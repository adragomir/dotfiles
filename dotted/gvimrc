" settings
set nocompatible              " use VI incompatible features
set noantialias
set noautochdir
set autowriteall
set ruler
set number                    " show line numbers
set mouse=a
set selectmode=mouse,key      " select model
set keymodel=startsel         ",stopsel
set autoread                  " read outside modified files
set directory=/tmp            " temp directory
set encoding=UTF-8            " file encoding
set formatoptions=tcrqn21     " auto format
"set textwidth=80              " text width
set guioptions=crbie"M"m		  " aA BAD
set history=10000             " number of history items
set ignorecase                " ignore case when searching
set smartcase                 " ignore case when searching
set hlsearch                  " highlight last search
set incsearch                 " show matches while searching
set laststatus=2              " always show status line
set scrolloff=2               " minlines to show around cursor
set sidescrolloff=4           " minchars to show around cursor
set shortmess=aTI           " supress some file messages
set showbreak=>               " character to show that a line is wrapped
set showcmd                   " show number of selected chars/lines in status
set showmatch                 " briefly jump to matching brace
set matchtime=1               " show matching brace time (1/10 seconds)
set showmode                  " show mode in status when not in normal mode
set nostartofline             " don't move to start of line after commands
set statusline=%-2(%M\ %)%5l,%-5v%<%F\ %m%=%(%-5([%R%H%W]\ %)\ %10([%Y]%{ShowFileFormatFlag(&fileformat)}\ %)\ %L\ lines%)
set undolevels=10000
set viminfo=%,h,'1000,"1000,:1000,n~/.viminfo
set virtualedit=block
set novisualbell
set noerrorbells
set whichwrap=<,>,h,l,b,s,~,[,]
set wildmenu
set wildmode=list:longest,full
set wildignore=*.o,*.obj,*.pyc,*.d
set winaltkeys=no
set writebackup
set writeany
set iskeyword+=@-@,48-57,128-167,224-235,_,"
set showtabline=2
set matchtime=0
set complete=.,w,b,u,t,i	" completion by Ctrl-N
set completeopt=menu,menuone
set gdefault

" settings: windows and buffers
"set noequalalways
set guiheadroom=0
" 	When off a buffer is unloaded when it is |abandon|ed.
set hidden
set splitbelow                " split windows below current one
set title

" settings: line endings
"set ff=unix
"set ffs=unix

" settings: grep
set grepprg=ack
set grepformat=%f:%l:%m

" settings: tabs and indenting
set autoindent
set smartindent
set smarttab
set indentexpr=none
set noexpandtab
set tabstop=4
let &sw=4

" look & feel
if has("gui_running")
  set noantialias
  set guifont=Terminus:h20
endif

nnoremap Q
nnoremap gQ

if has("gui_running")
  " behave mswin
  set selectmode=key,mouse
  set mousemodel=popup
  set keymodel=startsel,stopsel
  set selection=exclusive

  " source $VIMRUNTIME/mswin.vim
  " mswin.vim, INLINE
  " backspace and cursor keys wrap to previous/next line
  set backspace=indent,eol,start whichwrap+=<,>,[,]

  " backspace in Visual mode deletes selection
  vnoremap <BS> d

  " CTRL-X and SHIFT-Del are Cut
  vnoremap <D-X> "+x
  vnoremap <S-Del> "+x

  " CTRL-C and CTRL-Insert are Copy
  vnoremap <special> <D-C> "+y
  vnoremap <C-Insert> "+y

  " CTRL-V and SHIFT-Insert are Paste
  map <D-V>		"+gP
  map <S-Insert>		"+gP

  cmap <D-V>		<C-R>+
  cmap <S-Insert>		<C-R>+

  " Pasting blockwise and linewise selections is not possible in Insert and
  " Visual mode without the +virtualedit feature.  They are pasted as if they
  " were characterwise instead.
  " Uses the paste.vim autoload script.

  exe 'inoremap <script> <D-V>' paste#paste_cmd['i']
  exe 'vnoremap <script> <D-V>' paste#paste_cmd['v']

  imap <S-Insert>		<D-V>
  vmap <S-Insert>		<D-V>

  " Use CTRL-Q to do what CTRL-V used to do
  noremap <C-Q>		<C-V>

  " For CTRL-V to work autoselect must be off.
  " On Unix we have two selections, autoselect can be used.
  if !has("unix")
    set guioptions-=a
  endif

  " CTRL-A is Select all
  noremap <D-A> gggH<C-O>G
  inoremap <D-A> <C-O>gg<C-O>gH<C-O>G
  cnoremap <D-A> <C-C>gggH<C-O>G
  onoremap <D-A> <C-C>gggH<C-O>G
  snoremap <D-A> <C-C>gggH<C-O>G
  xnoremap <D-A> <C-C>ggVG
  " end mswin.vim


  "source $VIMRUNTIME/macmap.vim.old
  " macmap.vim.old INLINE
  vnoremap <special> <D-x> "+x
  vnoremap <special> <D-c> "+y
  cnoremap <special> <D-c> <C-Y>
  nnoremap <special> <D-v> "+gP
  cnoremap <special> <D-v> <C-R>+
  execute 'vnoremap <script> <special> <D-v>' paste#paste_cmd['v']
  execute 'inoremap <script> <special> <D-v>' paste#paste_cmd['i']

  nnoremap <silent> <special> <D-a> :if &slm != ""<Bar>exe ":norm gggH<C-O>G"<Bar> else<Bar>exe ":norm ggVG"<Bar>endif<CR>
  vmap <special> <D-a> <Esc><D-a>
  imap <special> <D-a> <Esc><D-a>
  cmap <special> <D-a> <C-C><D-a>
  omap <special> <D-a> <Esc><D-a>
  " end macmap.vim
endif

map H ^
map L $

colorscheme desert
highlight SignColor guibg=red guifg=White

" syntax highlightinh
syntax enable
syntax on
filetype on
filetype indent on
filetype plugin on

" enable autosaving
set updatecount=0 updatetime=500
autocmd CursorHold,CursorHoldI * silent! wall

" source my functions
" source $HOME/.vim/_mine/functions.vim
" start $HOME/.vim/_mine/functions.vim
function! SwapUp()
  if ( line( '.' ) > 1 )
    let cur_col = virtcol(".")
    if ( line( '.' ) == line( '$' ) )
      normal ddP
    else
      normal ddkP
    endif
    execute "normal " . cur_col . "|"
  endif
endfunction

function! SwapDown()
  if ( line( '.' ) < line( '$' ) )
    let cur_col = virtcol(".")
    normal ddp
    execute "normal " . cur_col . "|"
  endif
endfunction

function! MoveCursor(move, mode)
	if (a:move == 'h')
		if (a:mode == '0')
			normal 0
		elseif (a:mode =~ '^\^')
			if (a:mode == '^g')
				normal g^
			elseif (a:mode == '^n')
				normal ^
			endif
		endif
	elseif (a:move == 'e')
		if (a:mode =~ '^\$')
			if (a:mode == '$g')
				normal g$
			elseif (a:mode == '$n')
				normal $
			endif
		endif
	endif
endfunction

function! HomeKey()
	let oldmode = mode()
	let oldcol = col('.')
	call MoveCursor('h', '^n')
	let newcol = col('.')
	if (oldcol == newcol)
		if (&wrap != 1) || (newcol <= winwidth(0) - 20)
			call MoveCursor('h', '0')
			let lastcol = col('.')
			if (newcol == lastcol)
				if (newcol == oldcol)
					normal i
				else
					call MoveCursor('h', '^n')
				endif
			else
				call MoveCursor('h', '0')
			endif
		endif
	endif
endfunction

function! EndKey()
	call MoveCursor('e', '$g')
endfunction

function! StrMatchNo(haystack, needle)
	let LastMatch = match(a:haystack, a:needle)
	if LastMatch > -1
		let Result = 1
		while LastMatch > -1
			let LastMatch = match(a:haystack, a:needle, LastMatch+1)
			if LastMatch > -1
				let Result = Result + 1
			endif
		endwhile
	else
		let Result = 0
	endif
	return Result
endfunction

function! ConditionalExecute(action)
	if a:action == "write"
		if &modified == 1
			silent write
		endif
	elseif a:action == "quit"
		new
		execute "normal! \<C-w>\<C-w>"
		silent quit
	endif
endfunction

function! InsertBrace()
	if strpart(getline("."), col(".")-1, 1) != " "
		let s:seq = " "
	else
		let s:seq = ""
	endif
	let s:seq = s:seq . "{\<CR>}\<Left>\<CR>\<Up>\<Tab>"
	execute "normal a" . s:seq
endfunction

function! KeyMap(modifier, key, action, mode, target)
	if strlen(a:mode) > 0
		let s:mode = " <" . a:mode . "> "
	else
		let s:mode = " "
	endif
	if StrMatchNo(a:action, '<CR>') > 1 || a:action =~ 'e' || a:action !~ '<CR>$'
		let s:insert{"pre"} = " <Esc>"
		let s:insert{"post"} = "a"
	else
		let s:insert{"pre"} = " <C-o>"
		let s:insert{"post"} = ""
	endif
	if a:target =~ '_'
		let s:insert{"pre"} = " "
		let s:insert{"post"} = ""
	endif
	" modifier: <M> meta
	if a:modifier == "M"
		if a:target =~ 'n'
			execute "nnoremap" . s:mode . "<M-" . a:key . "> " . a:action
		endif
		if a:target =~ 'i'
			execute "inoremap" . s:mode . "<M-" . a:key . ">" . s:insert{"pre"} . a:action . s:insert{"post"}
		endif
		if a:target =~ 'v'
			execute "vnoremap" . s:mode . "<M-" . a:key . "> " . a:action
		endif
	" modifier: <D> meta
	elseif a:modifier == "D"
		if a:target =~ 'n'
			execute "nnoremap" . s:mode . "<D-" . a:key . "> " . a:action
		endif
		if a:target =~ 'i'
			execute "inoremap" . s:mode . "<D-" . a:key . ">" . s:insert{"pre"} . a:action . s:insert{"post"}
		endif
		if a:target =~ 'v'
			execute "vnoremap" . s:mode . "<D-" . a:key . "> " . a:action
		endif
	" modifier: <C> control
	elseif a:modifier == "C"
		let s:key = substitute(a:key, '[<>]', '', 'g')
		if a:target =~ 'n'
			execute "nnoremap" . s:mode . "<C-" . s:key . "> " . a:action
		endif
		if a:target =~ 'i'
			execute "inoremap" . s:mode . "<C-" . s:key . ">" . s:insert{"pre"} . a:action . s:insert{"post"}
		endif
		if a:target =~ 'v'
			execute "vnoremap" . s:mode . "<C-" . s:key . "> " . a:action
		endif
	" modifier: <S> shift
	elseif a:modifier == "C"
		let s:key = substitute(a:key, '[<>]', '', 'g')
		if a:target =~ 'n'
			execute "nnoremap" . s:mode . "<S-" . s:key . "> " . a:action
		endif
		if a:target =~ 'i'
			execute "inoremap" . s:mode . "<S-" . s:key . ">" . s:insert{"pre"} . a:action . s:insert{"post"}
		endif
		if a:target =~ 'v'
			execute "vnoremap" . s:mode . "<S-" . s:key . "> " . a:action
		endif
	" modifier: none
	else
		if a:target =~ 'n'
			execute "nnoremap" . s:mode . a:key . " " . a:action
		endif
		if a:target =~ 'i'
			execute "inoremap" . s:mode . a:key . s:insert{"pre"} . a:action . s:insert{"post"}
		endif
		if a:target =~ 'v'
			execute "vnoremap" . s:mode . a:key . " " . a:action
		endif
	endif
endfunction

function! OpenFileUnderCursor()
	let FileName = expand("<cfile>")
	if (!filereadable(FileName))
		if (filereadable("./" . FileName))
			let FileName = "./" . FileName
		else
			let cpwd = substitute(getcwd(), '\([^/]\)$', '\1/', '')
			let fpwd = substitute(FileName, '^.\{-}\(/.*/\).*$', '\1', '')
			if (match(cpwd, fpwd . '$'))
				let FileName = substitute(FileName, '^.*/\(.*\)$', '\1', '')
			endif
		endif
	endif
	let OldPath = getcwd()
	silent cd %:p:h
	if (filereadable(FileName))
	execute "silent sp +e " . FileName
	else
		echohl error
		echo "File '" . FileName . "' not found."
		echohl normal
	endif
	execute "silent cd " . OldPath
endfunction

function! GetStringBeforeCursor()
	return strpart(getline("."), 0, col("."))
endfunction

function! GetStringAfterCursor()
	return strpart(getline("."), col("."))
endfunction

function! GetWordBeforeCursor()
	return substitute(GetStringBeforeCursor(), '^.*\(\<\w\{-1,}\)\W*$', '\1', '')
endfunction

function! GetStringBeforeWord()
	return substitute(GetStringBeforeCursor(), '^.*\(\W\{-1,}\)\<\w\{-1,}\W*$', '\1', '')
endfunction

function! GetWordBeforeParen()
	return substitute(GetStringBeforeCursor(), '^.\{-}\(\<\w\{-1,}\)\s*(.*$', '\1', '')
endfunction

function! UpcaseWordBeforeCursor()
	let Line = substitute(GetStringBeforeCursor(), '^\(.*\)\(\<\w\{-1,}\)\(\W*\)$', '\1\U\2\E\3', '')
	call setline(".", Line . GetStringAfterCursor())
endfunction

function! GetWordUnder()
	let WordBeginning = substitute(GetStringBeforeCursor(), '^.*\<\(\w\{-1,}\)$', '\1', '')
	if match(GetStringAfterCursor(), '\w') == 0
		let WordEnd = substitute(GetStringAfterCursor(), '^\<\(\w\{-1,}\)\>.*$', '\1', '')
	else
		let WordEnd = ''
	endif
	let Word = WordBeginning . WordEnd
	return Word
endfunction

function! ColonComplete()
	normal! a:
endfunction

function! ShowFileFormatFlag(var) 
	if ( a:var == 'dos' ) 
		return '[DOS]' 
	elseif ( a:var == 'mac' ) 
		return '[MAC]' 
	else 
		return '[UNIX]' 
	endif 
endfunction

function! InsertDateTime()
	execute "normal a" . strftime("%A, %Y-%m-%d %H:%M:%S")
endfunction

function! CtagAdder(...)
	let index = 1
	let s:dir_list = ''
	while index <= a:0
		let s:dir_list = s:dir_list . TlGetDirs(a:{index})
		let index = index + 1
	endwhile
	call TlAddAddFiles(s:dir_list)
	wincmd p
	exec "normal ="
	wincmd p
endfunction

" Adds *.rb, *.rhtml and *.css files to TagList from a given list
" of dirs

function! TlAddAddFiles(dir_list)
	let dirlist = a:dir_list
	let s:olddir = getcwd()
	while strlen(dirlist) > 0
		let curdir = substitute (dirlist, '|.*', "", "")
		let dirlist = substitute (dirlist, '[^|]*|\?', "", "")
		exec "cd " . g:base_dir
		exec "TlistAddFiles " . curdir . "/*.rb"
		exec "TlistAddFiles " . curdir . "/*.rhtml"
		exec "TlistAddFiles " . curdir . "/*.css"
"		exec "TlistAddFiles " . curdir . "/*.js"
	endwhile
	exec "cd " . s:olddir
endfunction

" Gets all dirs within a given dir, returns them in a string,
" separated by '|''s

function! TlGetDirs(start_dir)
	let s:olddir = getcwd()
	exec "cd " . g:base_dir . '/' . a:start_dir
	let dirlist = a:start_dir . '|'
	let dirlines = glob ('*')
	let dirlines = substitute (dirlines, "\n", '/', "g")
	while strlen(dirlines) > 0
		let curdir = substitute (dirlines, '/.*', "", "")
		let dirlines = substitute (dirlines, '[^/]*/\?', "", "")
		if isdirectory(g:base_dir . '/' . a:start_dir . '/' . curdir)
			let dirlist = dirlist . TlGetDirs(a:start_dir . '/' . curdir)
		endif
	endwhile
	exec "cd " . s:olddir
	return dirlist
endfunction

function! GuiTabLabel()
	let label = v:lnum
	let bufnrlist = tabpagebuflist(v:lnum)

	" Add '+' if one of the buffers in the tab page is modified
	for bufnr in bufnrlist
        if getbufvar(bufnr, "&modified")
            let label .= '+'
            break
        endif
	endfor

	" Append the number of windows in the tab page if more than one
	let wincount = tabpagewinnr(v:lnum, '$')
	if wincount > 1
		let label .= wincount
	endif
	if label != ''
		let label .= ' '
	endif

	let guifname = bufname(bufnrlist[tabpagewinnr(v:lnum) - 1])
	let guifname = substitute(guifname, '^\(.*\)/\([^/]*\)$', '\2', '')
	" Append the buffer name
	return label . guifname
endfunction

function! OpenAllBuffersInTabs()
ruby << EOF
	require 'pp'
	numtabs = VIM::evaluate("tabpagenr('$')")
	buffers = []
	for i in 0..(VIM::Buffer.count - 1)
		buffers << VIM::Buffer[i]
	end
	buffers.each { |b|
		
	}
	puts numtabs
EOF
endfunction

function! GuiEnter()
set columns=150 lines=49
" open tabs for all the open buffers
let g:GuiEnter_tablist = []
for i in range(tabpagenr('$'))
   call extend(g:GuiEnter_tablist, tabpagebuflist(i + 1))
endfor
ruby << EOF
	require 'pp'
	numtabs = VIM::evaluate("tabpagenr('$')")
	buffers = []
	for i in 0..(VIM::Buffer.count - 1)
		buffers << VIM::Buffer[i]
	end
	puts numtabs
EOF
endfunction

" helper function to toggle hex mode
function! ToggleHex()
  " hex mode should be considered a read-only operation
  " save values for modified and read-only for restoration later,
  " and clear the read-only flag for now
  let l:modified=&mod
  let l:oldreadonly=&readonly
  let &readonly=0
  let l:oldmodifiable=&modifiable
  let &modifiable=1
  if !exists("b:editHex") || !b:editHex
    " save old options
    let b:oldft=&ft
    let b:oldbin=&bin
    " set new options
    setlocal binary " make sure it overrides any textwidth, etc.
    let &ft="xxd"
    " set status
    let b:editHex=1
    " switch to hex editor
    %!xxd
  else
    " restore old options
    let &ft=b:oldft
    if !b:oldbin
      setlocal nobinary
    endif
    " set status
    let b:editHex=0
    " return to normal editing
    %!xxd -r
  endif
  " restore values for modified and read only state
  let &mod=l:modified
  let &readonly=l:oldreadonly
  let &modifiable=l:oldmodifiable
endfunction

function! ContextSettings()
	"set indentexpr=none
	let l:NBuffers = bufnr('$')
	if l:NBuffers > 1 && bufexists(1) && buflisted(1) && !getbufvar(1, "&bufsecret")
		:bw 1
	endif
endfunction

function! OpenNewTabOnFileOpen()
	let fName = expand('<afile>')
	echom "fname: " . fName
	if fName != ""
		exe 'tablast | tabe <afile>'
	else
		exe 'tablast | tabnew'
	endif
endfunction

function! ToggleScratch()
  if expand('%') == g:ScratchBufferName
    quit
  else
    Sscratch
  endif
endfunction


" end $HOME/.vim/_mine/functions.vim

" commands
command! W :browse confirm saveas
command! -bar Hexmode call ToggleHex()

" key mappings
let mapleader = ","
let maplocalleader = ","

call KeyMap('', '<F3>', ':e %:p:s,.h$,.X123X,:s,.cpp$,.h,:s,.X123X$,.cpp,<CR>', '', 'n')
call KeyMap('', '<F7>', ':RTlist<CR>', '', 'niv')
call KeyMap('', '<F8>', ':Tlist<CR>', 'silent', 'n')
call KeyMap('', '<S-Space>', ':call ExpandTemplate(1)<CR>', 'silent', 'i')
call KeyMap('D', 'q', ':q<CR>', '', 'ni')
call KeyMap('D', 'Q', ':q!<CR>', '', 'ni')
call KeyMap('D', 'w' , ':call ConditionalExecute("write")<CR>', 'silent', 'ni')
call KeyMap('D', 'a' , 'gggH<C-O>G', 'silent', 'n')
call KeyMap('D', 'a' , '<C-O>gg<C-O>gH<C-O>G', 'silent', 'i')
call KeyMap('D', 'y' , '<C-R>', 'silent', 'n')
call KeyMap('D', 'y' , '<C-O><C-R>', 'silent', 'i')
call KeyMap('D', '`' , ':maca selectNextWindow:<CR>', 'silent', 'ni')
call KeyMap('D', 'W' , ':write!<CR>', 'silent', 'ni')
call KeyMap('D', '!', ':!!<CR>', 'silent', 'ni')
call KeyMap('D', '"', ':@:<CR>', 'silent', 'ni')
call KeyMap('', '<F9>', ':Tlist<CR>', 'silent', 'ni')
call KeyMap('D', 'd', ':bd<CR>', 'silent', 'ni')
call KeyMap('D', 'e', ':call OpenFileUnderCursor()<CR>', 'silent', 'ni')
call KeyMap('', '<Tab>', '>gv', 'silent', 'v')
call KeyMap('', '<S-Tab>', '<gv', 'silent', 'v')
call KeyMap('D', "'", ':call ExpandTemplate()<CR>', 'silent', 'i')
call KeyMap('C', 'z', ':u<CR>', 'silent', 'i')
call KeyMap('D', 's', ':set scb<CR>', 'silent', 'ni')
call KeyMap('D', 'S', ':set noscb<CR>', 'silent', 'ni')
call KeyMap('D', 'u', 'guaw', 'silent', 'ni')
call KeyMap('D', 'U', 'gUaw', 'silent', 'ni')
call KeyMap('D', 'E', ':e .<CR>', 'silent', 'ni')
call KeyMap('D', 'Up', ':call SwapUp()<CR>', 'silent', 'ni')
call KeyMap('D', 'Down', ':call SwapDown()<CR>', 'silent', 'ni')
call KeyMap('C', 'Space', '<C-p>', 'silent', 'ni')
call KeyMap('D', 'Space', '<C-X><C-O>', 'silent', 'ni')
call KeyMap('C', '<F2>', ':call Vm_toggle_sign()<CR>', 'silent', 'ni')
call KeyMap('', '<F5>', ':BufExplorer<CR>', 'silent', 'ni')
"call KeyMap('D', 'Space', ':simalt ~<CR>', 'silent', 'n')
"call KeyMap('', '<Down>', 'gj', 'silent', 'niv')
"call KeyMap('', '<Up>', 'gk', 'silent', 'niv')
"call KeyMap('', ':', ':call ColonComplete()<CR>', 'silent', 'i')
"call KeyMap('D', 'X', ':simalt ~x<CR>', 'silent', 'ni')
"call KeyMap('M', 'a', ':let &wrap = !&wrap<CR>', 'silent', 'ni')
"call KeyMap('D', 'X', ':simalt ~x<CR>', 'silent', 'nvi')
"call KeyMap('C', 'Space', '<C-w><C-w>', 'silent', 'n')
"call KeyMap('C', '1', ':buffer 11<CR>', 'silent', 'ni')
"call KeyMap('C', '2', ':buffer 12<CR>', 'silent', 'ni')
"call KeyMap('C', '3', ':buffer 13<CR>', 'silent', 'ni')
"call KeyMap('C', '4', ':buffer 14<CR>', 'silent', 'ni')
"call KeyMap('C', '5', ':buffer 15<CR>', 'silent', 'ni')
"call KeyMap('C', '6', ':buffer 16<CR>', 'silent', 'ni')
"call KeyMap('C', '7', ':buffer 17<CR>', 'silent', 'ni')
"call KeyMap('C', '8', ':buffer 18<CR>', 'silent', 'ni')
"call KeyMap('C', '9', ':buffer 19<CR>', 'silent', 'ni')
"call KeyMap('C', '0', ':buffer 20<CR>', 'silent', 'ni')
"call KeyMap('C', '_', ':<CR>', ':call Run_Snippet()', 'ni')
"call KeyMap('D', '`', ':macaction selectNextWindow:<CR>', 'silent', 'ni')
inoremap <C-space> <C-p>

" disable middle mouse pasting
map  <MiddleMouse>  <Nop>
map  <2-MiddleMouse>  <Nop>
map  <3-MiddleMouse>  <Nop>
map  <4-MiddleMouse>  <Nop>
imap  <MiddleMouse>  <Nop>
imap  <2-MiddleMouse>  <Nop>
imap  <3-MiddleMouse>  <Nop>
imap  <4-MiddleMouse>  <Nop>

inoremap <S-CR> <C-o>O
inoremap <C-CR> <C-o>o
inoremap <C-S-CR> <CR><C-o>O
inoremap <silent> <Home> <C-o>:call HomeKey()<CR>
nnoremap <silent> <Home> :call HomeKey()<CR>

set suffixes+=.lo,.o,.moc,.la,.closure,.loT
" Insert an include guard based on the file name on ,i
nmap <MapLocalLeader>h :AT<CR>
nmap ,h :AT<CR>
map <leader>s :call ToggleScratch()<CR>

" make word back / forward to be cooloer
"noremap W b
"noremap b W

" Disable recording
"nmap q <esc>
"vmap q <esc>

" tab keys
if has("gui_running")
  map <D-t> :tabnew<CR>
  map <D-n> :new<CR>
  map <D-S-t> :browse tabe<CR>
  map <D-S-n> :browse split<CR>
  map <D-]> :tabn<CR>
  map <D-[> :tabp<CR>
  imap <D-]> <C-o>:tabn<CR>
  imap <D-[> <C-o>:tabp<CR>
endif

if has("gui_running")
imap <D-1> <C-o>1gt<CR>
imap <D-2> <C-o>2gt<CR>
imap <D-3> <C-o>3gt<CR>
imap <D-4> <C-o>4gt<CR>
imap <D-5> <C-o>5gt<CR>
imap <D-6> <C-o>6gt<CR>
imap <D-7> <C-o>7gt<CR>
imap <D-8> <C-o>8gt<CR>
imap <D-9> <C-o>9gt<CR>
imap <D-0> <C-o>10gt<CR>
endif

if has("gui_running")
map <D-1> 1gt
map <D-2> 2gt
map <D-3> 3gt
map <D-4> 4gt
map <D-5> 5gt
map <D-6> 6gt
map <D-7> 7gt
map <D-8> 8gt
map <D-9> 9gt
map <D-0> 10gt
endif

" working with tabs
if has("gui_running")
  map <D-M-Right> :tabn<CR>
  map <D-M-Left> :tabp<CR>
  imap <D-M-Right> <C-o>:tabn<CR>
  imap <D-M-Left> <C-o>:tabp<CR>
endif

if !has("gui_running")
  noremap h <Esc>:tabprev<Cr>
  noremap l <Esc>:tabnext<Cr>
  noremap n <Esc>:tabnew<Cr>
  noremap c <Esc>:tabclose<Cr>
else
  " working with tabs
  noremap h <Esc>:tabprev<Cr>
  noremap l <Esc>:tabnext<Cr>
  noremap n <Esc>:tabnew<Cr>
  noremap c <Esc>:tabclose<Cr>
endif

" macros 
map ]xx :Explore<cr>2jp<c-w>H20<c-w><

" abbreviations
"cabbrev help vertical help
iabbrev mdy <C-r>=strftime("%Y-%m-%d %H:%M:%S")
iabbrev fi if
iabbrev fpritnf fprintf
iabbrev fro for
iabbrev pritnf printf
iabbrev stirng string
iabbrev teh the


" python syntax settings
let python_highlight_all = 1

" taglist settings
let Tlist_Ctags_Cmd = "/usr/bin/ctags"
let Tlist_Compact_Format = 1
let Tlist_File_Fold_Auto_Close = 1
let Tlist_Use_Right_Window = 1
let Tlist_Exit_OnlyWindow = 1
let Tlist_WinWidth = 40 

" ruby settings
let g:rubycomplete_buffer_loading = 1
let g:rubycomplete_classes_in_global = 1
let g:rubycomplete_rails = 1

" enhanced commentify
let g:EnhCommentifyBindInNormal = 'yes'
let g:EnhCommentifyBindInVisual = 'yes'

" omni cpp complete
let OmniCpp_GlobalScopeSearch = 1
let OmniCpp_NamespaceSearch = 2
let OmniCpp_DisplayMode = 1
let OmniCpp_ShowScopeInAbbr = 1
let OmniCpp_ShowPrototypeInAbbr = 1
let OmniCpp_ShowAccess = 1
let OmniCpp_DefaultNamespaces = ["std", "_GLIBCXX_STD"]

" tex
let g:tex_ignore_makefile = 1
let g:tex_flavor = "/usr/texbin/pdftex"

" auto commands
autocmd GUIEnter * call GuiEnter()
autocmd Filetype ruby let b:foldsearchprefix='\v^\s*(#.*)?$'
autocmd BufRead *.mxml set filetype=xml
autocmd! FileType xml,sgml,entity,xslt,svg,xhtml,xsl,xsd
	\ if !exists("b:match_words") |
	\ let b:match_ignorecase=0 | let b:match_words =
	\ '<:>,' .
	\ '<\@<=!--:-->,'.
	\ '<\@<=?\k\+:?>,'.
	\ '<\@<=\([^ \t>/]\+\)\%(\s\+[^>]*\%([^/]>\|$\)\|>\|$\):<\@<=/\1>,'.
	\ '<\@<=\%([^ \t>/]\+\)\%(\s\+[^/>]*\|$\):/>'
	\ | endif
autocmd BufNewFile,BufRead *.html let g:snip_start_tag = "@"
autocmd BufNewFile,BufRead *.html let g:snip_end_tag = "@"
autocmd BufNewFile,BufRead *.mxml,*.as :nmap <C-B> :!bash /Users/adragomi/work/flex/sdk/bin/fcshcmp.sh %:p
autocmd FileType python set omnifunc=pythoncomplete#Complete
autocmd FileType python setlocal autoindent expandtab
autocmd BufRead *.as set filetype=actionscript

set guitablabel=%{GuiTabLabel()}

" python
python << EOF
import os
import sys
import vim
for p in sys.path:
    if os.path.isdir(p):
        vim.command(r"set path+=%s" % (p.replace(" ", r"\ ")))
EOF
set tags+=$HOME/.vim/tags/python.ctags
autocmd FileType python set omnifunc=pythoncomplete#Complete
autocmd BufRead *.py set makeprg=python\ -c\ \"import\ py_compile,sys;\ sys.stderr=sys.stdout;\ py_compile.compile(r'%')\"
autocmd BufRead *.py set efm=%C\ %.%#,%A\ \ File\ \"%f\"\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m

python << EOL
import vim
def EvaluateCurrentRange():
	eval(compile('\n'.join(vim.current.range),'','exec'),globals())
EOL
map <C-h> :py EvaluateCurrentRange()

" autocmds to automatically enter hex mode and handle file writes properly
if has("autocmd")

  " vim -b : edit binary using xxd-format!
  augroup Binary
    autocmd!
    autocmd BufReadPre *.bin,*.hex setlocal binary
    autocmd BufReadPost *
          \ if &binary | Hexmode | endif
    autocmd BufWritePre *
          \ if exists("b:editHex") && b:editHex && &binary |
          \  let oldro=&ro | let &ro=0 |
          \  let oldma=&ma | let &ma=1 |
          \  exe "%!xxd -r" |
          \  let &ma=oldma | let &ro=oldro |
          \  unlet oldma | unlet oldro |
          \ endif
    autocmd BufWritePost *
          \ if exists("b:editHex") && b:editHex && &binary |
          \  let oldro=&ro | let &ro=0 |
          \  let oldma=&ma | let &ma=1 |
          \  exe "%!xxd" |
          \  exe "set nomod" |
          \  let &ma=oldma | let &ro=oldro |
          \  unlet oldma | unlet oldro |
          \ endif
  augroup END

  autocmd! BufWritePost *
    \ if &diff == 1 |
    \ :diffupdate | 
    \ endif
endif

"set noantialias
