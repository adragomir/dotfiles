#!ruby

require 'open3'

Commit = Struct.new(:id, :message, :branch) do
  def marker()
    tmp = message[/^\[(?<marker>[a-zA-Z0-9\-]*)\]/, 'marker']
    return tmp unless tmp.nil?

    tmp = message[/^(?<marker>[A-Z0-9]+\-[0-9]+)/, 'marker']
    return tmp unless tmp.nil?

    nil
  end

  def branch()
    data = /^\[([A-Z0-9]*\-(X+|[0-9]+))\] /.match(message)
    data[0]
  end
end
PR = Struct.new(:base, :marker, :head)

def commits_range(commits, pr)
  range = []
  in_range = false
  commits.each_with_index{|c, i|
    if commits[i].id == pr.marker.id
      in_range = true
    end
    if in_range
      range.push(c)
    end
    if commits[i].id == pr.head.id
      in_range = false
    end
  }
  range
end

def find_extents(commits)
  extent = {
    start_index: -1,
    end_index: -1,
    marker: nil
  }
  extents = []
  commits.each_with_index do |commit, i|
    marker = commit.marker()
    if extent[:marker].nil? && marker.nil?
      raise 'First commit is not a marker ! Exiting'
    end

    if !marker.nil? # we found a marker !
      if !extent[:marker].nil?
        if marker == extent[:marker]
          # continue extent
          extent[:end_index] = i
        else
          # end extent
          extents.push([extent[:start_index], extent[:end_index]])
          extent = {
            start_index: i,
            end_index: i,
            marker: marker
          }
        end
      else
        # here, we have a marker, but there is no current extent
        extent = {
          marker: marker,
          start_index: i,
          end_index: i
        }
      end
    else
      if extent[:marker].nil?
      end
      extent[:end_index] = i
    end
    if i == commits.length - 1
      extents.push(extent.clone) unless !extent[:marker].nil?
    end
  end
  extents
end

require 'optparse'
options = {
  master_branch: 'master',
  push_only: false,
  all_commits: false,
  split: false
}
OptionParser.new do |opts|
  opts.banner = 'Usage:  [options]'

  opts.on('-a', '--all-commits', '') do
    options[:all_commits] = true
  end
  opts.on('-p', '--push-only', '') do
    options[:push_only] = true
  end
  opts.on('-b BRANCH', '--branch=BRANCH', '') do |v|
    options[:master_branch] = v
  end
end.parse!

current_branch = %x(git rev-parse --symbolic-full-name --abbrev-ref HEAD).strip
root_dir = %x(git rev-parse --show-toplevel).strip()

commits = %x{git rev-list --reverse "#{options[:master_branch]}..#{current_branch}"}.split("\n").map { |c|
  Commit.new(c, %x(git log -1 --pretty=format:%s "#{c}").strip)
}
# cleanup commits
commits = commits.reverse.drop_while { |c| c.message =~ /^IGNORED /i }.reverse
extents = find_extents(commits, options[:all_commits])

extents.each do |extent|
  puts %( git stash
    git branch -D #{extent.marker}
    git checkout -b #{extent.marker} master
    git cherry-pick #{commits[extent.start_index].id}^..#{commits[extent.end_index].id}
    git push -f origin #{extent.marker}:#{extent.marker}
  )
  puts " hub pull-request -f -m \"#{commits[extent.start_index].message}\" -b #{base_name} -h #{extent.marker}"

  puts %{ git checkout #{current_branch}
    git stash pop
    # ----
  }
end
