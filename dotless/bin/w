#!/usr/bin/env ruby 

require 'optparse' 
require 'rdoc/usage'
require 'ostruct'
require 'date'

class Entry

  TITLE_RE = /^\+\+\+(\+*)\s*(.+)\s*$/

  attr_accessor :name, :content, :metadata, :time, :order

  def initialize(name)
    @name = name
    @content = ""
    @metadata = {}
    @time = {}
    @folder = nil
    @file = nil
    @index = -1
  end

  def deserialize(content, opts={})
    @metadata = {}
    @content = ""

    lines = content.to_a
    return unless ! ( lines.nil? || lines.length == 0 )

    include_name = opts[:include_name] # default is true
    if include_name
      @name = lines.shift().gsub(/^\s*\+*\s*/, "").strip()
    end

    while (1 and lines.length > 0) do
      l = lines.shift()
      # stop when you get an empty line
      begin
        raise "error" unless l.strip() != ""
        result = l.scan(/^\* ([a-zA-Z]*) : (.*)$/).flatten()
        raise "error" unless result.length == 2
        k, v = result[0], result[1]
        @metadata[k] = v
      rescue
        lines.unshift(l)
        break
      end
    end
    @content = lines.to_s
  end

  def serialize(opts={})
    include_name = opts[:include_name] || false 
    t = ""
    if include_name
      t += "+++ #{@name}\n"
    end

    @metadata.each { |k, v|
      t += "* #{k} : #{v}\n"
    }

    t += @content
    return t
  end

  def index
    @index = (@metadata["index"] || @index).to_i
    return @index
  end

  def index=(v)
    @index = v
    @metadata["index"] = @index.to_s
  end

  def compute_dir_and_file()
    if @folder.nil?
      @folder = File.dirname(@name).split("/").inject("") { |memo, dir| memo += dir + "@" + "/" unless dir == '.' }
      @folder ||= ""
      @file = File.basename(@name)
    end
  end

  def dir()
    compute_dir_and_file
    return @folder
  end

  def file()
    compute_dir_and_file
    return @file
  end

end

class RollingEntry < Entry
  def add(text)

  end
end

class Wiki
  attr_accessor :pages

  def initialize
    @pages = []
  end

  def parse_from_file(file)
    index = 0
    wiki_string = IO.read(file)
    mark, offset, index = nil, 0, 0
    while 1 do
      page_start = wiki_string.index(/(^\+\+\+\+*\s*.+\s*$)/, offset)
      if page_start.nil?
        # we are at last page. Dump to end
        page_content = wiki_string[mark..wiki_string.length-1]

        p = Entry.new("")
        p.deserialize(page_content, {:include_name => true})
        @pages[index] = p
        p.index, index = index, index+1
        break
      else
        # we found a page start, must mark it and continue
        if !mark.nil?
          page_content = wiki_string[mark..page_start-1]

          p = Entry.new("")
          p.deserialize(page_content, {:include_name => true})
          @pages[index] = p
          p.index, index = index, index+1

          mark = page_start
          offset = page_start + $1.length
        else
          # the mark was nil, we are at the first page
          mark = page_start
          offset = page_start + $1.length
        end
      end
    end
  end

  def parse_from_folder(folder, sort_by=:index)
    Dir[folder + "/**/*"].each { |f|
      next unless File.file?(f)
      file_name = f
      f = f[folder.length..f.length]
      prefix = f[0..f.rindex("/")]
      name = f[f.rindex("/")+1 .. f.length]

      splits = prefix.split("/").reject! { |piece| piece == "" }
      page_name = splits.nil? ? name : splits.inject("") { |memo, p| memo += p[0..p.length-2] + "/"  } + name
      p = Entry.new(page_name)
      p.deserialize(IO.read(file_name), {
        :include_name => false
      })
      @pages.push(p)
    }
    new_pages, pages = @pages.partition{ |p| p.index < 0 }
    @pages = pages + new_pages
  end

  def set_order(order)
    case order
      when "index": pages.sort! { |a, b| a.index <=> b.index  }
      when "folder": pages.sort! { |a, b| a.name <=> b.name  }
    end
  end
end

class App
  VERSION = '0.0.1'
  attr_reader :options
  def initialize(arguments, stdin)
    @arguments = arguments
    @stdin = stdin
    @options = OpenStruct.new
    @command = :none
    @file = nil
    @ordering = "index"
  end
  def run
    if parsed_options? && arguments_valid? 
      puts "Start at #{DateTime.now}\\n\\n" if @options.verbose
      process_arguments            
      process_command
      puts "\\nFinished at #{DateTime.now}" if @options.verbose
    else
      output_usage
    end
      
  end
  
  protected
    def parsed_options?
      opts = OptionParser.new 
      opts.on('-h', '--help')       { output_help }
      opts.on('-e', '--explode')    { @command = :explode }  
      opts.on('-i', '--implode')    { @command = :implode }  
      opts.on('-o', '--reorder ORDERING')    { |v| @ordering = v }  
      opts.parse!(@arguments) rescue return false
      true      
    end
    def arguments_valid?
      true
    end
    def process_arguments
    end
    def output_help
      RDoc::usage() #exits app
    end
    # usage mumu
    def output_usage
      RDoc::usage('usage') # gets usage from comments above
    end
    def process_command
      send(@command)
    end
    def process_standard_input
      input = @stdin.read      
    end

    def explode
      w = Wiki.new()
      w.parse_from_file(@arguments[0])
      folder = @arguments[1] + "/" || "./exploded/"
      w.set_order(@ordering)
      w.pages.each { |p|
        FileUtils.mkdir_p(folder + p.dir())
        File.open(folder + p.dir() + p.file(), "wb+") { |f|
          f.write(p.serialize)
        }
      }
    end

    def implode
      w = Wiki.new()
      w.parse_from_folder(@arguments[0])
      file = @arguments[1] || "imploded.txt"
      w.set_order(@ordering)
      File.open(file, "wb+") { |output|
        w.pages.each { |p|
          output.write(p.serialize({:include_name => true}))
        }
      }
    end

    def reorder
      
    end

    def self_test
      puts "AAAAAAAAAAAAAA"
      p = Entry.new("")
      p.deserialize( <<EOD
  +++ folder/first page
  k: v
  altk: altv

  actual content
  asdasdasdas
  actual content
  asdasdasdas
  actual content
  asdasdasdas
EOD
      )
      puts p.name
      puts p.metadata
      puts p.content

    end
end

app = App.new(ARGV, STDIN)
app.run
# vim: set ai tw=80 expandtab sw=2 ts=2
