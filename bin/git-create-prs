#!/usr/bin/ruby

require 'open3'

Commit = Struct.new(:id, :message) do
  def marker()
    tmp = message[/^\[(?<marker>[a-zA-Z0-9\-]*)\]/, 'marker']
    return tmp unless tmp.nil?

    tmp = message[/^(?<marker>[A-Z0-9]+-[0-9]+)/, 'marker']
    return tmp unless tmp.nil?

    nil
  end

  def branch()
    data = /^\[([A-Z0-9]*-(X+|[0-9]+))\] /.match(message)
    data[0]
  end
end
PR = Struct.new(:base, :marker, :head)

def commits_range(commits, pull_request)
  range = []
  in_range = false
  commits.each_with_index do |c, i|
    in_range = true if commits[i].id == pull_request.marker.id
    range.push(c) if in_range
    in_range = false if commits[i].id == pull_request.head.id
  end
  range
end

def find_extents(commits)
  extent = {
    start_index: -1,
    end_index: -1,
    marker: nil
  }
  extents = []
  commits.each_with_index do |commit, i|
    marker = commit.marker()
    if extent[:marker].nil? && marker.nil?
      raise 'First commit is not a marker ! Exiting'
    end

    if !marker.nil? # we found a marker !
      if !extent[:marker].nil?
        if marker == extent[:marker]
          # continue extent
          extent[:end_index] = i
        else
          # end extent, and restart with next
          extents.push(extent)
          extent = {
            start_index: i,
            end_index: i,
            marker: marker
          }
        end
      else
        # here, we have a marker, but there is no current extent
        extent = {
          marker: marker,
          start_index: i,
          end_index: i
        }
      end
    else
      if !extent[:marker].nil?
        extent[:end_index] = i
      end
    end
    if i == commits.length - 1
      extents.push(extent.clone) unless extent[:marker].nil?
    end
  end
  extents
end

require 'optparse'
options = {
  push_only: false,
  split: false
}
OptionParser.new do |opts|
  opts.banner = 'Usage:  [options]'

  opts.on('-p', '--push-only', '') do
    options[:push_only] = true
  end
end.parse!

current_branch = %x(git rev-parse --symbolic-full-name --abbrev-ref HEAD).strip

commits = %x{git rev-list --reverse "origin/#{current_branch}..#{current_branch}"}.split("\n").map { |c|
  Commit.new(c, %x(git log -1 --pretty=format:%s "#{c}").strip)
}
extents = find_extents(commits)

extents.each_with_index do |extent, i|
  if i == 0
    base_name = current_branch
  else
    base_name = extents[i - 1][:marker]
  end

  if !options[:push_only]
    puts %(
      git push -f origin #{commits[extent[:end_index]].id}:refs/heads/#{extent[:marker]}
      hub pull-request -f -m \"#{commits[extent[:start_index]].message}\" -b #{base_name} -h #{extent[:marker]}
    )
  else
    puts %(
      git push -f origin #{commits[extent[:end_index]].id}:refs/heads/#{extent[:marker]}
    )
  end
end
