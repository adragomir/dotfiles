#!/usr/bin/env bash

# Iterates over Godep file dependencies and sets the specified version on each of them.
set_dependencies() {
  local deps=$(sed 's/#.*//;/^\s*$/d' < $1) || echo ""

  while read package version; do
    (
      echo ">> Getting package "$package""
      go get -u -d "$package"
    ) &
  done < <(echo "$deps")
  wait

  while read package version; do
    (
      echo ">> Setting $package to version $version"
      local pkg_path=$(echo "$package" | awk -F/ '{print $1"/"$2"/"$3}')
      set_package_to_version $pkg_path "$version"
    ) &
  done < <(echo "$deps")
  wait
  echo ">> All Done"
}

link() {
  to=$1
  from=${2:-$PWD}
  echo "From: $from"

  [[ -d "$from" ]] || return

  echo ">> Linking $from/* to $to"

  [[ ! -d $to ]] && mkdir -p $to
  for f in $from/*; do 
    [[ "$f" =~ "Godeps" || "$f" =~ ".godeps" ]] && continue
    bf=$(basename $f)
    echo ">> Linking $from/$bf to $to/$bf..."
    ln -vs $from/$bf $to/$bf
  done
}

bootstrap() {
  echo ">> Installing dependencies."
  go get -d
  dependencies=`go list -f '{{join .Deps "\n"}}' ./... | xargs go list -f '{{if not .Standard}}{{.ImportPath}}{{end}}'`
  lines=$(echo $dependencies | sed '/^$/d' | wc -l)

  [[ $lines > 0 ]] && (
    while read package; do
      (
        package_and_version=`find_package_and_last_tag_or_head "$package"`
        IFS=" " read p v <<< $package_and_version
        echo ">> Adding package "$p" version "$v" to Godeps."
        echo ""$p" "$v"" >> Godeps
        set_package_to_version $p $v
      )
    done < <(echo "$dependencies")
  )

  wait
  [[ -f Godeps ]] && sort -u -o Godeps Godeps
  echo ">> All Done."
}

# Sets a given package to a given revision using the appropriate VCS.
set_package_to_version() {
  cd "${GOPATH%%:*}/src/${1%%/...}"

  [[ -e "$PWD/.git/index.lock" || -e "$PWD/.hg/store/lock"  || -e "$PWD/.bzr/checkout/lock" ]] && wait

  [ -d .hg ]  && hg update    -q      "$2"
  [ -d .git ] && git checkout -q      "$2"
  [ -d .bzr ] && bzr revert   -q -r   "$2"
}

find_package_and_last_tag_or_head() {
  folder="${GOPATH%%:*}/src/${1%%/...}"
  tmp=$folder
  cd $folder

  # If no repo file is found it means we are inside a repo's subdirectory tree, we can just ignore this package.
  while [ ! -d .git ] && [ ! -d .bzr ] && [ ! -d .hg ]; do
    tmp=$(dirname $tmp)
    cd $tmp
  done
  echo ">> Found root package $tmp" 1>&2

  [[ -e "$PWD/.git/index.lock" || -e "$PWD/.hg/store/lock"  || -e "$PWD/.bzr/checkout/lock" ]] && wait

  real_package="${tmp##$GOPATH/src/}"
  [ -d .git ] && (
    # FIXME: there should be a better way,  but git tags returns in alphabetical order.
    version=`git tag | xargs -I@ git log --format=format:"%ai @%n" -1 @ | sort | awk '{print $4}' | tail -1`
    [ -n "$version" ] && echo "$real_package $version" && return
    version=`git log -n 1 --pretty=oneline | cut -d " " -f 1`
    echo ">> No tags on package "$1", setting version to latest revision." 1>&2
    echo "$real_package $version" && return
  )

  [ -d .bzr ] && (
    version=`bzr tags | tail -1 | cut -d " " -f 1`
    [ -n "$version" ] && echo "$real_package $version" && return
    version=`bzr log -r-1 --log-format=line | cut -d ":" -f 1`
    echo ">> No tags on package "$1", setting version to latest revision." 1>&2
    echo "$real_package $version" && return
  )

  [ -d .hg ] && (
    version=`hg parents --template "{latesttag}"`
    [ "$version" != "null" ] && echo "$real_package $version" && return
    version=`hg log --template "{node}" -l 1`
    echo ">> No tags on package "$1", setting version to latest_revision." 1>&2
    echo "$real_package $version" && return
  )

  echo " "
}

deps_build() {
  local deps=$(sed 's/#.*//;/^\s*$/d' < $1) || echo ""
  while read package version; do
    echo ">> Pre-building $package/..."
    go install $package/...
    echo ">> Pre-building $package"
    go install $package
  done < <(echo "$deps")
}

## /Functions

usage() {
cat << EOF
SYNOPSIS

    A Godeps file in the root of your Go application is expected containing
    the import paths of your packages and a specific tag or commit hash
    from its version control system, an example Godeps file looks like this:

    $ cat Godeps
    # This is a comment
    github.com/nu7hatch/gotrail         v0.0.2
    github.com/replicon/fast-archiver   v1.02   #This is another comment!
    github.com/nu7hatch/gotrail         2eb79d1f03ab24bacbc32b15b75769880629a865

USAGE
      Version information
      $ gvm version

      Parses all the go package dependencies, saves them into the Godeps file&
      $ gvm bootstrap 

      Set the package name and make a symlink
      $ gvm self github.com/test/test

      Parses the Godeps file, installs dependencies and sets them to the appropriate version.
      $ gvm install

      Builds all the dependencies
      $ gvm prebuild
EOF
}

## Command Line Parsing
(which go > /dev/null) || ( echo ">> Go is currently not installed or in your PATH" && exit 1)

case "${1:-"install"}" in
  "help")
    usage
    ;;
  "version")
    echo ">> gvm v0.1"
    ;;
  "install")
    deps_file="${2:-"Godeps"}"
    [[ -r "$deps_file" ]] || (echo ">> $deps_file file does not exist." && exit 1)
    GOPATH=$(PWD)/.godeps set_dependencies $deps_file
    ;;
  "prebuild")
    godeps_file="Godeps"
    [[ -f $godeps_file ]] || (echo ">> $godeps_file does not exist." && exit 1)
    [[ -f $godeps_file ]] && GOPATH=$(PWD)/.godeps deps_build $godeps_file
    wait
    echo ">> All Done"
    ;;
  "test")
    for f in ./*; do 
      [[ "$f" =~ "Godeps" || "$f" =~ ".godeps" ]] && continue
      #( file "$PWD/$f" | grep "executable" ) || continue
      echo $(basename $f)
      [[ -d "$f" ]] && echo ">> Linking .godeps/src/$2/$f to $f"
      [[ -f "$f" ]] && echo "linking file .godeps/src/$2/$f to $f"
    done
    ;;
  "self")
    [[ "${2:-""}" == "" ]] && exit 1
    echo ">> Setting package name to $2"
    link ".godeps/src/${2}"
    ;;
  "bootstrap")
    [[ -f "Godeps" ]] && echo ">> A Godeps file exists within this directory." && exit 1
    mkdir -p .godeps/{src,pkg,bin}
    bootstrap
    if [ ! -z "${2:-}" ]; then
      link $2
    fi
    ;;
  "run" | "in")
    do=1
    if [[ -n $GVM_NAME ]]; then
      echo ">> Already set path to $GOPATH, exiting..."
      do=0
    fi

    mkdir -p .godeps/{src,pkg,bin}
    GVM_DIR="$(pwd)/.godeps"

    if [[ ! -d $GVM_DIR ]]; then
      echo '>> Directory .godeps not found. Run `gvm init` first.'
      do=0
    fi

    if [ "$do" -eq "1" ]; then
      GVM_OLD_GOPATH=$GOPATH
      GVM_OLD_GOBIN=$GOBIN
      GVM_OLD_PATH=$PATH
      export GVM_OLD_GOPATH GVM_OLD_GOBIN PATH

      GVM_NAME=$(pwd | sed -E "s/^.*\/(.*)$/\\1/")
      GOBIN="$GVM_DIR/bin"
      GOPATH="$GVM_DIR:$PWD"
      PATH="$GOBIN:$PATH"

      export GOBIN GOPATH GVM_NAME PATH
      echo ">> Local GOPATH set."

      if [[ -n $2 ]]; then
        echo ">> Running ${@:2}"
        eval ${@:2}
      fi
    fi
    ;;
  "out")
    do=1
    if [[ -z $GVM_NAME ]]; then
      echo ">> Already reverted, exiting..."
      do=0
    fi

    if [ "$do" -eq "1" ]; then
      GOBIN=$GVM_OLD_GOBIN
      GOPATH=$GVM_OLD_GOPATH
      PATH=$GVM_OLD_PATH

      export PATH GOPATH GOBIN
      unset GVM_OLD_GOPATH GVM_OLD_GOBIN GVM_OLD_PATH GVM_NAME
      echo ">> Reverted to system GOPATH."
    fi
    ;;
esac
