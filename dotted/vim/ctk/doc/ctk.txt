*ctk.txt*	Plugin for compile and run your source code in Vim

ctk - Compile Toolkit					*ctk* *CTK*
    Wroten by StarWing <weasley_wx AT qq DOT com>
Last Change: 2010-01-28 21:04:52

|ctk-description|	Description
|ctk-options|		Option
|ctk-usage|		Usage
|ctk-features|		Features
|ctk-contact|		Contact

For Vim version 7.0 or later.
{Vi does not have any of these features.}

==============================================================================
DESCRIPTION						*ctk-description*

ctk.vim makes you easily and freely compiler your source code on you own way.
it read several modeline in your file to modify the behavior your command do,
such as change command flags, add redirect when exec it, etc.  You can define
your own hotkey to invoke ctk, and do any happy things with it.

the most usefull function of ctk is its modeline. you can just add a line in
your source code: |ctk-modeline|
>
 /* cc-gcc: flags+='-mwindows' */
<
then, if you have a compiler_info line (|ctk-info-line|) in your cinfo file
(defualtly as .compiler_info |ctk-cinfo-file|) like:
>
 SetCompilerInfo gcc cmd='gcc $input $flags -o $output' run='!$output'
<
you will find that you can invoke your compiler (use "gc" |ctk-hotkey|) with
this command line: |ctk-cmd-type|
>
 gcc source.c -Wall -mwindows -o source
<
and, after compile, you can run it, just press the hotkey you defined, or "gC"
in normal mode.

==============================================================================
USAGE								*ctk-usage*

								  *ctk-hotkey*

you can press hotkey to invoke compiler to compile your code, or invoke the
program generated by compiler. default hotkey is gc, you can add <count>
before it to specified which compiler you want to invoke. default run hotkey
is gC. to define specified hotkey, see |ctk-hotkey-tag|.

CTK commands		   					*ctk-commands*

								   *:StartCTK*
								    *:StopCTK*
:StartCTK[!]
:StopCTK
		start to use CTK, or stop CTK. or you can use StartCTK to
		refresh your cinfo file after you modified it.

		with '!', StartCTK will also reload and refresh current
		compiler info.

								 *:RefreshCTK*
:RefreshCTK
		reload the CTK compiler info file and refresh all displayed
		buffers in Vim.

:[N]CC[!] {entry}
		this command is used to invoke specified compiler. [N] is your
		compiler index. you can see it in :ListCompiler command
		|:ListCompiler|. {entry} is the command you invoke, in this
		way you can use any command in a single info line.  it will be
		discussed in |ctk-entry-tag|.
		
		if the compiler command is executed a extern program, the
		quickfix window will open if compiler return nonzero.
		otherwise, the compiler output will display, if any.

		With [!] and you doesn't have an entry, it uses a empty entry,
		that is, invoke "cmd" tag in your info line. and it invokes
		the entry you used last time without [!].

									*:RUN*
:[N]RUN[!] {entry}
		run the program generated by compiler. if you change your
		source code after compiling or the index [N] or {entry} isn't
		the same with the ones when you invoke compiler, the compiler
		will be invoked first to compile your code again.

		[!] will pass to :CC, if need.

			NOTE: if the compiler command is ":foobar" (that is,
			      exec a Vim command) and it has some output, the
			      Run command will be not executed. you should run
			      :RUN again. if you don't want this side-effect.
			      just use ':silent ....' in your compiler
			      command.


								   *:AddFlags*
:AddFlags {flags}
		add a modeline to source code. contains all texts in {flags}.
		see |ctk-modeline|.

							       *:ListCompiler*
:ListCompiler [all | current | default | {name}]
		list compilers ctk support now. 'all' means list all compilers.
		and 'current' means list the compiler just compiled your code.
		'default' means the attributes in your SetDefaultInfo
		sentence.  or a specified name to list this compiler's
		attributes.

		NOTE: you can press <TAB> to complete all names above.

							   *:EditCompilerInfo*
:EditCompilerInfo
		edit your cinfo file.

							   *:SetExtensionName*
:SetExtensionName {name}
		set the default extension name for specified filetype. ctk.vim
		uses this to generate name for new buffer. put it into your
		cinfo file. (with autocmd, e.g.: >

		    autocmd ruby SetExtensionName rb
<
		this will set ruby program's default extension name to 'rb',
		so ctk.vim will generate name "noname.rb" for ruby file,
		instead of "noname.ruby" (that's default, use 'filetype' as
		extension name).


							     *:SetDefaultInfo*
:SetDefaultInfo[!] {attr}="value" {attr2}=!value2! ...

		set default info for this filetype. add this command in your
		cinfo file if this is your default value, or it won't be saved
		after you leave Vim!

		you can use anything to replace '"' or '!' to around values.

		With [!] it delete the old default value of this buffer.
		Without [!] it just modify (add or edit) the tags in current
		default values.

							    *:SetCompilerInfo*
:SetCompilerInfo
		just like :ListCompiler all, list all info lines of current
		buffer.

:SetCompilerInfo!
		delete all info lines of current buffer.

:SetCompilerInfo {name}
		list compiler info of {name}, just like :ListCompiler {name}.

:SetCompilerInfo! {name}
		delete specified name from current buffer.

:SetCompilerInfo {name} {attr}="value" {attr2}=!value2|
		same as SetDefaultInfo. but this is for setting attributes for
		specified compiler. see |ctk-set-compiler-info|

:SetCompilerInfo! {name} {attr}="value" {attr2}=!value2|
		same as SetCompilerInfo without [!] above, but delete the
		specified compiler info first.


							     *ctk-auto-rename*

When you use ctk.vim. It will check all files you open. if you open a new file
 which its filetype has some info line in your cinfo file, the new file will
 be renamed by ctk.vim. it only happens when g:ctk_autofname isn't empty
 |ctk_autofname|.  this option controls the way that ctk.vim product the new
 filename.

if a file has a autocreated name, this name will be used in compile. when you
conpile it, it will be saved in a temporary folder |ctk_tempdir|. but the
executable output program will be dropped in your current folder (except when
current folder is $VIM, in this case program will be dropped to temporary
folder).  the executable program will be named to the value of g:ctk_defoutput
|ctk_defoutput|.

ctk.vim will use several way to detect the extension name of your source.
first it read the value of variable b:{g:ctk_ext_var}  |curly-braces-names|
you can set this variable manually, or drop it into your cinfo file: >
 autocmd FileType ruby let b:{g:ctk_ext_var} = 'rb'
>
or simply use SetExtensionName command (in cinfo file or manually): >
 autocmd FileType ruby SetExtensionName rb
<
see |ctk-fileext-define| for details.

								*ctk-modeline*

you can use modeline in your source code to specified the special flags. just
add a line: >

 /* cc: flags+='foobar' */
<
where the cc: will be recognized as a signature of modeline. you can also use
cc-gcc: to specifie gcc-specified settings. the "flags" is a attribute name in
SetCompilerInfo or SetDefaultInfo |ctk-def-attr|. and gcc is the name of a
info line |:SetCompilerInfo|. you can use anything to replace "'", just like
in SetCompilerInfo. |ctk-info-format|

							 *ctk-modeline-format*
the format of modeline is: >

 com-start cc[-compiler_name]: <tag> [+]= ?any thing? com-end
<
where com-start and com-end are the comment start sign and end sign, they can
be empty. 'cc' is the signature of modeline, compiler_name is a specified
compiler info line name. it's optional, and if you offer it, this modeline
will only effect when you invoke the specified compiler.

tag can be any undercase letter. it discussed at |ctk-info-tag|.

if you use tag += 'foobar', then foobar will be added to the value of tag.
e.g. if the value of tag "flags" is "-Wall", "flags += '-mwindow'" will change
flags into '-Wall -mwindow'.

another example, if we don't have a tag named 'flags', "flags = '-Wall'" will
define a new tag and set its value to '-Wall'.

you can use command :AddFlags to add a modeline in your file |:AddFlags|.

there are several examples of modeline: >

 /* cc: output='foobar' */  : set output filename to foobar

 /* cc: cc=#cl# flags=## */ : set compiler to cl (cmd='$cc $input $flags -o
			      $output')

 /* cc-vc6: flags+='/HAs' */
			    : add /HAs into flags, only effect when you invoke
			      the compiler named 'vc6'

 /* cc: run='!$output <data' */
			    : change run command to '!$output <data', that is,
			      use a default input for your program.

 -- cc: cc='ghc' haskell type comments
 {- cc: cc='ghc' -} -- haskell type comments
 // cc: flags='' C++ type comments

			    : modeline support any kind of commnets, as if
			      they contain 'cc:' or 'cc-name:'
<

==============================================================================
FEATURES							*ctk-features*


							      *ctk-cinfo-file*

you can define your source compiler and compile-flags in your cinfo file, it
defaultly ".compiler_info" in your 'runtimepath', that is usually '~\.vim' in
unix/linux, or '$VIM\vimfiles' in windows. you can open it and edit it with
executing :EditCompilerInfo, just try ':StartCTK' to refresh your new settings.


							  *ctk-fileext-define*

before define your own compiler info in a new filetype, maybe you need add a
"let" sentence (|:let|) to define the ext-name of your source code (e.g. "c"
for c code, "cpp" for c++ code, and hs for haskell code, etc.):
>
		autocmd FileType c let b:ft_ext = "c"
<
ft_ext is the value of option ctk_ext_var. the better way is:
>
		autocmd FileType c let b{g:ctk_ext_var} = "c"
<
or the best way: >
		autocmd FileType c SetExtensionName c
<

							       *ctk-info-line*

that file is combined with several autocmds |autocmd|. you can add a new
compile setting in these steps: >

	-- add the infomation for the extension name of specified program
	    files. (*.c, for example) see |ctk-fileext-define|
		autocmd FileType c SetExtensionName c

	-- add a new SetDefaultInfo sentence in a new section, [!] for delete
	   the old ones:

		autocmd FileType c SetDefaultInfo! cmd='...' run='...'

	-- maybe some platform settings, use if...else... and SetDefaultInfo
	   to modify current default value:

		if has('win32')
		    autocmd FileType c SetDefaultInfo ....
		elseif has('unix')
		    autocmd FileType c SetDefaultInfo ....
		else
		    autocmd FileType c SetDefaultInfo ....
		endif

	-- add a new SetCompilerInfo after it:

		autocmd FileType c SetCompilerInfo gcc title='...'

all autocmds are in the group "ctk_autocmds". and all lines need add to the
cinfo file |ctk-cinfo-file|.

the format of a info line is: >

 autocmd FileType <filetype> SetCompilerInfo <compiler_name> tags...
<
where filetype is the filetype you want to add compiler info in. compiler_name
is the name of this compiler, this name can be used in modeline.
|ctk-modeline|

all tags can used in your modeline, and its format is the same with the tags
in modeline. 
|ctk-modeline-format|

							       *ctk-cinfo-tag*

tag is just like variables in your program. there are four base tags in ctk,
if you didn't define then, they will defined by ctk. they are "cmd", "run",
"input" and "output". these tags use to create the command line to invoke
compiler and the program compiled.

the default define of base tags are:
>
    SetDefaultInfo cmd=':echo "Nothing Done"'
	    \ run=':echo "Nothing Done"'
	    \ input='%:.' output='%:t:r'
<

this is a long whole line. the leading backslash (\) is a line-continue sign.
you must add C sign in 'cpoptions' to support it. |cpo-C|


								*ctk-cmd-type*
							    *ctk-commmand-tag*

the tag named cmd and run are command tag, they are the template of command
line.  they has two type: shell-command type and vim-command type. if it begin
with ':', it will be a vim-command, if it begin with '!' or anyother things.
it will be parsed to a shell-command.

in cmd=':echo "Nothing Done"', the cmd tag is a vim-command tag, it just print
a line in vim |:echo|.

							      *ctk-run-direct*
if cmd is the string "#RUN_DIRECT", then when you press cmd hotkey, the
compiler will not run, and the "run" tag will be run instead.

in several subscript languages (lua, perl, python and ruby, etc.), you can use
"src" to specifie script file, use "args" to specifie runtime argument, and
use "flags" to pass flags to intepreter.

in run='!$output' or run='$output', the run tag is a shell-command tag. it
will be run in a shell.

if you use |:redirect| or |:silent| in cmd or run, you must close ctk's
redirect first. just like this:
>
    function! Foobar()				    
	redir END
	silent! foobar
	redir g:ctk_redir
    endfunction

    autocmd FileType foobar SetCompilerInfo foo cmd=':call Foobar()'

<
this example is useless, but it shows how to use silent/redir command in cmd
or run tags.

							     *ctk-placeholder*

the $output in run tag is a placeholder. it will be replaced by the value of
tag has name 'output' (or entry_output in a command tag, see 'ctk-entry-tag'
below).

you can also use ${q-output} for a placeholder, that means the value will be
quoted, just like <q-args> sign of :command |<a-args>|.

if ctk can't find the placeholder you specified, it will replace placeholder
to a enviroment variable. |ctk_envvarfmt|

							       *ctk-entry-tag*

tags can be defined in several entries. a entries is used as a trigger word
after :CC or :RUN command. see |:CC|, |:RUN|. such as :CC debug, 'debug' is a
entries. if you press :CC! directly, the empty entry will be used.

  - if tagname isn't include the underline (_), it will be a simple tag, a
    simple tag has a empty entry. e.g.  cmd, run, input and output. if you
    just press :CC to invoke compiler. the empty entry command tag "cmd" will
    be parsed and runed. if you just press :RUN to invoke the program you
    compiled. the empty entry command tag "run" will be parsed adn runed.

  - if you use any trigger word to invole compiler and program. e.g. use
    'foobar'.  it will be used as a entry. if you press :CC foobar, the
    command tag foobar_cmd will be parsed. if ctk can't find foobar_cmd in a
    info line, the cmd will be parsed.

in a word: tags has a format as [<entry>_]<tagname>, if you ignore entry, the
empty will be used, entry used to config :CC or :RUN command.

ctk use this turn to find the tags:
  - first, find it in info line;
  - then find it in 'default' (defined by :SetDefaultInfo);
  - if it still can't be found, ctk find the simple tag in info line;
  - and in default at last.

if ctk still can't find it, ctk will remain it as it is.


							  *ctk-filename-parse*

ctk will change any thing begin with % and # into current file name and
alternative file name. |:_%:| e.g. input='%:.' when parse command line, input
will be parsed in current file name, base to current directory.
|cmdline-special|.


the SetCompilerInfo command accepts a compile name and several attribute.
there are two attributes support: simple attribute (just comtain ansi word in
attribute name) and combine attribute (specname_attrname). there are several
attr examples: >
 input='%:.' output='%:t:r' asm_output='$output.asm'
<
you can use anything that isn't appeared in attributes to replace "'", e.g: >
 input=+%:.+ input=#%:.# ...
<
use space to separate each attributes.

a example: (you can find this in the default cinfo file)
>
 au FileType c SetExtensionName c

 au FileType c SetDefaultInfo!
    	\ cmd='!$cc $input $flags -o $output'
    	\ run='!$output' input='%:.' output='%:t:r'
    	\ asm_run=':pedit $output.asm'
	\ asm_output='$output.asm'
    	\ debug_run='!gdb -q $output'

 au FileType c SetCompilerInfo! gcc
    	\ title='GNU C Compiler'
    	\ cc='gcc' flags='-Wall' cmdmap='<m-c>' runmap='<m-1> <f5>'
    	\ asm_title='GCC to ASM' asm_flags='-S $flags'
    	\ debug_title='GCC with debug' debug_flags='-ggdb $flags'

<

the first line tells ctk.txt c language file's extension name is "c", some
times the 'filetype' option's value is the extension name, but sometimes not.
instead of use SetExtensionName, you can also put this sentence into
SetDefaultInfo: >

 aut FileType c SetDefaultInfo extname='c'
<

the second line is the default line, if ctk.vim can't find infomations in
current info line (e.g. cmd), it will find the current default line. so you
can put some common infomations at here.

you needn't clear all infomations (use SetCompilerInfo!) before you set it. if
the filetype of buffer is changed, all info line will be deleted. if you want
didn't delete, add alternative filetype into autocmd pattern
|autocmd-patterns|.

the first two line of default info line defined the four simple tag: cmd, run,
input and output. it says, if you want to compile a C program. the command
line is "$cc $input $flags -o $output", it combine with four tags. so as run.

the input and output tags can be omited, because this is the orignal value of
default.

the asm_run is a entry tag |ctk-entry-tag|. you can use ":RUN asm" to invoke
it.  in this case, all tags in this tag will be treat a entry tag. for
asm_run, ":if bufname('^$output$') == '' | sp +drop $output | endif |
checkt'", the $output wil be treated as asm_output. if ctk can't find
asm_output, it will find output, and if it can't find output, it will use
built-in value, since it's a base tag. if the asm_run = '$foobar', and you
don't define foobar and asm_foobar in your info line, it will be remain as it
is ($foobar).

next two line defines asm_output and debug_run. in asm_output, it used
$output, this will be parsed into a simple tag $output, not the entry tag.


								*ctk-name-tag*

the info line support the remain infomations.  the first field of info line is
the name of info field. that will be used in modeline. |ctk-modeline|. you can
use ListCompiler to display it.

							       *ctk-title-tag*

you can add a title tag in info line. it will be displayed when you compile
your program. if it is a entry one, it will displayed when you compile your
program with specified entry.

next line set $cc to gcc, and flags to -Wall, so the cmd will be parsed to
'!gcc %:. -Wall -o %:t:r', where %:. and %:t:r will be replaced by filename.
|:_%:|.

							      *ctk-hotkey-tag*
the next two tags is hotkey tags. hotkey tags named "cmdmap" and "runmap", you
can define then with "modelist:key", just like cmdmap="n:<f1>", means when you
press <F1> in normal mode, the compiler will be invoked. runmap="<F2>" means
when you press <F2> in any mode, your program will run. (if it hasn't compile
yet, the compiler will be invoked before). you can define multikey in a hotkey
tag. just lile runmap='<m-1> <f5>', omited mode means all mode as far as ctk
can defined (that is not defined by other scripts or user yet). you can see
the defined key in ListCompiler. |:ListCompiler|

you can't contain child tags in hotkey tags.

==============================================================================
OPTION								*ctk-options*

these are ctk's option and default value, you can change them, and put it in
your .vimrc file |.vimrc| to modified ctk.

					       *ctk-autofname* *ctk_autofname*
>
 let g:ctk_autofname = 'strftime("%Y-%m-%d")."-".idx'

<			this is used to set the auto generated fname, the
			value of this will be calculated then generated the
			new fname. set it to empty will disabled the function
			of auto rename the noname file: >

				let g:ctk_autofname = ''
<
							       *ctk_autostart*
>
 let g:ctk_autostart = 1
<
			if you don't want CTK auto start when you enter Vim,
			set it to 0, it's default 1, means auto start.

							      *ctk_cinfo_file*
>
 let g:ctk_cinfo_file = '.compiler_info'
<			this is the default cinfo file path, based on
			'runtimepath'. it will be loaded when you start the
			ctk |StartCTK|.

								  *ctk_cmdenc*
>
 let g:ctk_cmdenc = "cp936"
<
			this option is avaliable in win32 only. because the
			encoding of win32 console is not utf-8, if you use
			utf-8 for 'encoding'. the command line you invoke will
			incorrect. set this to the encoding of win32 console
			to solve this problem.

							       *ctk_defoutput*
>
 let g:ctk_defoutput = './output'
<			this is the default output name when the file name is
			generated by CTK.

								 *ctk_ext_var*
>
 let g:ctk_ext_var = 'ft_ext'
<			this is the default variable name of current file
			extname. it should b:ft_ext when the g:ctk_ext_var =
			'ft_ext'

			design this is because that maybe other plug-in
			supports some feature to offer the extension name of
			file, so you can simply set g:ctk_ext_var to the name
			of that variable.

			in ctk, first it checks whether 'b:'.g:ctk_ext_var
			exists, when g:ctk_ext_var defaults to 'ft_ext', this
			variable turns to 'b:ft_ext'.  when this variable
			exists, ctk use it to create the file name of new
			program.

			otherwise, ctk checks 'sua' option. (see :h 'sua') if
			it is non-empty, at last it used &ft directly. if all
			option is empty, ctk will not rename the new program
			file.

			so, g:ctk_ext_var is nothing about finding source
			window, it only used to create the new name of
			program.

								 *ctk_tempdir*
>
 let g:ctk_tempdir = './noname'
<			this is the temporary folder to contain noname file.

							       *ctk_envvarfmt*
 if has('win32')
     let g:ctk_envvarfmt = '%var%'
 elseif has('unix')
     let g:ctk_envvarfmt = '${var}'
 else
     let g:ctk_envvarfmt = ''
 endif
			this option is used to substitute placeholder to a
enviroment variable.

								 *ctk_execprg*
>
 if has('win32')
     let g:ctk_execprg = executable('vimrun') ?
 		\ 'start vimrun $exec' : 'start $exec'
 elseif has('unix') && has('gui_running')
     let g:ctk_execprg = 'xterm -e"$exec; '.
 		\ 'read -s -n1 -p''press any key to continue...''"'
 else
     let g:ctk_execprg = ''
 endif
<
			the g:ctk_execprg is the system-specified command
			template. when you run your program. this template
			will be used to build the command send to shell.
			the $exec will be replaced by the program that will
			executed.

==============================================================================
CONTACT								*ctk-contact*

if you find any bug, please contact me <weasley_wx AT qq DOT com>. and i will
very happy if you can send me some advise or new-feature :-)


vim: tw=79:ts=8:ft=help:norl:
