#!/bin/sh


# p4_file_list
#   Similar to 'p4 opened', but displays the list in a cooked format
# that is more predictable. Also has options to toggle exactly what
# kind of change entries you want to list. The added functionality
# comes with the -n and -u arguments, which will show you what files
# you currently have that are either not checked out (but perforce
# knows about) or unknown (no perforce information), respectively.
# The -u option is particularly useful for looking for files that you
# forgot to add, or checking up on your 'make clean' target to make
# sure all files were removed.


prog_name=`basename $0`
TOOLSDIR=`dirname $0`
echo $prog_name
echo $TOOLSDIR

usage() {
	echo "usage: $prog_name [-abdeinufqR] [-r <revision1> [-r <revision2]]"
	echo "       [<dir> ...]"
	echo ""
	echo "  -a              show added files"
	echo "  -b              show branches files"
	echo "  -d              show deleted files"
	echo "  -e              show edited files"
	echo "  -i              show integrated files"
	echo "  -n              show files that have not been modified"
	echo "  -u              show unknown files (files not in perforce)"
	echo ""
	echo "  -f              display full path names of files"
	echo "  -q              print only the names of the files and not the status"
	echo "                  (quiet)"
	echo "  -R              do not recurse into directories"
	echo ""
	echo "  -r <revision1>  show the changes against <revision1>"
	echo "  -r <revision2>  show the changes between <revision1> and <revision2>"
	echo ""
	echo "  <dir>           evaluate this directory"
	echo ""
	echo "If no display arguments are given, then changed files with known"
	echo "statuses are shown (-abdei). If no directory argument is given, the"
	echo "current directory is evaluated."
	exit 1
}

# variables passed to the sed script are exported
export show_added=0
export show_branched=0
export show_deleted=0
export show_edited=0
export show_integrated=0
export show_not_modified=0
export show_unknown=0
export full_path=0
export quiet=0
recursive=1
revision1=""
revision2=""
directories="`pwd`"

while getopts abdeinufqRr:h opt; do
	case $opt in
		(a) export show_added=1;;
		(b) export show_branched=1;;
		(d) export show_deleted=1;;
		(e) export show_edited=1;;
		(i) export show_integrated=1;;
		(n) export show_not_modified=1;;
		(u) export show_unknown=1;;
		(f) export full_path=1;;
		(q) export quiet=1;;
		(R) recursive=0;;
		(r)
			if [ -z "$revision1" ]; then
				revision1=$OPTARG
			elif [ -z "$revision2" ]; then
				revision2=$OPTARG
			else
				usage
			fi
			;;
		(h|?) usage;;
	esac
done

shift $(($OPTIND - 1))

if [ $# -gt 0 ]; then
	directories=""
	for dir in $*; do
		directories="$directories `cd $dir && pwd`"
		if [ $? -ne 0 ]; then
			echo "error: could not change to directory $dir"
			continue
		fi
	done
fi

let fast_args=show_added+show_branched+show_deleted+show_edited+show_integrated
let slow_args=show_not_modified+show_unknown
let sum=fast_args+slow_args
if [ $sum -eq 0 ]; then
	show_added=1
	show_branched=1
	show_deleted=1
	show_edited=1
	show_integrated=1
	show_not_modified=0
	show_unknown=0
fi
let fast_args=show_added+show_branched+show_deleted+show_edited+show_integrated
let slow_args=show_not_modified+show_unknown

find_args=""
if [ $recursive -eq 0 ]; then
	find_args="-maxdepth 1"
fi

if [ -n "$revision1" ]; then
	if [ -z "$revision2" ]; then
		echo "error: this operation is not implemented"
		exit 1
	fi

	IFS='
'
	for line in `p4 diff2 -q ...${revision1} ...${revision2} 2>/dev/null`; do
		file1=`echo $line | awk -F ' - ' '{print $1}' | \
			awk -F '==== ' '{print $2}' | cut -d '#' -f 1`
		file2=`echo $line | awk -F ' - ' '{print $2}' | \
			awk -F ' ====' '{print $1}' | cut -d '#' -f 1`

		if [ "$file1" = "< none >" ]; then
			echo "A: $file2"
		elif [ "$file2" = "< none >" ]; then
			echo "D: $file1"
		else
			echo "E: $file1"
		fi
	done
	exit 0
fi

files=""
for file in `p4 opened 2>&1 | cut -d '#' -f 1`; do
	files="${files} ${file}"
done

export dir
export fast
for dir in $directories; do
	# xargs doesn't get it right if you don't specify max-chars

	if [ $fast_args -gt 0 ]; then
		fast=1
		echo "$files" | \
			xargs --no-run-if-empty p4 fstat 2>&1 | \
				awk -f $TOOLSDIR/$prog_name.awk
	fi

	if [ $slow_args -gt 0 ]; then
		fast=0
		find $dir -type f -print0 $find_args | \
			xargs -0 --no-run-if-empty --max-chars=200 p4 fstat 2>&1 | \
				awk -f $TOOLSDIR/$prog_name.awk
	fi
done

exit 0
