diff --git a/autoload/go/complete.vim b/autoload/go/complete.vim
index a0f9da7..8e8d660 100644
--- a/autoload/go/complete.vim
+++ b/autoload/go/complete.vim
@@ -2,6 +2,27 @@ if !exists("g:go_gocode_bin")
     let g:go_gocode_bin = "gocode"
 endif
 
+function! s:gocodeFastExecute(args, buf)
+python << EOL
+import vim, os, subprocess
+params = vim.eval("a:args")
+#buf = vim.current.buffer
+buf = vim.eval("a:buf")
+buffer_str = "\n".join(buf[:])
+try:
+    process = subprocess.Popen(params, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
+    stdout = process.communicate(input=buffer_str)[0]
+    output_command_string = "let result = \"%s\"" % stdout.replace("\"", "\\\"")
+    vim.command(output_command_string)
+except:
+    vim.command("let result = \"['0', []]\"")
+EOL
+
+if &encoding != 'utf-8'
+    let result = iconv(result, 'utf-8', &encoding)
+endif
+return result
+endfunction
 
 fu! s:gocodeCurrentBuffer()
     let buf = getline(1, '$')
@@ -13,13 +34,17 @@ fu! s:gocodeCurrentBuffer()
         " so if fileformat is 'dos', 'buf' must include '\r'.
         let buf = map(buf, 'v:val."\r"')
     endif
+    return buf
+endf
+
+fu! s:gocodeCurrentBufferFile()
+	let buf = s:gocodeCurrentBuffer()
     let file = tempname()
     call writefile(buf, file)
 
     return file
 endf
 
-
 if go#vimproc#has_vimproc()
     let s:vim_system = get(g:, 'gocomplete#system_function', 'vimproc#system2')
 else
@@ -91,21 +116,30 @@ fu! s:gocodeCursor()
 endf
 
 fu! s:gocodeAutocomplete()
-    let filename = s:gocodeCurrentBuffer()
-    let result = s:gocodeCommand('autocomplete',
+	if 1
+	    let toolPath = go#path#CheckBinPath(g:go_gocode_bin)
+	    let result = s:gocodeFastExecute([toolPath, '-f=vim', 'autocomplete',  expand('%:p'), s:gocodeCursor()], s:gocodeCurrentBuffer())
+	else
+	    let filename = s:gocodeCurrentBufferFile()
+	    let result = s:gocodeCommand('autocomplete',
                 \ [s:gocodeCurrentBufferOpt(filename), '-f=vim'],
                 \ [expand('%:p'), s:gocodeCursor()])
-    call delete(filename)
+    	call delete(filename)
+	endif
     return result
 endf
 
 function! go#complete#GetInfo()
-    let filename = s:gocodeCurrentBuffer()
-    let result = s:gocodeCommand('autocomplete',
+    if 1
+	    let result = s:gocodeFastExecute([toolPath, '-f=godit', 'autocomplete',  expand('%:p'), s:gocodeCursor()], s:gocodeCurrentBuffer)
+	else
+	    let filename = s:gocodeCurrentBufferFile()
+    	let result = s:gocodeCommand('autocomplete',
                 \ [s:gocodeCurrentBufferOpt(filename), '-f=godit'],
                 \ [expand('%:p'), s:gocodeCursor()])
-    call delete(filename)
-
+	    call delete(filename)
+    endif
+ 
     " first line is: Charcount,,NumberOfCandidates, i.e: 8,,1
     " following lines are candiates, i.e:  func foo(name string),,foo(
     let out = split(result, '\n')
@@ -115,7 +149,7 @@ function! go#complete#GetInfo()
         return ""
     endif
 
-    " only one candiate is found
+    " only one candidate is found
     if len(out) == 2
         return split(out[1], ',,')[0]
     endif
