*stlrefvim.txt*           STL-Reference Manual for Vim
                            ======================
                                 Version 1.0
                                20. Aug. 2008

                 stlrefvim is copyright (c) 2008 Daniel Price
            See |stlrefvim-copyright| for full copyright and license.

********************************************************************************
                            Introduction and Usage
********************************************************************************
    1. Introduction                                            |stlrefvim-intro|
    2. Installation                                          |stlrefvim-install|
    3. Usage                                                   |stlrefvim-usage|
    4. Customization                                   |stlrefvim-customization|

********************************************************************************
                             Table of  Contents:
********************************************************************************
    1. Introduction to the STL |stl-introduction|
    2. How to use the documentation|stl-howto|
    3. Containers
         1. Concepts
              1. General concepts
                   1. |stl-Container|
                   2. |stl-ForwardContainer|
                   3. |stl-ReversibleContainer|
                   4. |stl-RandomAccessContainer|
              2. Sequences
                   1. |stl-Sequence|
                   2. |stl-FrontInsertionSequence|
                   3. |stl-BackInsertionSequence|
              3. Associative Containers
                   1. |stl-AssociativeContainer|
                   2. |stl-SimpleAssociativeContainer|
                   3. |stl-PairAssociativeContainer|
                   4. |stl-SortedAssociativeContainer|
                   5. |stl-HashedAssociativeContainer|
                   6. |stl-HashFunction|
                   7. |stl-UniqueAssociativeContainer|
                   8. |stl-MultipleAssociativeContainer|
                   9. |stl-UniqueSortedAssociativeContainer|
                  10. |stl-MultipleSortedAssociativeContainer|
                  11. |stl-UniqueHashedAssociativeContainer|
                  12. |stl-MultipleHashedAssociativeContainer|
         2. Container classes
              1. Sequences
                   1. |stl-vector|
                   2. |stl-deque|
                   3. |stl-list|
                   4. |stl-slist|
                   5. |stl-bit_vector|
              2. Associative Containers
                   1. |stl-set|
                   2. |stl-map|
                   3. |stl-multiset|
                   4. |stl-multimap|
                   5. |stl-hash_set|
                   6. |stl-hash_map|
                   7. |stl-hash_multiset|
                   8. |stl-hash_multimap|
                   9. |stl-hash|
              3. String package
                   1. |stl-Character_Traits|
                   2. |stl-char_traits|
                   3. |stl-basic_string|
              4. |stl-rope|
              5. Container adaptors
                   1. |stl-stack|
                   2. |stl-queue|
                   3. |stl-priority_queue|
              6. |stl-bitset|
    4. Iterators
         1. Iterator Introduction |stl-iterators|
         2. Concepts
              1. |stl-TrivialIterator|
              2. |stl-InputIterator|
              3. |stl-OutputIterator|
              4. |stl-ForwardIterator|
              5. |stl-BidirectionalIterator|
              6. |stl-RandomAccessIterator|
         3. Iterator Tags
              1. Iterator Tag Introduction |stl-iterator_tags|
              2. |stl-iterator_traits|
              3. |stl-iterator_category|
              4. |stl-distance_type|
              5. |stl-value_type|
              6. Iterator tag classes
                   1. |stl-input_iterator_tag|
                   2. |stl-output_iterator_tag|
                   3. |stl-forward_iterator_tag|
                   4. |stl-bidirectional_iterator_tag|
                   5. |stl-random_access_iterator_tag|
              7. Iterator base classes
                   1. |stl-input_iterator|
                   2. |stl-output_iterator|
                   3. |stl-forward_iterator|
                   4. |stl-bidirectional_iterator|
                   5. |stl-random_access_iterator|
         4. Iterator functions
              1. |stl-distance|
              2. |stl-advance|
         5. Iterator classes
              1. |stl-istream_iterator|
              2. |stl-ostream_iterator|
              3. |stl-front_insert_iterator|
              4. |stl-back_insert_iterator|
              5. |stl-insert_iterator|
              6. |stl-reverse_iterator|
              7. |stl-reverse_bidirectional_iterator|
              8. |stl-raw_storage_iterator|
              9. |stl-sequence_buffer|
    5. Algorithms
         1. Non-mutating algorithms
              1. |stl-for_each|
              2. |stl-find|
              3. |stl-find_if|
              4. |stl-adjacent_find|
              5. |stl-find_first_of|
              6. |stl-count|
              7. |stl-count_if|
              8. |stl-mismatch|
              9. |stl-equal|
             10. |stl-search|
             11. |stl-search_n|
             12. |stl-find_end|
         2. Mutating algorithms
              1. |stl-copy|
              2. |stl-copy_n|
              3. |stl-copy_backward|
              4. Swap
                   1. |stl-swap|
                   2. |stl-iter_swap|
                   3. |stl-swap_ranges|
              5. |stl-transform|
              6. Replace
                   1. |stl-replace|
                   2. |stl-replace_if|
                   3. |stl-replace_copy|
                   4. |stl-replace_copy_if|
              7. |stl-fill|
              8. |stl-fill_n|
              9. |stl-generate|
             10. |stl-generate_n|
             11. Remove
                   1. |stl-remove|
                   2. |stl-remove_if|
                   3. |stl-remove_copy|
                   4. |stl-remove_copy_if|
             12. |stl-unique|
             13. |stl-unique_copy|
             14. |stl-reverse|
             15. |stl-reverse_copy|
             16. |stl-rotate|
             17. |stl-rotate_copy|
             18. |stl-random_shuffle|
             19. |stl-random_sample|
             20. |stl-random_sample_n|
             21. |stl-partition|
             22. |stl-stable_partition|
         3. Sorting
              1. Sort
                   1. |stl-sort|
                   2. |stl-stable_sort|
                   3. |stl-partial_sort|
                   4. |stl-partial_sort_copy|
                   5. |stl-is_sorted|
              2. |stl-nth_element|
              3. Binary search
                   1. |stl-lower_bound|
                   2. |stl-upper_bound|
                   3. |stl-equal_range|
                   4. |stl-binary_search|
              4. |stl-merge|
              5. |stl-inplace_merge|
              6. Set operations on sorted ranges
                   1. |stl-includes|
                   2. |stl-set_union|
                   3. |stl-set_intersection|
                   4. |stl-set_difference|
                   5. |stl-set_symmetric_difference|
              7. Heap operations
                   1. |stl-push_heap|
                   2. |stl-pop_heap|
                   3. |stl-make_heap|
                   4. |stl-sort_heap|
                   5. |stl-is_heap|
              8. Minimum and maximum
                   1. |stl-min|
                   2. |stl-max|
                   3. |stl-min_element|
                   4. |stl-max_element|
              9. |stl-lexicographical_compare|
             10. |stl-lexicographical_compare_3way|
             11. |stl-next_permutation|
             12. |stl-prev_permutation|
         4. Generalized numeric algorithms
              1. |stl-iota|
              2. |stl-accumulate|
              3. |stl-inner_product|
              4. |stl-partial_sum|
              5. |stl-adjacent_difference|
              6. |stl-power|
    6. Function Objects
         1. Function Object Introduction|stl-functors|
         2. Concepts
              1. |stl-Generator|
              2. |stl-UnaryFunction|
              3. |stl-BinaryFunction|
              4. |stl-AdaptableGenerator|
              5. |stl-AdaptableUnaryFunction|
              6. |stl-AdaptableBinaryFunction|
              7. Predicates
                   1. |stl-Predicate|
                   2. |stl-BinaryPredicate|
                   3. |stl-AdaptablePredicate|
                   4. |stl-AdaptableBinaryPredicate|
                   5. |stl-StrictWeakOrdering|
              8. |stl-MonoidOperation|
              9. |stl-RandomNumberGenerator|
         3. Predefined function objects
              1. Arithmetic operations
                   1. |stl-plus|
                   2. |stl-minus|
                   3. |stl-multiplies| (formerly called times)
                   4. |stl-divides|
                   5. |stl-modulus|
                   6. |stl-negate|
              2. Comparisons
                   1. |stl-equal_to|
                   2. |stl-not_equal_to|
                   3. |stl-less|
                   4. |stl-greater|
                   5. |stl-less_equal|
                   6. |stl-greater_equale|
              3. Logical operations
                   1. |stl-logical_and|
                   2. |stl-logical_or|
                   3. |stl-logical_not|
              4. Generalized identity operations
                   1. |stl-identity|
                   2. |stl-project1st|
                   3. |stl-project2nd|
                   4. |stl-select1st|
                   5. |stl-select2nd|
              5. |stl-subtractive_rng|
         4. Function object adaptors
              1. |stl-binder1st|
              2. |stl-binder2nd|
              3. |stl-ptr_fun|
              4. |stl-pointer_to_unary_function|
              5. |stl-pointer_to_binary_function|
              6. |stl-unary_negate|
              7. |stl-binary_negate|
              8. |stl-unary_compose|
              9. |stl-binary_compose|
             10. Member function adaptors
                   1. |stl-mem_fun|
                   2. |stl-mem_fun_ref|
                   3. |stl-mem_fun1|
                   4. |stl-mem_fun1_ref|
    7. Utilities
         1. Concepts
              1. |stl-Assignable|
              2. |stl-DefaultConstructible|
              3. |stl-EqualityComparable|
              4. |stl-LessThanComparable|
         2. Functions
              1. |stl-RelationalOperators|
         3. Classes
              1. |stl-pair|
    8. Memory Allocation
         1. Classes
              1. |stl-Allocators|
         2. Functions
              1. |stl-construct|
              2. |stl-destroy|
              3. |stl-uninitialized_copy|
              4. |stl-uninitialized_copy_n|
              5. |stl-uninitialized_fill|
              6. |stl-uninitialized_fill_n|
              7. |stl-temporary_buffer|
              8. |stl-get_temporary_buffer|
              9. |stl-return_temporary_buffer|
    9. Design documents
         1. Thread safety |stl-thread_safety|
         2. The meaning of complexity specifications |stl-complexity|
         3. Representations of strings |stl-string_discussion|
   10. Full Index |stl-index|
   11. License |stlrefvim-license|
   12. Acknowledgements |stlrefvim-acknowledgements|


******************************************************************************
1. Introduction                                              *stlrefvim-intro*
******************************************************************************

The intention of this project is to provide a STL-reference manual that can
be accessed from within Vim.

This project consists of two parts:
  1. stlrefvim.vim     plugin to get access to the STL-reference
  2. stlrefvim.txt     an STL-reference with Vim-tags for navigation

See |stlrefvim-copyright| for copyright and licenses.

******************************************************************************
2. Installation                                            *stlrefvim-install*
******************************************************************************

stlrefvim consists of two files: the script 'stlrefvim.vim' and its
documentation 'stlrefvim.txt'.

To use the script copy it into your local plugin-directory
  Unix:    ~/.vim/plugin
  Windows: c:\vimfiles\plugin

This script can be customized in your .vimrc, for further information
see |stlrefvim-customization|.

You have to add this documentation and the STL-reference to Vim's help
system. To do this, copy 'stlrefvim.txt' to your local doc-directory:
  Unix:    ~/.vim/doc
  Windows: c:\vimfiles\doc

Then start Vim and do:
  :helptags ~/.vim/doc   (or :helptags c:\vimfiles\doc for Windows)


******************************************************************************
3. Usage                                                     *stlrefvim-usage*
******************************************************************************

There are several ways to specify a word stlrefvim should search for in order
to view help:

  <Leader>tr normal mode:  get help for word under cursor
                           Memory aid tr: (t)-(r)eference
  <Leader>tr visual mode:  get help for visually selected text
                           Memory aid tr: (t)-(r)eference
  <Leader>tr normal mode:  get example for word under cursor
                           Memory aid tr: (t)-(e)xample
  <Leader>te visual mode:  get example for visually selected text
                           Memory aid tr: (t)-(e)xample
  <Leader>tw:              prompt for word stlrefvim should search for
                           Memory aid tw: (t)-reference (w)hat
  <Leader>tc:              jump to table of contents of the STL-reference manual
                           Memory aid tc: (t)-reference (c)ontents

Note: by default <Leader> is \, e.g. press \tr to invoke STL-reference


******************************************************************************
4. Customization                                     *stlrefvim-customization*
******************************************************************************

The key-maps used to invoke stlrefvim can be customized. To do so set the
following variables in your .vimrc-file. If they are not set, defaults are
taken.

  - <Plug>StlRefVimVisual
    mapping to start search for visually selected text
    default:
      vmap <silent> <unique> <Leader>tr <Plug>StlRefVimVisual

  - <Plug>StlRefVimNormal
    mapping to start search for text under cursor
    default:
      nmap <silent> <unique> <Leader>tr <Plug>StlRefVimNormal

  - <Plug>StlRefVimExample
    mapping to start search for visually selected text
    default:
      vmap <silent> <unique> <Leader>te <Plug>StlRefVimExample

  - <Plug>StlRefVimExample
    mapping to start search for text under cursor
    default:
      map <silent> <unique> <Leader>te <Plug>StlRefVimExample

  - <Plug>StlRefVimAsk
    mapping to ask for word to search for
    default:
      map <silent> <unique> <Leader>tw <Plug>StlRefVimAsk

  - <Plug>StlRefVimInvoke
    mapping to let Vim jump to the contents of the STL-reference manual
    default:
      map <silent> <unique> <Leader>tc <Plug>StlRefVimInvoke

********************************************************************************
                            Introduction to the STL           *stl-introduction*
********************************************************************************

                 Introduction to the Standard Template Library

   The Standard Template Library, or STL, is a C++ library of container
   classes, algorithms, and iterators; it provides many of the basic
   algorithms and data structures of computer science. The STL is a generic
   library, meaning that its components are heavily parameterized: almost
   every component in the STL is a template. You should make sure that you
   understand how templates work in C++ before you use the STL.

Containers and algorithms

   Like many class libraries, the STL includes container classes: classes
   whose purpose is to contain other objects. The STL includes the classes
   |stl-Vector|, |stl-List|, |stl-Deque|, |stl-set|, |stl-multiset|,
   |stl-Map|, |stl-Multimap|, |stl-hash_set|, |stl-hash_multiset|,
   |stl-hash_map|, and |stl-hash_multimap|. Each of these classes is a
   template, and can be instantiated to contain any type of object. You can,
   for example, use a vector<int> in much the same way as you would use an
   ordinary C array, except that vector eliminates the chore of managing
   dynamic memory allocation by hand.

       vector<int> v(3);            // Declare a vector of 3 elements.
       v[0] = 7;
       v[1] = v[0] + 3;
       v[2] = v[0] + v[1];          // v[0] == 7, v[1] == 10, v[2] == 17

   The STL also includes a large collection of algorithms that manipulate the
   data stored in containers. You can reverse the order of elements in a
   vector, for example, by using the |stl-reverse| algorithm.

       reverse(v.begin(), v.end()); // v[0] == 17, v[1] == 10, v[2] == 7

   There are two important points to notice about this call to reverse.
   First, it is a global function, not a member function. Second, it takes
   two arguments rather than one: it operates on a range of elements, rather
   than on a container. In this particular case the range happens to be the
   entire container v.

   The reason for both of these facts is the same: reverse, like other STL
   algorithms, is decoupled from the STL container classes. This means that
   reverse can be used not only to reverse elements in vectors, but also to
   reverse elements in lists, and even elements in C arrays. The following
   program is also valid.

       double A[6] = { 1.2, 1.3, 1.4, 1.5, 1.6, 1.7 };
       reverse(A, A + 6);
       for (int i = 0; i < 6; ++i)
         cout << "A[" << i << "] = " << A[i];

   This example uses a range, just like the example of reversing a vector:
   the first argument to reverse is a pointer to the beginning of the range,
   and the second argument points one element past the end of the range. This
   range is denoted [A, A + 6); the asymmetrical notation is a reminder that
   the two endpoints are different, that the first is the beginning of the
   range and the second is one past the end of the range.

Iterators

   In the example of reversing a C array, the arguments to reverse are
   clearly of type double*. What are the arguments to reverse if you are
   reversing a vector, though, or a list? That is, what exactly does reverse
   declare its arguments to be, and what exactly do v.begin() and v.end()
   return?

   The answer is that the arguments to reverse are iterators, which are a
   generalization of pointers. Pointers themselves are iterators, which is
   why it is possible to reverse the elements of a C array. Similarly, vector
   declares the nested types iterator and const_iterator. In the example
   above, the type returned by v.begin() and v.end() is
   vector<int>::iterator. There are also some iterators, such as
   |stl-istream_iterator| and |stl-ostream_iterator|, that aren't associated
   with containers at all.

   Iterators are the mechanism that makes it possible to decouple algorithms
   from containers: algorithms are templates, and are parameterized by the
   type of iterator, so they are not restricted to a single type of
   container. Consider, for example, how to write an algorithm that performs
   linear search through a range. This is the STL's |stl-find| algorithm.

       template <class InputIterator, class T>
       InputIterator find(InputIterator first, InputIterator last, const T& value) {
           while (first != last && *first != value) ++first;
           return first;
       }

   Find takes three arguments: two iterators that define a range, and a value
   to search for in that range. It examines each iterator in the range
   [first, last), proceeding from the beginning to the end, and stops either
   when it finds an iterator that points to value or when it reaches the end
   of the range.

   First and last are declared to be of type InputIterator, and InputIterator
   is a template parameter. That is, there isn't actually any type called
   InputIterator: when you call find, the compiler substitutes the actual
   type of the arguments for the formal type parameters InputIterator and T.
   If the first two arguments to find are of type int* and the third is of
   type int, then it is as if you had called the following function.

       int* find(int* first, int* last, const int& value) {
           while (first != last && *first != value) ++first;
           return first;
       }

Concepts and Modeling

   One very important question to ask about any template function, not just
   about STL algorithms, is what the set of types is that may correctly be
   substituted for the formal template parameters. Clearly, for example, int*
   or double* may be substituted for find's formal template parameter
   InputIterator. Equally clearly, int or double may not: find uses the
   expression *first, and the dereference operator makes no sense for an
   object of type int or of type double. The basic answer, then, is that find
   implicitly defines a set of requirements on types, and that it may be
   instantiated with any type that satisfies those requirements. Whatever
   type is substituted for InputIterator must provide certain operations: it
   must be possible to compare two objects of that type for equality, it must
   be possible to increment an object of that type, it must be possible to
   dereference an object of that type to obtain the object that it points to,
   and so on.

   Find isn't the only STL algorithm that has such a set of requirements; the
   arguments to |stl-for_each| and |stl-count|, and other algorithms, must
   satisfy the same requirements. These requirements are sufficiently
   important that we give them a name: we call such a set of type
   requirements a concept, and we call this particular concept
   |stl-InputIterator|. We say that a type conforms to a concept, or that it
   is a model of a concept, if it satisfies all of those requirements. We say
   that int* is a model of Input Iterator because int* provides all of the
   operations that are specified by the Input Iterator requirements.

   Concepts are not a part of the C++ language; there is no way to declare a
   concept in a program, or to declare that a particular type is a model of a
   concept. Nevertheless, concepts are an extremely important part of the
   STL. Using concepts makes it possible to write programs that cleanly
   separate interface from implementation: the author of find only has to
   consider the interface specified by the concept Input Iterator, rather
   than the implementation of every possible type that conforms to that
   concept. Similarly, if you want to use find, you need only to ensure that
   the arguments you pass to it are models of Input Iterator. This is the
   reason why find and reverse can be used with lists, vectors, C arrays, and
   many other types: programming in terms of concepts, rather than in terms
   of specific types, makes it possible to reuse software components and to
   combine components together.

Refinement

   Input Iterator is, in fact, a rather weak concept: that is, it imposes
   very few requirements. An Input Iterator must support a subset of pointer
   arithmetic (it must be possible to increment an Input Iterator using
   prefix and postfix operator++), but need not support all operations of
   pointer arithmetic. This is sufficient for |stl-find|, but some other
   algorithms require that their arguments satisfy additional requirements.
   |stl-reverse|, for example, must be able to decrement its arguments as
   well as increment them; it uses the expression --last. In terms of
   concepts, we say that reverse's arguments must be models of
   |stl-BidirectionalIterator| rather than Input Iterator.

   The Bidirectional Iterator concept is very similar to the Input Iterator
   concept: it simply imposes some additional requirements. The types that
   are models of Bidirectional Iterator are a subset of the types that are
   models of Input Iterator: every type that is a model of Bidirectional
   Iterator is also a model of Input Iterator. Int*, for example, is both a
   model of Bidirectional Iterator and a model of Input Iterator, but
   |stl-istream_iterator|, is only a model of Input Iterator: it does not
   conform to the more stringent Bidirectional Iterator requirements.

   We describe the relationship between Input Iterator and Bidirectional
   Iterator by saying that Bidirectional Iterator is a refinement of Input
   Iterator. Refinement of concepts is very much like inheritance of C++
   classes; the main reason we use a different word, instead of just calling
   it "inheritance", is to emphasize that refinement applies to concepts
   rather than to actual types.

   There are actually three more iterator concepts in addition to the two
   that we have already discussed: the five iterator concepts are
   |stl-OutputIterator|, |stl-InputIterator|, |stl-ForwardIterator|,
   |stl-BidirectionalIterator|, and |stl-RandomAccessIterator|; Forward
   Iterator is a refinement of Input Iterator, Bidirectional Iterator is a
   refinement of Forward Iterator, and Random Access Iterator is a refinement
   of Bidirectional Iterator. (|stl-OutputIterator| is related to the other
   four concepts, but it is not part of the hierarchy of refinement: it is
   not a refinement of any of the other iterator concepts, and none of the
   other iterator concepts are refinements of it.) The |stl-Iterators| has
   more information about iterators in general.

   Container classes, like iterators, are organized into a hierarchy of
   concepts. All containers are models of the concept |stl-Container|; more
   refined concepts, such as |stl-Sequence| and |stl-AssociativeContainer|,
   describe specific types of containers.

Other parts of the STL

   If you understand algorithms, iterators, and containers, then you
   understand almost everything there is to know about the STL. The STL does,
   however, include several other types of components.

   First, the STL includes several utilities: very basic concepts and
   functions that are used in many different parts of the library. The
   concept |stl-Assignable|, for example, describes types that have
   assignment operators and copy constructors; almost all STL classes are
   models of Assignable, and almost all STL algorithms require their
   arguments to be models of Assignable.

   Second, the STL includes some low-level mechanisms for allocating and
   deallocating memory. |stl-Allocators| are very specialized, and you can
   safely ignore them for almost all purposes.

   Finally, the STL includes a large collection of |stl-functors|, also known
   as functors. Just as iterators are a generalization of pointers, function
   objects are a generalization of functions: a function object is anything
   that you can call using the ordinary function call syntax. There are
   several different concepts relating to function objects, including
   |stl-UnaryFunction| (a function object that takes a single argument, i.e.
   one that is called as f(x)) and |stl-BinaryFunction| (a function object
   that takes two arguments, i.e. one that is called as f(x, y)). Function
   objects are an important part of generic programming because they allow
   abstraction not only over the types of objects, but also over the
   operations that are being performed.


********************************************************************************
                         How to Use the Documentation                *stl-howto*
********************************************************************************

   This site documents all of the components (classes, functions, and
   concepts) in the SGI Standard Template Library. Each page describes a
   single component, and also includes links to related components.

   This documentation assumes a general familiarity with C++, especially with
   C++ templates. Additionally, you should read |stl-Introduction| to the
   Standard Template Library before proceeding to the pages that describe
   individual components: the introductory page defines several terms that
   are used throughout the documentation.

Classification of STL components

   The STL components are divided into six broad categories on the basis of
   functionality: Containers, Iterators, Algorithms, Function Objects,
   Utilities, and Allocators; these categories are defined in the
   |stl-Introduction|, and the [4]Table of Contents is organized according to
   them.

   The STL documentation contains two indices. One of them, the [5]Main
   Index, lists all components in alphabetical order. The other, the
   |stl-Divided-Index|, contains a separate alphabetical listing for each
   category. The Divided Index includes one category that is not present in
   the Table of Contents: Adaptors. An adaptor is a class or a function that
   transforms one interface into a different one. The reason that adaptors
   don't appear in the Table of Contents is that no component is merely an
   adaptor, but always an adaptor and something else; |stl-stack|, for
   example, is a container and an adaptor. Accordingly, |stl-stack| appears
   in two different places in the Divided Index. There are several other
   components that appear in the Divided Index in more than one place.

   The STL documentation classifies components in two ways.

    1. Categories are a classification by functionality. The categories are:

          * Container
          * Iterator
          * Algorithm
          * Function Object
          * Utility
          * Adaptor
          * Allocator.

    2. Component types are a structural classification: one based on what
       kind of C++ entity (if any) a component is. The component types are:

          * Type (i.e. a struct or class)
          * Function
          * Concept (as defined in the |stl-Introduction|).

   These two classification schemes are independent, and each of them applies
   to every STL component; |stl-Vector|, for example, is a type whose
   category is Containers, and |stl-ForwardIterator| is a concept whose
   category is Iterators.

   Both of these classification schemes appear at the top of every page that
   documents an STL component. The upper left corner identifies the the
   component's category as Containers, Iterators, Algorithms, Function
   Objects, Utilities, Adaptors, or Allocators, and the upper right corner
   identifies the component as a type, a function, or a concept.

Using the STL documentation

   The STL is a generic library: almost every class and function is a
   template. Accordingly, one of the most important purposes of the STL
   documentation is to provide a clear description of which types may be used
   to instantiate those templates. As described in the |stl-Introduction|, a
   concept is a generic set of requirements that a type must satisfy: a type
   is said to be a model of a concept if it satisfies all of that concept's
   requirements.

   Concepts are used very heavily in the STL documentation, both because they
   directly express type requirements, and because they are a tool for
   organizing types conceptually. (For example, the fact that
   |stl-ostream_iterator| and |stl-insert_iterator| are both models of
   |stl-OutputIterator| is an important statement about what those two
   classes have in common.) Concepts are used for the documentation of both
   types and functions.

  The format of a concept page

   A page that documents a concept has the following sections.

     * Summary: A description of the concept's purpose.
     * Refinement of: A list of other concepts that this concept refines,
       with links to those concepts.
     * Associated types: A concept is a set of requirements on some type.
       Frequently, however, some of those requirements involve some other
       type. For example, one of the |stl-UnaryFunction| requirements is that
       a |stl-UnaryFunction| must have an argument type; if F is a type that
       models |stl-UnaryFunction| and f is an object of type F, then, in the
       expression f(x), x must be of F's argument type. If a concept does
       have any such associated types, then they are defined in this section.
     * Notation: The next three sections, definitions, valid expressions, and
       expression semantics, present expressions involving types that model
       the concept being defined. This section defines the meaning of the
       variables and identifiers used in those expressions.
     * Definitions: Some concepts, such as |stl-LessThanComparable|, use
       specialized terminology. If a concept requires any such terminology,
       it is defined in this section.
     * Valid Expressions: A type that models a concept is required to support
       certain operations. In most cases, it doesn't make sense to describe
       this in terms of specific functions or member functions: it doesn't
       make any difference, for example, whether a type that models
       |stl-InputIterator| uses a global function or a member function to
       provide operator++. This section lists the expressions that a type
       modeling this concept must support. It includes any special
       requirements (if any) on the types of the expression's operands, and
       the expression's return type (if any).
     * Expression Semantics: The previous section, valid expressions, lists
       which expressions involving a type must be supported; it doesn't,
       however, define the meaning of those expressions. This section does:
       it lists the semantics, preconditions, and postconditions for the
       expressions defined in the previous section.
     * Complexity Guarantees: In some cases, the run-time complexity of
       certain operations is an important part of a concept's requirements.
       For example, one of the most significant distinctions between a
       |stl-BidirectionalIterator| and a |stl-RandomAccessIterator| is that,
       for random access iterators, expressions like p + n take constant
       time. Any such requirements on run-time complexity are listed in this
       section.
     * Invariants: Many concepts require that some property is always true
       for objects of a type that models the concept being defined. For
       example, |stl-LessThanComparable| imposes the requirement of
       transitivity: if x < y and y < z, then x < z. Some such properties are
       "axioms" (that is, they are independent of any other requirements) and
       some are "theorems" (that is, they follow either from requirements in
       the expression semantics section or from other requirements in the
       invariants section).
     * Models: A list of examples of types that are models of this concept.
       Note that this list is not intended to be complete: in most cases a
       complete list would be impossible, because there are an infinite
       number of types that could model the concept.
     * Notes: Footnotes (if any) that are referred to by other parts of the
       page.
     * See Also: Links to other related pages.

  The format of a type page

   A page that documents a type has the following sections.

     * Description. A summary of the type's properties.
     * Example of use: A code fragment involving the type.
     * Definition: A link to the source code where the type is defined.
     * Template parameters: Almost all STL structs and classes are templates.
       This section lists the name of each template parameter, its purpose,
       and its default value (if any).
     * Model of: A list of the concepts that this type is a model of, and
       links to those concepts. Note that a type may be a model of more than
       one concept: |stl-Vector|, for example, is a model of both
       |stl-RandomAccessContainer| and |stl-BackInsertionSequence|. If a type
       is a model of two different concepts, that simply means that it
       satisfies the requirements of both.
     * Type requirements: The template parameters of a class template usually
       must satisfy a set of requirements. Many of these can simply be
       expressed by listing which concept a template parameter must conform
       to, but some type requirements are slightly more complicated, and
       involve a relationship between two different template parameters.
     * Public base classes: If this class inherits from any other classes,
       they are listed in this section.
     * Members: A list of this type's nested types, member functions, member
       variables, and associated non-member functions. In most cases these
       members are simply listed, rather than defined: since the type is a
       model of some concept, detailed definitions aren't usually necessary.
       For example, |stl-Vector| is a model of |stl-Container|, so the
       description of the member function begin() in the |stl-Container| page
       applies to |stl-Vector|, and there is no need to repeat it in the
       |stl-Vector| page. Instead, the Members section provides a very brief
       description of each member and a link to whatever page defines that
       member more fully.
     * New Members: A type might have some members that are not part of the
       requirements of any of the concepts that it models. For example,
       |stl-Vector| has a member function called capacity(), which is not
       part of the |stl-RandomAccessContainer| or |stl-BackInsertionSequence|
       requirements. These members are defined in the New members section.
     * Notes: Footnotes (if any) that are referred to by other parts of the
       page.
     * See Also: Links to other related pages.

  The format of a function page

   A page that documents a function has the following sections.

     * Prototype: the function's declaration.
     * Description: A summary of what the function does.
     * Definition: A link to the source code where the function is defined.
     * Requirements on types: Most functions in the STL are function
       templates. This section lists the requirements that must be satisfied
       by the function's template parameters. Sometimes the requirements can
       simply be expressed by listing which concept a template parameter must
       conform to, but sometimes they are more complicated and involve a
       relationship between two different template parameters. In the case of
       |stl-find|, for example, the requirements are that the parameter
       InputIterator is a model of |stl-InputIterator|, that the parameter
       EqualityComparable is a model of |stl-EqualityComparable|, and that
       comparison for equality is possible between objects of type
       EqualityComparable and objects of InputIterator's value types.
     * Preconditions: Functions usually aren't guaranteed to yield a
       well-defined result for any possible input, but only for valid input;
       it is an error to call a function with invalid input. This section
       describes the conditions for validity.
     * Complexity: Guarantees on the function's run-time complexity. For
       example, |stl-find|'s run-time complexity is linear in the length of
       the input range.
     * Example of use: A code fragment that illustrates how to use the
       function.
     * Notes: Footnotes (if any) that are referred to by other parts of the
       page.
     * See Also: Links to other related pages.




********************************************************************************
                                  Containers
********************************************************************************
    ----------------------------------------------------------------------------
                                     Concepts
    ----------------------------------------------------------------------------
        ________________________________________________________________________
                                   General Concepts
*stl-Container*

                                   Container

   Category: containers                               Component type: concept

  Description

   A Container is an object that stores other objects (its elements), and
   that has methods for accessing its elements. In particular, every type
   that is a model of Container has an associated |stl-Iterators| type that
   can be used to iterate through the Container's elements.

   There is no guarantee that the elements of a Container are stored in any
   definite order; the order might, in fact, be different upon each iteration
   through the Container. Nor is there a guarantee that more than one
   iterator into a Container may be active at any one time. (Specific types
   of Containers, such as |stl-ForwardContainer|, do provide such
   guarantees.)

   A Container "owns" its elements: the lifetime of an element stored in a
   container cannot exceed that of the Container itself. [2][1]

  Refinement of

   |stl-Assignable|

  Associated types

   +------------------------------------------------------------------------+
   | Value type   | X::value_type      | The type of the object stored in a |
   |              |                    | container. The value type must be  |
   |              |                    | |stl-Assignable|, but need not be  |
   |              |                    | |stl-DefaultConstructible|. [3][2] |
   |--------------+--------------------+------------------------------------|
   | Iterator     | X::iterator        | The type of iterator used to       |
   | type         |                    | iterate through a container's      |
   |              |                    | elements. The iterator's value     |
   |              |                    | type is expected to be the         |
   |              |                    | container's value type. A          |
   |              |                    | conversion from the iterator type  |
   |              |                    | to the const iterator type must    |
   |              |                    | exist. The iterator type must be   |
   |              |                    | an |stl-InputIterator|. [4][3]     |
   |--------------+--------------------+------------------------------------|
   | Const        | X::const_iterator  | A type of iterator that may be     |
   | iterator     |                    | used to examine, but not to        |
   | type         |                    | modify, a container's elements.    |
   |              |                    | [5][3] [6][4]                      |
   |--------------+--------------------+------------------------------------|
   | Reference    | X::reference       | A type that behaves as a reference |
   | type         |                    | to the container's value type.     |
   |              |                    | [7][5]                             |
   |--------------+--------------------+------------------------------------|
   | Const        | X::const_reference | A type that behaves as a const     |
   | reference    |                    | reference to the container's value |
   | type         |                    | type. [8][5]                       |
   |--------------+--------------------+------------------------------------|
   | Pointer type | X::pointer         | A type that behaves as a pointer   |
   |              |                    | to the container's value type.     |
   |              |                    | [9][6]                             |
   |--------------+--------------------+------------------------------------|
   | Distance     | X::difference_type | A signed integral type used to     |
   | type         |                    | represent the distance between two |
   |              |                    | of the container's iterators. This |
   |              |                    | type must be the same as the       |
   |              |                    | iterator's distance type. [10][2]  |
   |--------------+--------------------+------------------------------------|
   | Size type    | X::size_type       | An unsigned integral type that can |
   |              |                    | represent any nonnegative value of |
   |              |                    | the container's distance type.     |
   |              |                    | [11][2]                            |
   +------------------------------------------------------------------------+

  Notation

   X    A type that is a model of Container
   a, b Object of type X
   T    The value type of X

  Definitions

   The size of a container is the number of elements it contains. The size is
   a nonnegative number.

   The area of a container is the total number of bytes that it occupies.
   More specifically, it is the sum of the elements' areas plus whatever
   overhead is associated with the container itself. If a container's value
   type T is a simple type (as opposed to a container type), then the
   container's area is bounded above by a constant times the container's size
   times sizeof(T). That is, if a is a container with a simple value type,
   then a's area is O(a.size()).

   A variable sized container is one that provides methods for inserting
   and/or removing elements; its size may vary during a container's lifetime.
   A fixed size container is one where the size is constant throughout the
   container's lifetime. In some fixed-size container types, the size is
   determined at compile time.

  Valid expressions

   In addition to the expressions defined in |stl-Assignable|,
   |stl-EqualityComparable|, and |stl-LessThanComparable|, the following
   expressions must be valid.

   +------------------------------------------------------------------------+
   |     Name      |  Expression  |     Type      |       Return type       |
   |               |              | requirements  |                         |
   |---------------+--------------+---------------+-------------------------|
   | Beginning of  | a.begin()    |               | iterator if a is        |
   | range         |              |               | mutable, const_iterator |
   |               |              |               | otherwise [12][4]       |
   |               |              |               | [13][7]                 |
   |---------------+--------------+---------------+-------------------------|
   | End of range  | a.end()      |               | iterator if a is        |
   |               |              |               | mutable, const_iterator |
   |               |              |               | otherwise [14][4]       |
   |---------------+--------------+---------------+-------------------------|
   | Size          | a.size()     |               | size_type               |
   |---------------+--------------+---------------+-------------------------|
   | Maximum size  | a.max_size() |               | size_type               |
   |---------------+--------------+---------------+-------------------------|
   | Empty         | a.empty()    |               | Convertible to bool     |
   | container     |              |               |                         |
   |---------------+--------------+---------------+-------------------------|
   | Swap          | a.swap(b)    |               | void                    |
   +------------------------------------------------------------------------+

  Expression semantics

   Semantics of an expression is defined only where it differs from, or is
   not defined in, |stl-Assignable|, |stl-EqualityComparable|, or
   |stl-LessThanComparable|

  +----------------------------------------------------------------------------+
  |    Name     | Expression  |Precondition |  Semantics   |   Postcondition   |
  |-------------+-------------+-------------+--------------+-------------------|
  |Copy         |X(a)         |             |              |X().size() ==      |
  |constructor  |             |             |              |a.size(). X()      |
  |             |             |             |              |contains a copy of |
  |             |             |             |              |each of a's        |
  |             |             |             |              |elements.          |
  |-------------+-------------+-------------+--------------+-------------------|
  |Copy         |X b(a);      |             |              |b.size() ==        |
  |constructor  |             |             |              |a.size(). b        |
  |             |             |             |              |contains a copy of |
  |             |             |             |              |each of a's        |
  |             |             |             |              |elements.          |
  |-------------+-------------+-------------+--------------+-------------------|
  |Assignment   |b = a        |             |              |b.size() ==        |
  |operator     |             |             |              |a.size(). b        |
  |             |             |             |              |contains a copy of |
  |             |             |             |              |each of a's        |
  |             |             |             |              |elements.          |
  |-------------+-------------+-------------+--------------+-------------------|
  |Destructor   |a.~X()       |             |Each of a's   |                   |
  |             |             |             |elements is   |                   |
  |             |             |             |destroyed, and|                   |
  |             |             |             |memory        |                   |
  |             |             |             |allocated for |                   |
  |             |             |             |them (if any) |                   |
  |             |             |             |is            |                   |
  |             |             |             |deallocated.  |                   |
  |-------------+-------------+-------------+--------------+-------------------|
  |Beginning of |a.begin()    |             |Returns an    |a.begin() is either|
  |range        |             |             |iterator      |dereferenceable or |
  |             |             |             |pointing to   |past-the-end. It is|
  |             |             |             |the first     |past-the-end if and|
  |             |             |             |element in the|only if a.size() ==|
  |             |             |             |container.    |0.                 |
  |             |             |             |[15][7]       |                   |
  |-------------+-------------+-------------+--------------+-------------------|
  |End of range |a.end()      |             |Returns an    |a.end() is         |
  |             |             |             |iterator      |past-the-end.      |
  |             |             |             |pointing one  |                   |
  |             |             |             |past the last |                   |
  |             |             |             |element in the|                   |
  |             |             |             |container.    |                   |
  |-------------+-------------+-------------+--------------+-------------------|
  |Size         |a.size()     |             |Returns the   |a.size() >= 0 &&   |
  |             |             |             |size of the   |a.size() <=        |
  |             |             |             |container,    |max_size()         |
  |             |             |             |that is, its  |                   |
  |             |             |             |number of     |                   |
  |             |             |             |elements.     |                   |
  |             |             |             |[16][8]       |                   |
  |-------------+-------------+-------------+--------------+-------------------|
  |Maximum size |a.max_size() |             |Returns the   |a.max_size() >= 0  |
  |             |             |             |largest size  |&& a.max_size() >= |
  |             |             |             |that this     |a.size()           |
  |             |             |             |container can |                   |
  |             |             |             |ever have.    |                   |
  |             |             |             |[17][8]       |                   |
  |-------------+-------------+-------------+--------------+-------------------|
  |Empty        |a.empty()    |             |Equivalent to |                   |
  |container    |             |             |a.size() == 0.|                   |
  |             |             |             |(But possibly |                   |
  |             |             |             |faster.)      |                   |
  |-------------+-------------+-------------+--------------+-------------------|
  |Swap         |a.swap(b)    |             |Equivalent to |                   |
  |             |             |             |swap(a,b)     |                   |
  |             |             |             |[18][9]       |                   |
  +----------------------------------------------------------------------------+

  Complexity guarantees

   The copy constructor, the assignment operator, and the destructor are
   linear in the container's size.

   begin() and end() are amortized constant time.

   size() is linear in the container's size. [19][10] max_size() and empty()
   are amortized constant time. If you are testing whether a container is
   empty, you should always write c.empty() instead of c.size() == 0. The two
   expressions are equivalent, but the former may be much faster.

   swap() is amortized constant time. [20][9]

  Invariants

   +------------------------------------------------------------------------+
   | Valid range  | For any container a, [a.begin(), a.end()) is a valid    |
   |              | range. [21][11]                                         |
   |--------------+---------------------------------------------------------|
   | Range size   | a.size() is equal to the distance from a.begin() to     |
   |              | a.end().                                                |
   |--------------+---------------------------------------------------------|
   | Completeness | An algorithm that iterates through the range            |
   |              | [a.begin(), a.end()) will pass through every element of |
   |              | a. [22][11]                                             |
   +------------------------------------------------------------------------+

  Models

     * |stl-Vector|

  Notes

   [1] The fact that the lifetime of elements cannot exceed that of of their
   container may seem like a severe restriction. In fact, though, it is not.
   Note that pointers and iterators are objects; like any other objects, they
   may be stored in a container. The container, in that case, "owns" the
   pointers themselves, but not the objects that they point to.

   [2] This expression must be a typedef, that is, a synonym for a type that
   already has some other name.

   [3] This may either be a typedef for some other type, or else a unique
   type that is defined as a nested class within the class X.

   [4] A container's iterator type and const iterator type may be the same:
   there is no guarantee that every container must have an associated mutable
   iterator type. For example, |stl-set| and |stl-hash_set| define iterator
   and const_iterator to be the same type.

   [5] It is required that the reference type has the same semantics as an
   ordinary C++ reference, but it need not actually be an ordinary C++
   reference. Some implementations, for example, might provide additional
   reference types to support non-standard memory models. Note, however, that
   "smart references" (user-defined reference types that provide additional
   functionality) are not a viable option. It is impossible for a
   user-defined type to have the same semantics as C++ references, because
   the C++ language does not support redefining the member access operator
   (operator.).

   [6] As in the case of references [23][5], the pointer type must have the
   same semantics as C++ pointers but need not actually be a C++ pointer.
   "Smart pointers," however, unlike "smart references", are possible. This
   is because it is possible for user-defined types to define the dereference
   operator and the pointer member access operator, operator* and operator->.

   [7] The iterator type need only be an input iterator, which provides a
   very weak set of guarantees; in particular, all algorithms on input
   iterators must be "single pass". It follows that only a single iterator
   into a container may be active at any one time. This restriction is
   removed in |stl-ForwardContainer|.

   [8] In the case of a fixed-size container, size() == max_size().

   [9] For any |stl-Assignable| type, |stl-swap| can be defined in terms of
   assignment. This requires three assignments, each of which, for a
   container type, is linear in the container's size. In a sense, then,
   a.swap(b) is redundant. It exists solely for the sake of efficiency: for
   many containers, such as |stl-Vector| and |stl-List|, it is possible to
   implement swap such that its run-time complexity is constant rather than
   linear. If this is possible for some container type X, then the template
   specialization |stl-swap|(X&, X&) can simply be written in terms of
   X::swap(X&). The implication of this is that X::swap(X&) should only be
   defined if there exists such a constant-time implementation. Not every
   container class X need have such a member function, but if the member
   function exists at all then it is guaranteed to be amortized constant
   time.

   [10] For many containers, such as |stl-Vector| and |stl-Deque|, size is
   O(1). This satisfies the requirement that it be O(N).

   [11] Although [a.begin(), a.end()) must be a valid range, and must include
   every element in the container, the order in which the elements appear in
   that range is unspecified. If you iterate through a container twice, it is
   not guaranteed that the order will be the same both times. This
   restriction is removed in |stl-ForwardContainer|.

  See also

   The |stl-Iterators|, |stl-InputIterator|, |stl-Sequence|

*stl-ForwardContainer*

                               Forward Container

   Category: containers                               Component type: concept

  Description

   A Forward Container is a |stl-Container| whose elements are arranged in a
   definite order: the ordering will not change spontaneously from iteration
   to iteration. The requirement of a definite ordering allows the definition
   of element-by-element equality (if the container's element type is
   |stl-EqualityComparable|) and of lexicographical ordering (if the
   container's element type is |stl-LessThanComparable|).

   Iterators into a Forward Container satisfy the |stl-ForwardIterator|
   requirements; consequently, Forward Containers support multipass
   algorithms and allow multiple iterators into the same container to be
   active at the same time.

  Refinement of

   |stl-Container|, |stl-EqualityComparable|, |stl-LessThanComparable|

  Associated types

   No additional types beyond those defined in |stl-Container|. However, the
   requirements for the iterator type are strengthened: the iterator type
   must be a model of |stl-ForwardIterator|.

  Notation

   X    A type that is a model of Forward Container
   a, b Object of type X
   T    The value type of X

  Definitions

  Valid expressions

   In addition to the expressions defined in |stl-Container|,
   |stl-EqualityComparable|, and |stl-LessThanComparable|, the following
   expressions must be valid.

   +------------------------------------------------------------------------+
   |    Name     | Expression |      Type requirements       | Return type  |
   |-------------+------------+------------------------------+--------------|
   | Equality    | a == b     | T is                         | Convertible  |
   |             |            | |stl-EqualityComparable|     | to bool      |
   |-------------+------------+------------------------------+--------------|
   | Inequality  | a != b     | T is                         | Convertible  |
   |             |            | |stl-EqualityComparable|     | to bool      |
   |-------------+------------+------------------------------+--------------|
   | Less        | a < b      | T is                         | Convertible  |
   |             |            | |stl-LessThanComparable|     | to bool      |
   |-------------+------------+------------------------------+--------------|
   | Greater     | a > b      | T is                         | Convertible  |
   |             |            | |stl-LessThanComparable|     | to bool      |
   |-------------+------------+------------------------------+--------------|
   | Less or     | a <= b     | T is                         | Convertible  |
   | equal       |            | |stl-LessThanComparable|     | to bool      |
   |-------------+------------+------------------------------+--------------|
   | Greater or  | a >= b     | T is                         | Convertible  |
   | equal       |            | |stl-LessThanComparable|     | to bool      |
   +------------------------------------------------------------------------+

  Expression semantics

   Semantics of an expression is defined only where it is not defined in
   |stl-Container|, |stl-EqualityComparable|, or |stl-LessThanComparable|, or
   where there is additional information.

+-------------------------------------------------------------------------------------------+
|  Name   |Expression |Precondition |               Semantics                |Postcondition |
|---------+-----------+-------------+----------------------------------------+--------------|
|Equality |a == b     |             |Returns true if a.size() == b.size() and|              |
|         |           |             |if each element of a compares equal to  |              |
|         |           |             |the corresponding element of b.         |              |
|         |           |             |Otherwise returns false.                |              |
|---------+-----------+-------------+----------------------------------------+--------------|
|Less     |a < b      |             |Equivalent to                           |              |
|         |           |             ||stl-lexicographical_compare|(a,b)      |              |
+-------------------------------------------------------------------------------------------+

  Complexity guarantees

   The equality and inequality operations are linear in the container's size.

  Invariants

   +------------------------------------------------------------------------+
   | Ordering | Two different iterations through a forward container will   |
   |          | access its elements in the same order, providing that there |
   |          | have been no intervening mutative operations.               |
   +------------------------------------------------------------------------+

  Models

     * |stl-Vector|
     * |stl-List|
     * |stl-Slist|
     * |stl-Deque|
     * |stl-set|
     * |stl-hash_set|
     * |stl-Map|
     * |stl-hash_map|
     * |stl-multiset|
     * |stl-hash_multiset|
     * |stl-Multimap|
     * |stl-hash_multimap|

  See also

   The |stl-Iterators|, |stl-ForwardIterator|, |stl-Sequence|

*stl-ReversibleContainer*

                              Reversible Container

   Category: containers                               Component type: concept

  Description

   A Reversible Container is a |stl-ForwardContainer| whose iterators are
   |stl-BidirectionalIterator|. It allows backwards iteration through the
   container.

  Refinement of

   |stl-ForwardContainer|

  Associated types

   Two new types are introduced. In addition, the iterator type and the const
   iterator type must satisfy a more stringent requirement than for a
   |stl-ForwardContainer|. The iterator and reverse iterator types must be
   |stl-BidirectionalIterator|, not merely |stl-ForwardIterator|.

   +------------------------------------------------------------------------+
   | Reverse  | X::reverse_iterator       | A |stl-ReverseIterator| adaptor |
   | iterator |                           | whose base iterator type is the |
   | type     |                           | container's iterator type.      |
   |          |                           | Incrementing an object of type  |
   |          |                           | reverse_iterator moves          |
   |          |                           | backwards through the           |
   |          |                           | container: the                  |
   |          |                           | |stl-ReverseIterator| adaptor   |
   |          |                           | maps operator++ to operator--.  |
   |----------+---------------------------+---------------------------------|
   | Const    | X::const_reverse_iterator | A |stl-ReverseIterator| adaptor |
   | reverse  |                           | whose base iterator type is the |
   | iterator |                           | container's const iterator      |
   | type     |                           | type. [2][1]                    |
   +------------------------------------------------------------------------+

  Notation

   X    A type that is a model of Reversible Container
   a, b Object of type X

  Definitions

  Valid expressions

   In addition to the expressions defined in |stl-ForwardContainer|, the
   following expressions must be valid.

   +------------------------------------------------------------------------+
   |   Name    | Expression |     Type      |          Return type          |
   |           |            | requirements  |                               |
   |-----------+------------+---------------+-------------------------------|
   | Beginning | a.rbegin() |               | reverse_iterator if a is      |
   | of range  |            |               | mutable,                      |
   |           |            |               | const_reverse_iterator        |
   |           |            |               | otherwise [3][1]              |
   |-----------+------------+---------------+-------------------------------|
   | End of    | a.rend()   |               | reverse_iterator if a is      |
   | range     |            |               | mutable,                      |
   |           |            |               | const_reverse_iterator        |
   |           |            |               | otherwise [4][1]              |
   +------------------------------------------------------------------------+

  Expression semantics

   Semantics of an expression is defined only where it is not defined in
   |stl-ForwardContainer|, or where there is additional information.

+-------------------------------------------------------------------------------------------+
|   Name   |Expression |Precondition |           Semantics            |    Postcondition    |
|----------+-----------+-------------+--------------------------------+---------------------|
|Beginning |a.rbegin() |             |Equivalent to                   |a.rbegin() is        |
|of reverse|           |             |X::reverse_iterator(a.end()).   |dereferenceable or   |
|range     |           |             |                                |past-the-end. It is  |
|          |           |             |                                |past-the-end if and  |
|          |           |             |                                |only if a.size() ==  |
|          |           |             |                                |0.                   |
|----------+-----------+-------------+--------------------------------+---------------------|
|End of    |a.rend()   |             |Equivalent to                   |a.end() is           |
|reverse   |           |             |X::reverse_iterator(a.begin()). |past-the-end.        |
|range     |           |             |                                |                     |
+-------------------------------------------------------------------------------------------+

  Complexity guarantees

   The run-time complexity of rbegin() and rend() is amortized constant time.

  Invariants

   +------------------------------------------------------------------------+
   | Valid range           | [a.rbegin(), a.rend()) is a valid range.       |
   |-----------------------+------------------------------------------------|
   | Equivalence of ranges | The distance from a.begin() to a.end() is the  |
   |                       | same as the distance from a.rbegin() to        |
   |                       | a.rend().                                      |
   +------------------------------------------------------------------------+

  Models

     * |stl-Vector|
     * |stl-List|
     * |stl-Deque|

  Notes

   [1] A |stl-Container|'s iterator type and const iterator type may be the
   same type: a container need not provide mutable iterators. It follows from
   this that the reverse iterator type and the const reverse iterator type
   may also be the same.

  See also

   The |stl-Iterators|, |stl-BidirectionalIterator|, |stl-Sequence|

*stl-RandomAccessContainer*

                            Random Access Container

   Category: containers                               Component type: concept

  Description

   A Random Access Container is a |stl-ReversibleContainer| whose iterator
   type is a |stl-RandomAccessIterator|. It provides amortized constant time
   access to arbitrary elements.

  Refinement of

   |stl-ReversibleContainer|

  Associated types

   No additional types beyond those defined in |stl-ReversibleContainer|.
   However, the requirements for the iterator type are strengthened: it must
   be a |stl-RandomAccessIterator|.

  Notation

   X    A type that is a model of Random Access Container
   a, b Object of type X
   T    The value type of X

  Definitions

  Valid expressions

   In addition to the expressions defined in |stl-ReversibleContainer|, the
   following expressions must be valid.

   +------------------------------------------------------------------------+
   |  Name   | Expression | Type requirements  |        Return type         |
   |---------+------------+--------------------+----------------------------|
   | Element | a[n]       | n is convertible   | reference if a is mutable, |
   | access  |            | to size_type       | const_reference otherwise  |
   +------------------------------------------------------------------------+

  Expression semantics

   Semantics of an expression is defined only where it is not defined in
   |stl-ReversibleContainer|, or where there is additional information.

   +------------------------------------------------------------------------+
   |  Name   | Expression | Precondition  |    Semantics    | Postcondition |
   |---------+------------+---------------+-----------------+---------------|
   | Element | a[n]       | 0 <= n <      | Returns the nth |               |
   | access  |            | a.size()      | element from    |               |
   |         |            |               | the beginning   |               |
   |         |            |               | of the          |               |
   |         |            |               | container.      |               |
   +------------------------------------------------------------------------+

  Complexity guarantees

   The run-time complexity of element access is amortized constant time.

  Invariants

   +------------------------------------------------------------------------+
   | Element access | The element returned by a[n] is the same as the one   |
   |                | obtained by incrementing a.begin() n times and then   |
   |                | dereferencing the resulting iterator.                 |
   +------------------------------------------------------------------------+

  Models

     * |stl-Vector|
     * |stl-Deque|

  See also

   The |stl-Iterators|, |stl-RandomAccessIterator|, |stl-Sequence|


        ________________________________________________________________________
                                      Sequences
*stl-Sequence*

                                    Sequence

   Category: containers                               Component type: concept

  Description

   A Sequence is a variable-sized |stl-Container| whose elements are arranged
   in a strict linear order. It supports insertion and removal of elements.

  Refinement of

   |stl-ForwardContainer|, |stl-DefaultConstructible|

  Associated types

   None, except for those of |stl-ForwardContainer|.

  Notation

   X    A type that is a model of Sequence
   a, b Object of type X
   T    The value type of X
   t    Object of type T
   p, q Object of type X::iterator
   n    Object of a type convertible to X::size_type

  Definitions

   If a is a Sequence, then p is a valid iterator in a if it is a valid
   (nonsingular) iterator that is reachable from a.begin().

   If a is a Sequence, then [p, q) is a valid range in a if p and q are valid
   iterators in a and if q is reachable from p.

  Valid expressions

   In addition to the expressions defined in |stl-ForwardContainer|, the
   following expressions must be valid.

  +----------------------------------------------------------------------------+
  |    Name     |  Expression  |      Type requirements      |   Return type   |
  |-------------+--------------+-----------------------------+-----------------|
  |Fill         |X(n, t)       |                             |X                |
  |constructor  |              |                             |                 |
  |-------------+--------------+-----------------------------+-----------------|
  |Fill         |X a(n, t);    |                             |                 |
  |constructor  |              |                             |                 |
  |-------------+--------------+-----------------------------+-----------------|
  |Default fill |X(n)          |T is                         |X                |
  |constructor  |              ||stl-DefaultConstructible|.  |                 |
  |-------------+--------------+-----------------------------+-----------------|
  |Default fill |X a(n);       |T is                         |                 |
  |constructor  |              ||stl-DefaultConstructible|.  |                 |
  |-------------+--------------+-----------------------------+-----------------|
  |Range        |X(i, j)       |i and j are                  |X                |
  |constructor  |              ||stl-InputIterator| whose    |                 |
  |             |              |value type is convertible to |                 |
  |             |              |T [2][1]                     |                 |
  |-------------+--------------+-----------------------------+-----------------|
  |Range        |X a(i, j);    |i and j are                  |                 |
  |constructor  |              ||stl-InputIterator| whose    |                 |
  |             |              |value type is convertible to |                 |
  |             |              |T [3][1]                     |                 |
  |-------------+--------------+-----------------------------+-----------------|
  |Front        |a.front()     |                             |reference if a is|
  |             |              |                             |mutable,         |
  |             |              |                             |const_reference  |
  |             |              |                             |otherwise.       |
  |-------------+--------------+-----------------------------+-----------------|
  |Insert       |a.insert(p, t)|                             |X::iterator      |
  |-------------+--------------+-----------------------------+-----------------|
  |Fill insert  |a.insert(p, n,|a is mutable                 |void             |
  |             |t)            |                             |                 |
  |-------------+--------------+-----------------------------+-----------------|
  |Range insert |a.insert(p, i,|i and j are                  |void             |
  |             |j)            ||stl-InputIterator| whose    |                 |
  |             |              |value type is convertible to |                 |
  |             |              |T [4][1]. a is mutable       |                 |
  |-------------+--------------+-----------------------------+-----------------|
  |Erase        |a.erase(p)    |a is mutable                 |iterator         |
  |-------------+--------------+-----------------------------+-----------------|
  |Range erase  |a.erase(p,q)  |a is mutable                 |iterator         |
  |-------------+--------------+-----------------------------+-----------------|
  |Clear        |a.clear()     |a is mutable                 |void             |
  |-------------+--------------+-----------------------------+-----------------|
  |Resize       |a.resize(n, t)|a is mutable                 |void             |
  |-------------+--------------+-----------------------------+-----------------|
  |Resize       |a.resize(n)   |a is mutable                 |void             |
  +----------------------------------------------------------------------------+

  Expression semantics

   Semantics of an expression is defined only where it is not defined in
   |stl-ForwardContainer|, or where it differs.

+--------------------------------------------------------------------------------------+
|    Name     |  Expression  |  Precondition   |     Semantics      |  Postcondition   |
|-------------+--------------+-----------------+--------------------+------------------|
|Fill         |X(n, t)       |n >= 0           |Creates a sequence  |size() == n. Every|
|constructor  |              |                 |with n copies of t  |element is a copy |
|             |              |                 |                    |of t.             |
|-------------+--------------+-----------------+--------------------+------------------|
|Fill         |X a(n, t);    |n >= 0           |Creates a sequence  |a.size() == n.    |
|constructor  |              |                 |with n copies of t  |Every element of a|
|             |              |                 |                    |is a copy of t.   |
|-------------+--------------+-----------------+--------------------+------------------|
|Default fill |X(n)          |n >= 0           |Creates a sequence  |size() == n. Every|
|constructor  |              |                 |of n elements       |element is a copy |
|             |              |                 |initialized to a    |of T().           |
|             |              |                 |default value.      |                  |
|-------------+--------------+-----------------+--------------------+------------------|
|Default fill |X a(n, t);    |n >= 0           |Creates a sequence  |a.size() == n.    |
|constructor  |              |                 |with n elements     |Every element of a|
|             |              |                 |initialized to a    |is a copy of T(). |
|             |              |                 |default value.      |                  |
|-------------+--------------+-----------------+--------------------+------------------|
|Default      |X a; or X()   |                 |Equivalent to X(0). |size() == 0.      |
|constructor  |              |                 |                    |                  |
|-------------+--------------+-----------------+--------------------+------------------|
|Range        |X(i, j)       |[i,j) is a valid |Creates a sequence  |size() is equal to|
|constructor  |              |range.           |that is a copy of   |the distance from |
|             |              |                 |the range [i,j)     |i to j. Each      |
|             |              |                 |                    |element is a copy |
|             |              |                 |                    |of the            |
|             |              |                 |                    |corresponding     |
|             |              |                 |                    |element in the    |
|             |              |                 |                    |range [i,j).      |
|-------------+--------------+-----------------+--------------------+------------------|
|Range        |X a(i, j);    |[i,j) is a valid |Creates a sequence  |a.size() is equal |
|constructor  |              |range.           |that is a copy of   |to the distance   |
|             |              |                 |the range [i,j)     |from i to j. Each |
|             |              |                 |                    |element in a is a |
|             |              |                 |                    |copy of the       |
|             |              |                 |                    |corresponding     |
|             |              |                 |                    |element in the    |
|             |              |                 |                    |range [i,j).      |
|-------------+--------------+-----------------+--------------------+------------------|
|Front        |a.front()     |!a.empty()       |Equivalent to       |                  |
|             |              |                 |*(a.first())        |                  |
|-------------+--------------+-----------------+--------------------+------------------|
|Insert       |a.insert(p, t)|p is a valid     |A copy of t is      |a.size() is       |
|             |              |iterator in a.   |inserted before p.  |incremented by 1. |
|             |              |a.size() <       |[5][2] [6][3]       |*(a.insert(p,t))  |
|             |              |a.max_size()     |                    |is a copy of t.   |
|             |              |                 |                    |The relative order|
|             |              |                 |                    |of elements       |
|             |              |                 |                    |already in the    |
|             |              |                 |                    |sequence is       |
|             |              |                 |                    |unchanged.        |
|-------------+--------------+-----------------+--------------------+------------------|
|Fill insert  |a.insert(p, n,|p is a valid     |n copies of t are   |a.size() is       |
|             |t)            |iterator in a. n |inserted before p.  |incremented by n. |
|             |              |>= 0 && a.size() |[7][2] [8][3] [9][4]|The relative order|
|             |              |+ n <=           |                    |of elements       |
|             |              |a.max_size().    |                    |already in the    |
|             |              |                 |                    |sequence is       |
|             |              |                 |                    |unchanged.        |
|-------------+--------------+-----------------+--------------------+------------------|
|Range insert |a.insert(p, i,|[i,j) is a valid |Inserts a copy of   |a.size() is       |
|             |j)            |range. a.size()  |the range [i,j)     |incremented by the|
|             |              |plus the distance|before p. [10][1]   |distance from i to|
|             |              |from i to j does |[11][2] [12][3]     |j. The relative   |
|             |              |not exceed       |                    |order of elements |
|             |              |a.max_size().    |                    |already in the    |
|             |              |                 |                    |sequence is       |
|             |              |                 |                    |unchanged.        |
|-------------+--------------+-----------------+--------------------+------------------|
|Erase        |a.erase(p)    |p is a           |Destroys the element|a.size() is       |
|             |              |dereferenceable  |pointed to by p and |decremented by 1. |
|             |              |iterator in a.   |removes it from a.  |The relative order|
|             |              |                 |[13][3]             |of the other      |
|             |              |                 |                    |elements in the   |
|             |              |                 |                    |sequence is       |
|             |              |                 |                    |unchanged. The    |
|             |              |                 |                    |return value is an|
|             |              |                 |                    |iterator to the   |
|             |              |                 |                    |element           |
|             |              |                 |                    |immediately       |
|             |              |                 |                    |following the one |
|             |              |                 |                    |that was erased.  |
|-------------+--------------+-----------------+--------------------+------------------|
|Range erase  |a.erase(p,q)  |[p,q) is a valid |Destroys the        |a.size() is       |
|             |              |range in a.      |elements in the     |decremented by the|
|             |              |                 |range [p,q) and     |distance from i to|
|             |              |                 |removes them from a.|j. The relative   |
|             |              |                 |[14][3]             |order of the other|
|             |              |                 |                    |elements in the   |
|             |              |                 |                    |sequence is       |
|             |              |                 |                    |unchanged. The    |
|             |              |                 |                    |return value is an|
|             |              |                 |                    |iterator to the   |
|             |              |                 |                    |element           |
|             |              |                 |                    |immediately       |
|             |              |                 |                    |following the ones|
|             |              |                 |                    |that were erased. |
|-------------+--------------+-----------------+--------------------+------------------|
|Clear        |a.clear()     |                 |Equivalent to       |                  |
|             |              |                 |a.erase(a.begin(),  |                  |
|             |              |                 |a.end())            |                  |
|-------------+--------------+-----------------+--------------------+------------------|
|Resize       |a.resize(n, t)|n <= a.max_size()|Modifies the        |a.size() == n     |
|             |              |                 |container so that it|                  |
|             |              |                 |has exactly n       |                  |
|             |              |                 |elements, inserting |                  |
|             |              |                 |elements at the end |                  |
|             |              |                 |or erasing elements |                  |
|             |              |                 |from the end if     |                  |
|             |              |                 |necessary. If any   |                  |
|             |              |                 |elements are        |                  |
|             |              |                 |inserted, they are  |                  |
|             |              |                 |copies of t. If n > |                  |
|             |              |                 |a.size(), this      |                  |
|             |              |                 |expression is       |                  |
|             |              |                 |equivalent to       |                  |
|             |              |                 |a.insert(a.end(), n |                  |
|             |              |                 |- size(), t). If n <|                  |
|             |              |                 |a.size(), it is     |                  |
|             |              |                 |equivalent to       |                  |
|             |              |                 |a.erase(a.begin() + |                  |
|             |              |                 |n, a.end()).        |                  |
|-------------+--------------+-----------------+--------------------+------------------|
|Resize       |a.resize(n)   |n <= a.max_size()|Equivalent to       |a.size() == n     |
|             |              |                 |a.resize(n, T()).   |                  |
+--------------------------------------------------------------------------------------+

  Complexity guarantees

   The fill constructor, default fill constructor, and range constructor are
   linear.

   Front is amortized constant time.

   Fill insert, range insert, and range erase are linear.

   The complexities of single-element insert and erase are sequence
   dependent.

  Invariants

  Models

     * |stl-Vector| [15][5]
     * |stl-Deque|
     * |stl-List|
     * |stl-Slist|

  Notes

   [1] At present (early 1998), not all compilers support "member templates".
   If your compiler supports member templates then i and j may be of any type
   that conforms to the |stl-InputIterator| requirements. If your compiler
   does not yet support member templates, however, then i and j must be of
   type const T* or of type X::const_iterator.

   [2] Note that p equal to a.begin() means to insert something at the
   beginning of a (that is, before any elements already in a), and p equal to
   a.end() means to append something to the end of a.

   [3] Warning: there is no guarantee that a valid iterator on a is still
   valid after an insertion or an erasure. In some cases iterators do remain
   valid, and in other cases they do not. The details are different for each
   sequence class.

   [4] a.insert(p, n, t) is guaranteed to be no slower then calling
   a.insert(p, t) n times. In some cases it is significantly faster.

   [5] |stl-Vector| is usually preferable to |stl-Deque| and |stl-List|.
   |stl-Deque| is useful in the case of frequent insertions at both the
   beginning and end of the sequence, and |stl-List| and |stl-Slist| are
   useful in the case of frequent insertions in the middle of the sequence.
   In almost all other situations, |stl-Vector| is more efficient.

  See also

   |stl-Container|, |stl-ForwardContainer|, |stl-AssociativeContainer|,
   |stl-FrontInsertionSequence|, |stl-BackInsertionSequence|, |stl-Vector|,
   |stl-Deque|, |stl-List|, |stl-Slist|

*stl-FrontInsertionSequence*

                            Front Insertion Sequence

   Category: containers                               Component type: concept

  Description

   A Front Insertion Sequence is a |stl-Sequence| where it is possible to
   insert an element at the beginning, or to access the first element, in
   amortized constant time. Front Insertion Sequences have special member
   functions as a shorthand for those operations.

  Refinement of

   |stl-Sequence|

  Associated types

   None, except for those of |stl-Sequence|.

  Notation

   X A type that is a model of Front Insertion Sequence
   a Object of type X
   T The value type of X
   t Object of type T

  Definitions

  Valid expressions

   In addition to the expressions defined in |stl-Sequence|, the following
   expressions must be valid.

   +------------------------------------------------------------------------+
   |  Name  |    Expression    |      Type      |        Return type        |
   |        |                  |  requirements  |                           |
   |--------+------------------+----------------+---------------------------|
   | Front  | a.front() [2][1] |                | reference if a is         |
   |        |                  |                | mutable, otherwise        |
   |        |                  |                | const_reference.          |
   |--------+------------------+----------------+---------------------------|
   | Push   | a.push_front(t)  | a is mutable.  | void                      |
   | front  |                  |                |                           |
   |--------+------------------+----------------+---------------------------|
   | Pop    | a.pop_front()    | a is mutable.  | void                      |
   | front  |                  |                |                           |
   +------------------------------------------------------------------------+

  Expression semantics

+------------------------------------------------------------------------------+
| Name |   Expression    |Precondition |     Semantics     |   Postcondition   |
|------+-----------------+-------------+-------------------+-------------------|
|Front |a.front() [3][1] |!a.empty()   |Equivalent to      |                   |
|      |                 |             |*(a.begin()).      |                   |
|------+-----------------+-------------+-------------------+-------------------|
|Push  |a.push_front(t)  |             |Equivalent to      |a.size is          |
|front |                 |             |a.insert(a.begin(),|incremented by 1.  |
|      |                 |             |t)                 |a.front() is a copy|
|      |                 |             |                   |of t.              |
|------+-----------------+-------------+-------------------+-------------------|
|Pop   |a.pop_front()    |!a.empty()   |Equivalent to      |a.size() is        |
|front |                 |             |a.erase(a.begin()) |decremented by 1.  |
+------------------------------------------------------------------------------+

  Complexity guarantees

   Front, push front, and pop front are amortized constant time. [4][2]

  Invariants

   +------------------------------------------------------------------------+
   | Symmetry of push and pop | push_front() followed by pop_front() is a   |
   |                          | null operation.                             |
   +------------------------------------------------------------------------+

  Models

     * |stl-List|
     * |stl-Deque|

  Notes

   [1] Front is actually defined in |stl-Sequence|, since it is always
   possible to implement it in amortized constant time. Its definition is
   repeated here, along with push front and pop front, in the interest of
   clarity.

   [2] This complexity guarantee is the only reason that front(),
   push_front(), and pop_front() are defined: they provide no additional
   functionality. Not every sequence must define these operations, but it is
   guaranteed that they are efficient if they exist at all.

  See also

   |stl-Container|, |stl-Sequence|, |stl-BackInsertionSequence|, |stl-Deque|,
   |stl-List|, |stl-Slist|

*stl-BackInsertionSequence*

                            Back Insertion Sequence

   Category: containers                               Component type: concept

  Description

   A Back Insertion Sequence is a |stl-Sequence| where it is possible to
   append an element to the end, or to access the last element, in amortized
   constant time. Back Insertion Sequences have special member functions as a
   shorthand for those operations.

  Refinement of

   |stl-Sequence|

  Associated types

   None, except for those of |stl-Sequence|.

  Notation

   X A type that is a model of Back Insertion Sequence
   a Object of type X
   T The value type of X
   t Object of type T

  Definitions

  Valid expressions

   In addition to the expressions defined in |stl-Sequence|, the following
   expressions must be valid.

   +------------------------------------------------------------------------+
   |   Name   |   Expression   |      Type      |        Return type        |
   |          |                |  requirements  |                           |
   |----------+----------------+----------------+---------------------------|
   | Back     | a.back()       |                | reference if a is         |
   |          |                |                | mutable, otherwise        |
   |          |                |                | const_reference.          |
   |----------+----------------+----------------+---------------------------|
   | Push     | a.push_back(t) | a is mutable.  | void                      |
   | back     |                |                |                           |
   |----------+----------------+----------------+---------------------------|
   | Pop back | a.pop_back()   | a is mutable.  | void                      |
   +------------------------------------------------------------------------+

  Expression semantics

   +---------------------------------------------------------------------------+
   |Name |  Expression   |Precondition |     Semantics      |  Postcondition   |
   |-----+---------------+-------------+--------------------+------------------|
   |Back |a.back()       |!a.empty()   |Equivalent to       |                  |
   |     |               |             |*(--a.end()).       |                  |
   |-----+---------------+-------------+--------------------+------------------|
   |Push |a.push_back(t) |             |Equivalent to       |a.size is         |
   |back |               |             |a.insert(a.end(), t)|incremented by 1. |
   |     |               |             |                    |a.back() is a copy|
   |     |               |             |                    |of t.             |
   |-----+---------------+-------------+--------------------+------------------|
   |Pop  |a.pop_back()   |!a.empty()   |Equivalent to       |a.size() is       |
   |back |               |             |a.erase(--a.end())  |decremented by 1. |
   +---------------------------------------------------------------------------+

  Complexity guarantees

   Back, push back, and pop back are amortized constant time. [2][1]

  Invariants

   +------------------------------------------------------------------------+
   | Symmetry of push and pop | push_back() followed by pop_back() is a     |
   |                          | null operation.                             |
   +------------------------------------------------------------------------+

  Models

     * |stl-Vector|
     * |stl-List|
     * |stl-Deque|

  Notes

   [1] This complexity guarantee is the only reason that back(), push_back(),
   and pop_back() are defined: they provide no additional functionality. Not
   every sequence must define these operations, but it is guaranteed that
   they are efficient if they exist at all.

  See also

   |stl-Container|, |stl-Sequence|, |stl-FrontInsertionSequence|,
   |stl-Vector|, |stl-Deque|, |stl-List|


        ________________________________________________________________________
                                Associative Containers
*stl-AssociativeContainer*

                             Associative Container

   Category: containers                               Component type: concept

  Description

   An Associative Container is a variable-sized |stl-Container| that supports
   efficient retrieval of elements (values) based on keys. It supports
   insertion and removal of elements, but differs from a |stl-Sequence| in
   that it does not provide a mechanism for inserting an element at a
   specific position. [2][1]

   As with all containers, the elements in an Associative Container are of
   type value_type. Additionally, each element in an Associative Container
   has a key, of type key_type. In some Associative Containers,
   |stl-SimpleAssociativeContainer|, the value_type and key_type are the
   same: elements are their own keys. In others, the key is some specific
   part of the value. Since elements are stored according to their keys, it
   is essential that the key associated with each element is immutable. In
   |stl-SimpleAssociativeContainer| this means that the elements themselves
   are immutable, while in other types of Associative Containers, such as
   |stl-PairAssociativeContainer|, the elements themselves are mutable but
   the part of an element that is its key cannot be modified. This means that
   an Associative Container's value type is not |stl-Assignable|.

   The fact that the value type of an Associative Container is not
   |stl-Assignable| has an important consequence: associative containers
   cannot have mutable iterators. This is simply because a mutable iterator
   (as defined in the |stl-TrivialIterator| requirements) must allow assignment. That
   is, if i is a mutable iterator and t is an object of i's value type, then
   *i = t must be a valid expression.

   In |stl-SimpleAssociativeContainer|, where the elements are the keys, the
   elements are completely immutable; the nested types iterator and
   const_iterator are therefore the same. Other types of associative
   containers, however, do have mutable elements, and do provide iterators
   through which elements can be modified. |stl-PairAssociativeContainer|,
   for example, have two different nested types iterator and const_iterator.
   Even in this case, iterator is not a mutable iterator: as explained above,
   it does not provide the expression *i = t. It is, however, possible to
   modify an element through such an iterator: if, for example, i is of type
   |stl-Map|<int, double>, then (*i).second = 3 is a valid expression.

   In some associative containers, |stl-UniqueAssociativeContainer|, it is
   guaranteed that no two elements have the same key. [3][2] In other
   associative containers, |stl-MultipleAssociativeContainer|, multiple
   elements with the same key are permitted.

  Refinement of

   |stl-ForwardContainer|, |stl-DefaultConstructible|

  Associated types

   One new type is introduced, in addition to the types defined in the
   |stl-ForwardContainer| requirements.

   +------------------------------------------------------------------------+
   | Key type | X::key_type | The type of the key associated with           |
   |          |             | X::value_type. Note that the key type and     |
   |          |             | value type might be the same.                 |
   +------------------------------------------------------------------------+

  Notation

   X    A type that is a model of Associative Container
   a    Object of type X
   t    Object of type X::value_type
   k    Object of type X::key_type
   p, q Object of type X::iterator

  Definitions

   If a is an associative container, then p is a valid iterator in a if it is
   a valid iterator that is reachable from a.begin().

   If a is an associative container, then [p, q) is a valid range in a if [p,
   q) is a valid range and p is a valid iterator in a.

  Valid expressions

   In addition to the expressions defined in |stl-ForwardContainer|, the
   following expressions must be valid.

   +------------------------------------------------------------------------+
   |     Name     |    Expression    |     Type      |     Return type      |
   |              |                  | requirements  |                      |
   |--------------+------------------+---------------+----------------------|
   | Default      |X()               |               |                      |
   | constructor  |X a;              |               |                      |
   |--------------+------------------+---------------+----------------------|
   | Erase key    | a.erase(k)       |               | size_type            |
   |--------------+------------------+---------------+----------------------|
   | Erase        | a.erase(p)       |               | void                 |
   | element      |                  |               |                      |
   |--------------+------------------+---------------+----------------------|
   | Erase range  | a.erase(p, q)    |               | void                 |
   |--------------+------------------+---------------+----------------------|
   | Clear        | a.clear()        |               | void                 |
   |--------------+------------------+---------------+----------------------|
   | Find         | a.find(k)        |               | iterator if a is     |
   |              |                  |               | mutable, otherwise   |
   |              |                  |               | const_iterator       |
   |--------------+------------------+---------------+----------------------|
   | Count        | a.count(k)       |               | size_type            |
   |--------------+------------------+---------------+----------------------|
   | Equal range  | a.equal_range(k) |               | pair<iterator,       |
   |              |                  |               | iterator> if a is    |
   |              |                  |               | mutable, otherwise   |
   |              |                  |               | pair<const_iterator, |
   |              |                  |               | const_iterator>.     |
   +------------------------------------------------------------------------+

  Expression semantics

+-----------------------------------------------------------------------------------------+
|    Name     |   Expression    |  Precondition   |     Semantics      |  Postcondition   |
|-------------+-----------------+-----------------+--------------------+------------------|
|Default      |X()              |                 |Creates an empty    |The size of the   |
|constructor  |X a;             |                 |container.          |container is 0.   |
|-------------+-----------------+-----------------+--------------------+------------------|
|Erase key    |a.erase(k)       |                 |Destroys all        |a.size() is       |
|             |                 |                 |elements whose key  |decremented by    |
|             |                 |                 |is the same as k,   |a.count(k). a     |
|             |                 |                 |and removes them    |contains no       |
|             |                 |                 |from a. [4][2] The  |elements with key |
|             |                 |                 |return value is the |k.                |
|             |                 |                 |number of elements  |                  |
|             |                 |                 |that were erased,   |                  |
|             |                 |                 |i.e. the old value  |                  |
|             |                 |                 |of a.count(k).      |                  |
|-------------+-----------------+-----------------+--------------------+------------------|
|Erase element|a.erase(p)       |p is a           |Destroys the element|a.size() is       |
|             |                 |dereferenceable  |pointed to by p, and|decremented by 1. |
|             |                 |iterator in a.   |removes it from a.  |                  |
|-------------+-----------------+-----------------+--------------------+------------------|
|Erase range  |a.erase(p, q)    |[p, q) is a valid|Destroys the        |a.size() is       |
|             |                 |range in a.      |elements in the     |decremented by the|
|             |                 |                 |range [p,q) and     |distance from i to|
|             |                 |                 |removes them from a.|j.                |
|-------------+-----------------+-----------------+--------------------+------------------|
|Clear        |a.clear()        |                 |Equivalent to       |                  |
|             |                 |                 |a.erase(a.begin(),  |                  |
|             |                 |                 |a.end())            |                  |
|-------------+-----------------+-----------------+--------------------+------------------|
|Find         |a.find(k)        |                 |Returns an iterator |Either the return |
|             |                 |                 |pointing to an      |value is a.end(), |
|             |                 |                 |element whose key is|or else the return|
|             |                 |                 |the same as k, or   |value has a key   |
|             |                 |                 |a.end() if no such  |that is the same  |
|             |                 |                 |element exists.     |as k.             |
|-------------+-----------------+-----------------+--------------------+------------------|
|Count        |a.count(k)       |                 |Returns the number  |                  |
|             |                 |                 |of elements in a    |                  |
|             |                 |                 |whose keys are the  |                  |
|             |                 |                 |same as k.          |                  |
|-------------+-----------------+-----------------+--------------------+------------------|
|Equal range  |a.equal_range(k) |                 |Returns a pair P    |The distance      |
|             |                 |                 |such that [P.first, |between P.first   |
|             |                 |                 |P.second) is a range|and P.second is   |
|             |                 |                 |containing all      |equal to          |
|             |                 |                 |elements in a whose |a.count(k). If p  |
|             |                 |                 |keys are the same as|is a              |
|             |                 |                 |k. [5][3] If no     |dereferenceable   |
|             |                 |                 |elements have the   |iterator in a,    |
|             |                 |                 |same key as k, the  |then either p lies|
|             |                 |                 |return value is an  |in the range      |
|             |                 |                 |empty range.        |[P.first,         |
|             |                 |                 |                    |P.second), or else|
|             |                 |                 |                    |*p has a key that |
|             |                 |                 |                    |is not the same as|
|             |                 |                 |                    |k.                |
+-----------------------------------------------------------------------------------------+

  Complexity guarantees

   Average complexity for erase key is at most O(log(size()) + count(k)).

   Average complexity for erase element is constant time.

   Average complexity for erase range is at most O(log(size()) + N), where N
   is the number of elements in the range.

   Average complexity for count is at most O(log(size()) + count(k)).

   Average complexity for find is at most logarithmic.

   Average complexity for equal range is at most logarithmic.

  Invariants

   +------------------------------------------------------------------------+
   | Contiguous storage   | All elements with the same key are adjacent to  |
   |                      | each other. That is, if p and q are iterators   |
   |                      | that point to elements that have the same key,  |
   |                      | and if p precedes q, then every element in the  |
   |                      | range [p, q) has the same key as every other    |
   |                      | element.                                        |
   |----------------------+-------------------------------------------------|
   | Immutability of keys | Every element of an Associative Container has   |
   |                      | an immutable key. Objects may be inserted and   |
   |                      | erased, but an element in an Associative        |
   |                      | Container may not be modified in such a way as  |
   |                      | to change its key.                              |
   +------------------------------------------------------------------------+

  Models

     * |stl-set|
     * |stl-multiset|
     * |stl-hash_set|
     * |stl-hash_multiset|
     * |stl-Map|
     * |stl-Multimap|
     * |stl-hash_map|
     * |stl-hash_multimap|

  Notes

   [1] The reason there is no such mechanism is that the way in which
   elements are arranged in an associative container is typically a class
   invariant; elements in a |stl-SortedAssociativeContainer|, for example,
   are always stored in ascending order, and elements in a
   |stl-HashedAssociativeContainer| are always stored according to the hash
   function. It would make no sense to allow the position of an element to be
   chosen arbitrarily.

   [2] Keys are not required to be |stl-EqualityComparable|: associative
   containers do not necessarily use operator== to determine whether two keys
   are the same. In |stl-SortedAssociativeContainer|, for example, where keys
   are ordered by a comparison function, two keys are considered to be the
   same if neither one is less than the other.

   [3] Note the implications of this member function: it means that if two
   elements have the same key, there must be no elements with different keys
   in between them. The requirement that elements with the same key be stored
   contiguously is an associative container invariant.

  See also

   |stl-SimpleAssociativeContainer|, |stl-PairAssociativeContainer|,
   |stl-UniqueAssociativeContainer|, |stl-MultipleAssociativeContainer|,
   |stl-SortedAssociativeContainer|, |stl-UniqueSortedAssociativeContainer|,
   |stl-MultipleSortedAssociativeContainer|,
   |stl-HashedAssociativeContainer|, |stl-UniqueHashedAssociativeContainer|,
   |stl-MultipleHashedAssociativeContainer|.

*stl-SimpleAssociativeContainer*

                          Simple Associative Container

   Category: containers                               Component type: concept

  Description

   A Simple Associative Container is an |stl-AssociativeContainer| where
   elements are their own keys. A key in a Simple Associative Container is
   not associated with any additional value.

  Refinement of

   |stl-AssociativeContainer|

  Associated types

   None, except for those described in the |stl-AssociativeContainer|
   requirements. Simple Associative Container, however, introduces two new
   type restrictions.

   +------------------------------------------------------------------------+
   | Key type | X::key_type | The type of the key associated with           |
   |          |             | X::value_type. The types key_type and         |
   |          |             | value_type must be the same type.             |
   |----------+-------------+-----------------------------------------------|
   | Iterator | X::iterator | The type of iterator used to iterate through  |
   |          |             | a Simple Associative Container's elements.    |
   |          |             | The types X::iterator and X::const_iterator   |
   |          |             | must be the same type. That is, a Simple      |
   |          |             | Associative Container does not provide        |
   |          |             | mutable iterators. [2][1]                     |
   +------------------------------------------------------------------------+

  Notation

   X    A type that is a model of Simple Associative Container
   a    Object of type X
   k    Object of type X::key_type
   p, q Object of type X::iterator

  Definitions

  Valid expressions

   None, except for those defined in the |stl-AssociativeContainer|
   requirements.

  Expression semantics

  Complexity guarantees

  Invariants

   +------------------------------------------------------------------------+
   | Immutability of Elements | Every element of a Simple Associative       |
   |                          | Container is immutable. Objects may be      |
   |                          | inserted and erased, but not modified.      |
   |                          | [3][1]                                      |
   +------------------------------------------------------------------------+

  Models

     * |stl-set|
     * |stl-multiset|
     * |stl-hash_set|
     * |stl-hash_multiset|

  Notes

   [1] This is a consequence of the Immutability of Keys invariant of
   |stl-AssociativeContainer|. Keys may never be modified; values in a Simple
   Associative Container are themselves keys, so it immediately follows that
   values in a Simple Associative Container may not be modified.

  See also

   |stl-AssociativeContainer|, |stl-PairAssociativeContainer|

*stl-PairAssociativeContainer*

                           Pair Associative Container

   Category: containers                               Component type: concept

  Description

   A Pair Associative Container is an |stl-AssociativeContainer| that
   associates a key with some other object. The value type of a Pair
   Associative Container is |stl-pair|<const key_type, data_type>. [2][1]

  Refinement of

   |stl-AssociativeContainer|

  Associated types

   One new type is introduced, in addition to the types defined in the
   |stl-AssociativeContainer| requirements. Additionally, Pair Associative
   Container introduces one new type restriction

   +------------------------------------------------------------------------+
   | Key type   | X::key_type   | The type of the key associated with       |
   |            |               | X::value_type.                            |
   |------------+---------------+-------------------------------------------|
   | Data type  | X::data_type  | The type of the data associated with      |
   |            |               | X::value_type. A Pair Associative         |
   |            |               | Container can be thought of as a mapping  |
   |            |               | from key_type to data_type.               |
   |------------+---------------+-------------------------------------------|
   | Value type | X::value_type | The type of object stored in the          |
   |            |               | container. The value type is required to  |
   |            |               | be |stl-pair|<const key_type, data_type>. |
   +------------------------------------------------------------------------+

  Notation

   X    A type that is a model of Pair Associative Container
   a    Object of type X
   t    Object of type X::value_type
   d    Object of type X::data_type
   k    Object of type X::key_type
   p, q Object of type X::iterator

  Definitions

  Valid expressions

   None, except for those defined in the |stl-AssociativeContainer|
   requirements.

  Expression semantics

  Complexity guarantees

  Invariants

  Models

     * |stl-Map|
     * |stl-Multimap|
     * |stl-hash_map|
     * |stl-hash_multimap|

  Notes

   [1] The value type must be |stl-pair|<const key_type, data_type>, rather
   than |stl-pair|<key_type, data_type>, because of the
   |stl-AssociativeContainer| invariant of key immutability. The data_type
   part of an object in a Pair Associative Container may be modified, but the
   key_type part may not be. Note the implication of this fact: a Pair
   Associative Container cannot provide mutable iterators (as defined in the
   |stl-TrivialIterator| requirements), because the value type of a mutable iterator
   must be |stl-Assignable|, and |stl-pair|<const key_type, data_type> is not
   |stl-Assignable|. However, a Pair Associative Container can provide
   iterators that are not completely constant: iterators such that the
   expression (*i).second = d is valid.

  See also

   |stl-AssociativeContainer|, |stl-SimpleAssociativeContainer|

*stl-SortedAssociativeContainer*

                          Sorted Associative Container

   Category: containers                               Component type: concept

  Description

   A Sorted Associative Container is a type of |stl-AssociativeContainer|.
   Sorted Associative Containers use an ordering relation on their keys; two
   keys are considered to be equivalent if neither one is less than the
   other. (If the ordering relation is case-insensitive string comparison,
   for example, then the keys "abcde" and "aBcDe" are equivalent.)

   Sorted Associative Containers guarantee that the complexity for most
   operations is never worse than logarithmic [2][1], and they also guarantee
   that their elements are always sorted in ascending order by key.

  Refinement of

   |stl-ReversibleContainer|, |stl-AssociativeContainer|

  Associated types

   Two new types are introduced, in addition to the types defined in the
   |stl-AssociativeContainer| and |stl-ReversibleContainer| requirements.

   +------------------------------------------------------------------------+
   | X::key_compare   | The type of a |stl-StrictWeakOrdering| used to      |
   |                  | compare keys. Its argument type must be             |
   |                  | X::key_type.                                        |
   |------------------+-----------------------------------------------------|
   | X::value_compare | The type of a |stl-StrictWeakOrdering| used to      |
   |                  | compare values. Its argument type must be           |
   |                  | X::value_type, and it compares two objects of       |
   |                  | value_type by passing the keys associated with      |
   |                  | those objects to a function object of type          |
   |                  | key_compare.                                        |
   +------------------------------------------------------------------------+

  Notation

   X    A type that is a model of Sorted Associative Container
   a    Object of type X
   t    Object of type X::value_type
   k    Object of type X::key_type
   p, q Object of type X::iterator
   c    Object of type X::key_compare

  Definitions

  Valid expressions

   In addition to the expressions defined in |stl-AssociativeContainer| and
   |stl-ReversibleContainer|, the following expressions must be valid.

   +------------------------------------------------------------------------+
   |    Name     |     Expression     |     Type     |     Return type      |
   |             |                    | requirements |                      |
   |-------------+--------------------+--------------+----------------------|
   | Default     |X()                 |              |                      |
   | constructor |X a;                |              |                      |
   |-------------+--------------------+--------------+----------------------|
   | Constructor |X(c)                |              |                      |
   | with        |X a(c);             |              |                      |
   | compare     |                    |              |                      |
   |-------------+--------------------+--------------+----------------------|
   | Key         | a.key_comp()       |              | X::key_compare       |
   | comparison  |                    |              |                      |
   |-------------+--------------------+--------------+----------------------|
   | Value       | a::value_compare() |              | X::value_compare     |
   | comparison  |                    |              |                      |
   |-------------+--------------------+--------------+----------------------|
   | Lower bound | a.lower_bound(k)   |              | iterator if a is     |
   |             |                    |              | mutable, otherwise   |
   |             |                    |              | const_iterator.      |
   |-------------+--------------------+--------------+----------------------|
   | Upper bound | a.upper_bound(k)   |              | iterator if a is     |
   |             |                    |              | mutable, otherwise   |
   |             |                    |              | const_iterator.      |
   |-------------+--------------------+--------------+----------------------|
   | Equal range | a.equal_range(k)   |              | pair<iterator,       |
   |             |                    |              | iterator> if a is    |
   |             |                    |              | mutable, otherwise   |
   |             |                    |              | pair<const_iterator, |
   |             |                    |              | const_iterator>.     |
   +------------------------------------------------------------------------+

  Expression semantics

+------------------------------------------------------------------------------------------+
|    Name     |    Expression     |Precondition |     Semantics     |    Postcondition     |
|-------------+-------------------+-------------+-------------------+----------------------|
|Default      |X()                |             |Creates an empty   |The size of the       |
|constructor  |X a;               |             |container, using   |container is 0.       |
|             |                   |             |key_compare() as   |                      |
|             |                   |             |the comparison     |                      |
|             |                   |             |object.            |                      |
|-------------+-------------------+-------------+-------------------+----------------------|
|Constructor  |X(c)               |             |Creates an empty   |The size of the       |
|with compare |X a(c);            |             |container, using c |container is 0.       |
|             |                   |             |as the comparison  |key_comp() returns a  |
|             |                   |             |object.            |function object that  |
|             |                   |             |                   |is equivalent to c.   |
|-------------+-------------------+-------------+-------------------+----------------------|
|Key          |a.key_comp()       |             |Returns the key    |                      |
|comparison   |                   |             |comparison object  |                      |
|             |                   |             |used by a.         |                      |
|-------------+-------------------+-------------+-------------------+----------------------|
|Value        |a::value_compare() |             |Returns the value  |If t1 and t2 are      |
|comparison   |                   |             |comparison object  |objects of type       |
|             |                   |             |used by a.         |value_type, and k1 and|
|             |                   |             |                   |k2 are the keys       |
|             |                   |             |                   |associated with them, |
|             |                   |             |                   |then                  |
|             |                   |             |                   |a.value_comp()(t1, t2)|
|             |                   |             |                   |is equivalent to      |
|             |                   |             |                   |a.key_comp()(k1, k2). |
|-------------+-------------------+-------------+-------------------+----------------------|
|Lower bound  |a.lower_bound(k)   |             |Returns an iterator|If a contains any     |
|             |                   |             |pointing to the    |elements that have the|
|             |                   |             |first element whose|same key as k, then   |
|             |                   |             |key is not less    |the return value of   |
|             |                   |             |than k. Returns    |lower_bound points to |
|             |                   |             |a.end() if no such |the first such        |
|             |                   |             |element exists.    |element.              |
|-------------+-------------------+-------------+-------------------+----------------------|
|Upper bound  |a.upper_bound(k)   |             |Returns an iterator|If a contains any     |
|             |                   |             |pointing to the    |elements that have the|
|             |                   |             |first element whose|same key as k, then   |
|             |                   |             |key is greater than|the return value of   |
|             |                   |             |k. Returns a.end() |upper_bound points to |
|             |                   |             |if no such element |one past the last such|
|             |                   |             |exists.            |element.              |
|-------------+-------------------+-------------+-------------------+----------------------|
|Equal range  |a.equal_range(k)   |             |Returns a pair     |                      |
|             |                   |             |whose first element|                      |
|             |                   |             |is a.lower_bound(k)|                      |
|             |                   |             |and whose second   |                      |
|             |                   |             |element is         |                      |
|             |                   |             |a.upper_bound(k).  |                      |
+------------------------------------------------------------------------------------------+

  Complexity guarantees

   key_comp() and value_comp() are constant time.

   Erase element is constant time.

   Erase key is O(log(size()) + count(k)). [3][1]

   Erase range is O(log(size()) + N), where N is the length of the range.
   [4][1]

   Find is logarithmic. [5][1]

   Count is O(log(size()) + count(k)). [6][1]

   Lower bound, upper bound, and equal range are logarithmic. [7][1]

  Invariants

   +------------------------------------------------------------------------+
   | Definition of    | If t1 and t2 are objects of type X::value_type and  |
   | value_comp       | k1 and k2 are the keys associated with those        |
   |                  | objects, then a.value_comp() returns a              |
   |                  | |stl-functors| such that a.value_comp()(t1, t2) is  |
   |                  | equivalent to a.key_comp()(k1, k2).                 |
   |------------------+-----------------------------------------------------|
   | Ascending order  | The elements in a Sorted Associative Container are  |
   |                  | always arranged in ascending order by key. That is, |
   |                  | if a is a Sorted Associative Container, then        |
   |                  | |stl-is_sorted|(a.begin(), a.end(), a.value_comp()) |
   |                  | is always true.                                     |
   +------------------------------------------------------------------------+

  Models

     * |stl-set|
     * |stl-multiset|
     * |stl-Map|
     * |stl-Multimap|

  Notes

   [1] This is a much stronger guarantee than the one provided by
   |stl-AssociativeContainer|. The guarantees in |stl-AssociativeContainer|
   only apply to average complexity; worst case complexity is allowed to be
   greater. Sorted Associative Container, however, provides an upper limit on
   worst case complexity.

   [2] This definition is consistent with the semantics described in
   |stl-AssociativeContainer|. It is a stronger condition, though: if a
   contains no elements with the key k, then a.equal_range(k) returns an
   empty range that indicates the position where those elements would be if
   they did exist. The |stl-AssociativeContainer| requirements, however,
   merely state that the return value is an arbitrary empty range.

  See also

   |stl-AssociativeContainer|, |stl-HashedAssociativeContainer|

*stl-HashedAssociativeContainer*

                          Hashed Associative Container

   Category: containers                               Component type: concept

  Description

   A Hashed Associative Container is an |stl-AssociativeContainer| whose
   implementation is a hash table. [2][1] The elements of a Hashed
   Associative Container are not guaranteed to be in any meaningful order; in
   particular, they are not sorted. The worst case complexity of most
   operations on Hashed Associative Containers is linear in the size of the
   container, but the average case complexity is constant time; this means
   that for applications where values are simply stored and retrieved, and
   where ordering is unimportant, Hashed Associative Containers are usually
   much faster than |stl-Sorted-Associative-Containers|.

  Refinement of

   |stl-AssociativeContainer|

  Associated types

   The following new types are introduced, in addition to the types defined
   in the |stl-AssociativeContainer| requirements.

   +------------------------------------------------------------------------+
   | Hash function | X::hasher    | A type that is a model of               |
   |               |              | |stl-HashFunction|. X::hasher's         |
   |               |              | argument type must be X::key_type.      |
   |---------------+--------------+-----------------------------------------|
   | Key equal     | X::key_equal | A |stl-BinaryPredicate| whose argument  |
   |               |              | type is X::key_type. An object of type  |
   |               |              | key_equal returns true if its arguments |
   |               |              | are the same key, and false otherwise.  |
   |               |              | X::key_equal must be an equivalence     |
   |               |              | relation.                               |
   +------------------------------------------------------------------------+

  Notation

   X    A type that is a model of Hashed Associative Container
   a    Object of type X
   t    Object of type X::value_type
   k    Object of type X::key_type
   p, q Object of type X::iterator
   n    Object of type X::size_type
   h    Object of type X::hasher
   c    Object of type X::key_equal

  Definitions

   A hash function for a Hashed Associative Container X is a
   |stl-UnaryFunction| whose argument type is X::key_type and whose return
   type is size_t. A hash function must be deterministic (that is, it must
   always return the same value whenever it is called with the same
   argument), but return values of the hash function should be as uniform as
   possible: ideally, no two keys will hash to the same value. [4][2]

   Elements in a Hashed Associative Container are organized into buckets. A
   Hashed Associative Container uses the value of the hash function to
   determine which bucket an element is assigned to.

   The number of elements in a Hashed Associative Container divided by the
   number of buckets is called the load factor. A Hashed Associative
   Container with a small load factor is faster than one with a large load
   factor.

  Valid expressions

   In addition to the expressions defined in |stl-AssociativeContainer|, the
   following expressions must be valid.

   +------------------------------------------------------------------------+
   |     Name     |    Expression    |     Type      |     Return type      |
   |              |                  | requirements  |                      |
   |--------------+------------------+---------------+----------------------|
   | Default      |X()               |               |                      |
   | constructor  |X a;              |               |                      |
   |--------------+------------------+---------------+----------------------|
   | Constructor  |X(n)              |               |                      |
   | with bucket  |X a(n);           |               |                      |
   | count        |                  |               |                      |
   |--------------+------------------+---------------+----------------------|
   | Constructor  |X(n, h)           |               |                      |
   | with hash    |X a(n, h);        |               |                      |
   | function     |                  |               |                      |
   |--------------+------------------+---------------+----------------------|
   | Constructor  |X(n, h, k)        |               |                      |
   | with key     |X a(n, h, k);     |               |                      |
   | equal        |                  |               |                      |
   |--------------+------------------+---------------+----------------------|
   | Hash         | a.hash_funct()   |               | X::hasher            |
   | function     |                  |               |                      |
   |--------------+------------------+---------------+----------------------|
   | Key equal    | a.key_eq()       |               | X::key_equal         |
   |--------------+------------------+---------------+----------------------|
   | Erase key    | a.erase(k)       |               | size_type            |
   |--------------+------------------+---------------+----------------------|
   | Erase        | a.erase(p)       |               | void                 |
   | element      |                  |               |                      |
   |--------------+------------------+---------------+----------------------|
   | Erase range  | a.erase(p, q)    |               | void                 |
   |--------------+------------------+---------------+----------------------|
   | Find         | a.find(k)        |               | iterator if a is     |
   |              |                  |               | mutable, otherwise   |
   |              |                  |               | const_iterator       |
   |--------------+------------------+---------------+----------------------|
   | Count        | a.count(k)       |               | size_type            |
   |--------------+------------------+---------------+----------------------|
   | Equal range  | a.equal_range(k) |               | pair<iterator,       |
   |              |                  |               | iterator> if a is    |
   |              |                  |               | mutable, otherwise   |
   |              |                  |               | pair<const_iterator, |
   |              |                  |               | const_iterator>.     |
   |--------------+------------------+---------------+----------------------|
   | Bucket count | a.bucket_count() |               | X::size_type         |
   |--------------+------------------+---------------+----------------------|
   | Resize       | a.resize(n)      |               | void                 |
   +------------------------------------------------------------------------+

  Expression semantics

+----------------------------------------------------------------------------------+
|    Name     |   Expression    |  Precondition   |  Semantics  |  Postcondition   |
|-------------+-----------------+-----------------+-------------+------------------|
|Default      |X()              |                 |Creates an   |The size of the   |
|constructor  |X a;             |                 |empty        |container is 0.   |
|             |                 |                 |container,   |The bucket count  |
|             |                 |                 |using        |is an unspecified |
|             |                 |                 |hasher() as  |default value. The|
|             |                 |                 |the hash     |hash function is  |
|             |                 |                 |function and |hasher(), and the |
|             |                 |                 |key_equal()  |key equality      |
|             |                 |                 |as the key   |function is       |
|             |                 |                 |equality     |key_equal().      |
|             |                 |                 |function.    |                  |
|-------------+-----------------+-----------------+-------------+------------------|
|Constructor  |X(n)             |                 |Creates an   |The size of the   |
|with bucket  |X a(n);          |                 |empty        |container is 0.   |
|count        |                 |                 |container    |The bucket count  |
|             |                 |                 |with at least|is greater than or|
|             |                 |                 |n buckets,   |equal to n. The   |
|             |                 |                 |using        |hash function is  |
|             |                 |                 |hasher() as  |hasher(), and the |
|             |                 |                 |the hash     |key equality      |
|             |                 |                 |function and |function is       |
|             |                 |                 |key_equal()  |key_equal().      |
|             |                 |                 |as the key   |                  |
|             |                 |                 |equality     |                  |
|             |                 |                 |function.    |                  |
|-------------+-----------------+-----------------+-------------+------------------|
|Constructor  |X(n, h)          |                 |Creates an   |The size of the   |
|with hash    |X a(n, h);       |                 |empty        |container is 0.   |
|function     |                 |                 |container    |The bucket count  |
|             |                 |                 |with at least|is greater than or|
|             |                 |                 |n buckets,   |equal to n. The   |
|             |                 |                 |using h as   |hash function is  |
|             |                 |                 |the hash     |h, and the key    |
|             |                 |                 |function and |equality function |
|             |                 |                 |key_equal()  |is key_equal().   |
|             |                 |                 |as the key   |                  |
|             |                 |                 |equality     |                  |
|             |                 |                 |function.    |                  |
|-------------+-----------------+-----------------+-------------+------------------|
|Constructor  |X(n, h, k)       |                 |Creates an   |The size of the   |
|with key     |X a(n, h, k);    |                 |empty        |container is 0.   |
|equal        |                 |                 |container    |The bucket count  |
|             |                 |                 |with at least|is greater than or|
|             |                 |                 |n buckets,   |equal to n. The   |
|             |                 |                 |using h as   |hash function is  |
|             |                 |                 |the hash     |h, and the key    |
|             |                 |                 |function and |equality function |
|             |                 |                 |k as the key |is k.             |
|             |                 |                 |equality     |                  |
|             |                 |                 |function.    |                  |
|-------------+-----------------+-----------------+-------------+------------------|
|Hash function|a.hash_funct()   |                 |Returns the  |                  |
|             |                 |                 |hash function|                  |
|             |                 |                 |used by a.   |                  |
|-------------+-----------------+-----------------+-------------+------------------|
|Key equal    |a.key_eq()       |                 |Returns the  |                  |
|             |                 |                 |key equal    |                  |
|             |                 |                 |function used|                  |
|             |                 |                 |by a.        |                  |
|-------------+-----------------+-----------------+-------------+------------------|
|Erase key    |a.erase(k)       |                 |Destroys all |a.size() is       |
|             |                 |                 |elements     |decremented by    |
|             |                 |                 |whose key is |a.count(k). a     |
|             |                 |                 |the same as  |contains no       |
|             |                 |                 |k, and       |elements with key |
|             |                 |                 |removes them |k.                |
|             |                 |                 |from a.      |                  |
|             |                 |                 |[5][2] The   |                  |
|             |                 |                 |return value |                  |
|             |                 |                 |is the number|                  |
|             |                 |                 |of elements  |                  |
|             |                 |                 |that were    |                  |
|             |                 |                 |erased, i.e. |                  |
|             |                 |                 |the old value|                  |
|             |                 |                 |of           |                  |
|             |                 |                 |a.count(k).  |                  |
|-------------+-----------------+-----------------+-------------+------------------|
|Erase element|a.erase(p)       |p is a           |Destroys the |a.size() is       |
|             |                 |dereferenceable  |element      |decremented by 1. |
|             |                 |iterator in a.   |pointed to by|                  |
|             |                 |                 |p, and       |                  |
|             |                 |                 |removes it   |                  |
|             |                 |                 |from a.      |                  |
|-------------+-----------------+-----------------+-------------+------------------|
|Erase range  |a.erase(p, q)    |[p, q) is a valid|Destroys the |a.size() is       |
|             |                 |range in a.      |elements in  |decremented by the|
|             |                 |                 |the range    |distance from i to|
|             |                 |                 |[p,q) and    |j.                |
|             |                 |                 |removes them |                  |
|             |                 |                 |from a.      |                  |
|-------------+-----------------+-----------------+-------------+------------------|
|Find         |a.find(k)        |                 |Returns an   |Either the return |
|             |                 |                 |iterator     |value is a.end(), |
|             |                 |                 |pointing to  |or else the return|
|             |                 |                 |an element   |value has a key   |
|             |                 |                 |whose key is |that is the same  |
|             |                 |                 |the same as  |as k.             |
|             |                 |                 |k, or a.end()|                  |
|             |                 |                 |if no such   |                  |
|             |                 |                 |element      |                  |
|             |                 |                 |exists.      |                  |
|-------------+-----------------+-----------------+-------------+------------------|
|Count        |a.count(k)       |                 |Returns the  |                  |
|             |                 |                 |number of    |                  |
|             |                 |                 |elements in a|                  |
|             |                 |                 |whose keys   |                  |
|             |                 |                 |are the same |                  |
|             |                 |                 |as k.        |                  |
|-------------+-----------------+-----------------+-------------+------------------|
|Equal range  |a.equal_range(k) |                 |Returns a    |The distance      |
|             |                 |                 |pair P such  |between P.first   |
|             |                 |                 |that         |and P.second is   |
|             |                 |                 |[P.first,    |equal to          |
|             |                 |                 |P.second) is |a.count(k). If p  |
|             |                 |                 |a range      |is a              |
|             |                 |                 |containing   |dereferenceable   |
|             |                 |                 |all elements |iterator in a,    |
|             |                 |                 |in a whose   |then either a lies|
|             |                 |                 |keys are the |in the range      |
|             |                 |                 |same as k.   |[P.first,         |
|             |                 |                 |[6][3] If no |P.second), or else|
|             |                 |                 |elements have|*a has a key that |
|             |                 |                 |the same key |is not the same as|
|             |                 |                 |as k, the    |k.                |
|             |                 |                 |return value |                  |
|             |                 |                 |is an empty  |                  |
|             |                 |                 |range.       |                  |
|-------------+-----------------+-----------------+-------------+------------------|
|Bucket count |a.bucket_count() |                 |Returns the  |                  |
|             |                 |                 |number of    |                  |
|             |                 |                 |buckets in a.|                  |
|-------------+-----------------+-----------------+-------------+------------------|
|Resize       |a.resize(n)      |                 |Increases the|The bucket count  |
|             |                 |                 |bucket count |of a will be at   |
|             |                 |                 |of a.        |least n. All      |
|             |                 |                 |             |iterators pointing|
|             |                 |                 |             |to element in a   |
|             |                 |                 |             |will remain valid.|
|             |                 |                 |             |[7][3]            |
+----------------------------------------------------------------------------------+

  Complexity guarantees

   The default constructor, constructor with bucket count, constructor with
   hash function, and constructor with key equal, are all amortized constant
   time.

   Hash Function and Key Equal are amortized constant time.

   Average complexity for Erase Key is O(count(k)). Worst case is linear in
   the size of the container.

   Erase Element is amortized constant time.

   Average complexity for Erase Range is O(N), where N is the length of the
   range being erased. Worse case is linear in the size of the container.

   Average complexity for Find is constant time. Worst case is linear in the
   size of the container.

   Average complexity for Equal Range is O(count(k)). Worst case is linear in
   the size of the container.

   Average complexity for Count is O(count(k)). Worst case is linear in the
   size of the container.

   Bucket Count is amortized constant time.

   Resize is linear in the size of the container.

  Invariants

  Models

     * |stl-hash_set|
     * |stl-hash_map|
     * |stl-hash_multiset|
     * |stl-hash_multimap|

  Notes

   [1] There is an extensive literature dealing with hash tables. See, for
   example, section 6.4 of Knuth. (D. E. Knuth, The Art of Computer
   Programming. Volume 3: Sorting and Searching. Addison-Wesley, 1975.)

   [2] If the hash function is poor (that is, if many different keys hash to
   the same value) then this will hurt performance. The worst case is where
   every key hashes to the same value; in this case, run-time complexity of
   most Hashed Associative Container operations will be linear in the size of
   the container.

   [3] Resizing does not invalidate iterators; however, it does not
   necessarily preserve the ordering relation between iterators. That is, if
   i and j are iterators that point into a Hashed Associative Container such
   that i comes immediately before j, then there is no guarantee that i will
   still come immediately before j after the container is resized. The only
   guarantee about about the ordering of elements is the contiguous storage
   invariant: elements with the same key are always adjacent to each other.

  See also

   |stl-AssociativeContainer|, |stl-SortedAssociativeContainer|,
   |stl-UniqueHashedAssociativeContainer|,
   |stl-MultipleHashedAssociativeContainer|,

*stl-HashFunction*

                                 Hash Function

   Categories: containers, functors                   Component type: concept

  Description

   A Hash Function is a |stl-UnaryFunction| that is used by
   |stl-HashedAssociativeContainer|: it maps its argument to a result of type
   size_t. A Hash Function must be deterministic and stateless. That is, the
   return value must depend only on the argument, and equal arguments must
   yield equal results.

   The performance of a |stl-HashedAssociativeContainer| depends crucially on
   its hash function. It is important for a Hash Function to minimize
   collisions, where a collision is defined as two different arguments that
   hash to the same value. It is also important that the distribution of hash
   values be uniform; that is, the probability that a Hash Function returns
   any particular value of type size_t should be roughly the same as the
   probability that it returns any other value. [2][1]

  Refinement of

   |stl-UnaryFunction|

  Associated types

   +------------------------------------------------------------------------+
   | Result type | The type returned when the Hash Function is called. The  |
   |             | result type must be size_t.                              |
   +------------------------------------------------------------------------+

  Notation

  Definitions

  Valid expressions

   None, except for those described in the |stl-UnaryFunction| requirements.

  Expression semantics

  Complexity guarantees

  Invariants

   +------------------------------------------------------------------------+
   | Deterministic function | The return value depends only on the          |
   |                        | argument, as opposed to the past history of   |
   |                        | the Hash Function object. The return value is |
   |                        | always the same whenever the argument is the  |
   |                        | same.                                         |
   +------------------------------------------------------------------------+

  Models

     * |stl-hash|

  Notes

   [1] Note that both of these requirements make sense only in the context of
   some specific distribution of input values. To take a simple example,
   suppose that the values being hashed are the six strings "aardvark",
   "trombone", "history", "diamond", "forthright", and "solitude". In this
   case, one reasonable (and efficient) hash function would simply be the
   first character of each string. On the other hand, suppose that the values
   being hashed are "aaa0001", "aaa0010", "aaa0011", "aaa0100", "aaa0101",
   and "aaa0110". In that case, a different hash function would be more
   appropriate. This is why |stl-HashedAssociativeContainer| are
   parameterized by the hash function: no one hash function is best for all
   applications.

  See also

   |stl-HashedAssociativeContainer|, |stl-hash|

*stl-UniqueAssociativeContainer*

                          Unique Associative Container

   Category: containers                               Component type: concept

  Description

   A Unique Associative Container is an |stl-AssociativeContainer| with the
   property that each key in the container is unique: no two elements in a
   Unique Associative Container have the same key.

  Refinement of

   |stl-AssociativeContainer|

  Associated types

   None, except for those defined by |stl-AssociativeContainer|.

  Notation

   X    A type that is a model of Unique Associative Container
   a    Object of type X
   t    Object of type X::value_type
   k    Object of type X::key_type
   p, q Object of type X::iterator

  Definitions

  Valid expressions

   In addition to the expressions defined in |stl-AssociativeContainer|, the
   following expressions must be valid.

   +---------------------------------------------------------------------------+
   |    Name     | Expression |   Type requirements    |      Return type      |
   |-------------+------------+------------------------+-----------------------|
   |Range        |X(i, j)     |i and j are             |                       |
   |constructor  |X a(i, j);  ||stl-InputIterator|     |                       |
   |             |            |whose value type is     |                       |
   |             |            |convertible to T [2][1] |                       |
   |-------------+------------+------------------------+-----------------------|
   |Insert       |a.insert(t) |                        ||stl-pair|<X::iterator,|
   |element      |            |                        |bool>                  |
   |-------------+------------+------------------------+-----------------------|
   |Insert range |a.insert(i, |i and j are             |void                   |
   |             |j)          ||stl-InputIterator|     |                       |
   |             |            |whose value type is     |                       |
   |             |            |convertible to          |                       |
   |             |            |X::value_type. [3][1]   |                       |
   |-------------+------------+------------------------+-----------------------|
   |Count        |a.count(k)  |                        |size_type              |
   +---------------------------------------------------------------------------+

  Expression semantics

   +--------------------------------------------------------------------------+
   |    Name     | Expression |Precondition |   Semantics   |  Postcondition  |
   |-------------+------------+-------------+---------------+-----------------|
   |Range        |X(i, j)     |[i,j) is a   |Creates an     |size() is less   |
   |constructor  |X a(i, j);  |valid range. |associative    |than or equal to |
   |             |            |             |container that |the distance from|
   |             |            |             |contains all of|i to j.          |
   |             |            |             |the elements in|                 |
   |             |            |             |the range [i,j)|                 |
   |             |            |             |that have      |                 |
   |             |            |             |unique keys.   |                 |
   |-------------+------------+-------------+---------------+-----------------|
   |Insert       |a.insert(t) |             |Inserts t into |P.first is a     |
   |element      |            |             |a if and only  |dereferenceable  |
   |             |            |             |if a does not  |iterator.        |
   |             |            |             |already contain|*(P.first) has   |
   |             |            |             |an element     |the same key as  |
   |             |            |             |whose key is   |t. The size of a |
   |             |            |             |the same as the|is incremented by|
   |             |            |             |key of t. The  |1 if and only if |
   |             |            |             |return value is|P.second is true.|
   |             |            |             |a |stl-pair| P.|                 |
   |             |            |             |P.first is an  |                 |
   |             |            |             |iterator       |                 |
   |             |            |             |pointing to the|                 |
   |             |            |             |element whose  |                 |
   |             |            |             |key is the same|                 |
   |             |            |             |as the key of  |                 |
   |             |            |             |t. P.second is |                 |
   |             |            |             |a bool: it is  |                 |
   |             |            |             |true if t was  |                 |
   |             |            |             |actually       |                 |
   |             |            |             |inserted into  |                 |
   |             |            |             |a, and false if|                 |
   |             |            |             |t was not      |                 |
   |             |            |             |inserted into  |                 |
   |             |            |             |a, i.e. if a   |                 |
   |             |            |             |already        |                 |
   |             |            |             |contained an   |                 |
   |             |            |             |element with   |                 |
   |             |            |             |the same key as|                 |
   |             |            |             |t.             |                 |
   |-------------+------------+-------------+---------------+-----------------|
   |Insert range |a.insert(i, |[i, j) is a  |Equivalent to  |The size of a is |
   |             |j)          |valid range. |a.insert(t) for|incremented by at|
   |             |            |             |each object t  |most j - i.      |
   |             |            |             |that is pointed|                 |
   |             |            |             |to by an       |                 |
   |             |            |             |iterator in the|                 |
   |             |            |             |range [i, j).  |                 |
   |             |            |             |Each element is|                 |
   |             |            |             |inserted into a|                 |
   |             |            |             |if and only if |                 |
   |             |            |             |a does not     |                 |
   |             |            |             |already contain|                 |
   |             |            |             |an element with|                 |
   |             |            |             |the same key.  |                 |
   |-------------+------------+-------------+---------------+-----------------|
   |Count        |a.count(k)  |             |Returns the    |The return value |
   |             |            |             |number of      |is either 0 or 1.|
   |             |            |             |elements in a  |                 |
   |             |            |             |whose keys are |                 |
   |             |            |             |the same as k. |                 |
   +--------------------------------------------------------------------------+

  Complexity guarantees

   Average complexity for insert element is at most logarithmic.

   Average complexity for insert range is at most O(N * log(size() + N)),
   where N is j - i.

  Invariants

   +------------------------------------------------------------------------+
   | Uniqueness | No two elements have the same key. Equivalently, this     |
   |            | means that for every object k of type key_type,           |
   |            | a.count(k) returns either 0 or 1.                         |
   +------------------------------------------------------------------------+

  Models

     * |stl-set|
     * |stl-Map|
     * |stl-hash_set|
     * |stl-hash_map|

  Notes

   [1] At present (early 1998), not all compilers support "member templates".
   If your compiler supports member templates then i and j may be of any type
   that conforms to the |stl-InputIterator| requirements. If your compiler
   does not yet support member templates, however, then i and j must be of
   type const T* or of type X::const_iterator.

  See also

   |stl-AssociativeContainer|, |stl-MultipleAssociativeContainer|,
   |stl-UniqueSortedAssociativeContainer|,
   |stl-MultipleSortedAssociativeContainer|

*stl-MultipleAssociativeContainer*

                         Multiple Associative Container

   Category: containers                               Component type: concept

  Description

   A Multiple Associative Container is an |stl-AssociativeContainer| in which
   there may be more than one element with the same key. That is, it is an
   |stl-AssociativeContainer| that does not have the restrictions of a
   |stl-UniqueAssociativeContainer|.

  Refinement of

   |stl-AssociativeContainer|

  Associated types

   None, except for those defined by |stl-AssociativeContainer|

  Notation

   X    A type that is a model of Multiple Associative Container
   a    Object of type X
   t    Object of type X::value_type
   k    Object of type X::key_type
   p, q Object of type X::iterator

  Definitions

  Valid expressions

   In addition to the expressions defined in |stl-AssociativeContainer|, the
   following expressions must be valid.

   +------------------------------------------------------------------------+
   |      Name      |  Expression  |    Type requirements     | Return type |
   |----------------+--------------+--------------------------+-------------|
   | Range          |X(i, j)       | i and j are              |             |
   | constructor    |X a(i, j);    | |stl-InputIterator|      |             |
   |                |              | whose value type is      |             |
   |                |              | convertible to T [2][1]  |             |
   |----------------+--------------+--------------------------+-------------|
   | Insert element | a.insert(t)  |                          | X::iterator |
   |----------------+--------------+--------------------------+-------------|
   | Insert range   | a.insert(i,  | i and j are              | void        |
   |                | j)           | |stl-InputIterator|      |             |
   |                |              | whose value type is      |             |
   |                |              | convertible to           |             |
   |                |              | X::value_type.           |             |
   +------------------------------------------------------------------------+

  Expression semantics

   +------------------------------------------------------------------------+
   |    Name     | Expression  | Precondition |  Semantics  | Postcondition |
   |-------------+-------------+--------------+-------------+---------------|
   | Range       |X(i, j)      | [i,j) is a   | Creates an  | size() is     |
   | constructor |X a(i, j);   | valid range. | associative | equal to the  |
   |             |             |              | container   | distance from |
   |             |             |              | that        | i to j. Each  |
   |             |             |              | contains    | element in    |
   |             |             |              | all         | [i, j) is     |
   |             |             |              | elements in | present in    |
   |             |             |              | the range   | the           |
   |             |             |              | [i,j).      | container.    |
   |-------------+-------------+--------------+-------------+---------------|
   | Insert      | a.insert(t) |              | Inserts t   | The size of a |
   | element     |             |              | into a.     | is            |
   |             |             |              |             | incremented   |
   |             |             |              |             | by 1. The     |
   |             |             |              |             | value of      |
   |             |             |              |             | a.count(t) is |
   |             |             |              |             | incremented   |
   |             |             |              |             | by a.         |
   |-------------+-------------+--------------+-------------+---------------|
   | Insert      | a.insert(i, | [i, j) is a  | Equivalent  | The size of a |
   | range       | j)          | valid range. | to          | is            |
   |             |             |              | a.insert(t) | incremented   |
   |             |             |              | for each    | by j - i.     |
   |             |             |              | object t    |               |
   |             |             |              | that is     |               |
   |             |             |              | pointed to  |               |
   |             |             |              | by an       |               |
   |             |             |              | iterator in |               |
   |             |             |              | the range   |               |
   |             |             |              | [i, j).     |               |
   |             |             |              | Each        |               |
   |             |             |              | element is  |               |
   |             |             |              | inserted    |               |
   |             |             |              | into a.     |               |
   +------------------------------------------------------------------------+

  Complexity guarantees

   Average complexity for insert element is at most logarithmic.

   Average complexity for insert range is at most O(N * log(size() + N)),
   where N is j - i.

  Invariants

  Models

     * |stl-multiset|
     * |stl-Multimap|
     * |stl-hash_multiset|
     * |stl-hash_multimap|

  Notes

   [1] At present (early 1998), not all compilers support "member templates".
   If your compiler supports member templates then i and j may be of any type
   that conforms to the |stl-InputIterator| requirements. If your compiler
   does not yet support member templates, however, then i and j must be of
   type const T* or of type X::const_iterator.

  See also

   |stl-AssociativeContainer|, |stl-UniqueAssociativeContainer|,
   |stl-UniqueSortedAssociativeContainer|,
   |stl-MultipleSortedAssociativeContainer|

*stl-UniqueSortedAssociativeContainer*

                      Unique Sorted Associative Container

   Category: containers                               Component type: concept

  Description

   A Unique Sorted Associative Container is a |stl-Sorted-Associative-Container|
   that is also a |stl-UniqueAssociativeContainer|. That is, it is a
   |stl-SortedAssociativeContainer| with the property that no two elements in
   the container have the same key.

  Refinement of

   |stl-SortedAssociativeContainer|, |stl-UniqueAssociativeContainer|

  Associated types

   None, except for those described in the |stl-SortedAssociativeContainer|
   and |stl-UniqueAssociativeContainer| requirements.

  Notation

   X    A type that is a model of Unique Sorted Associative Container
   a    Object of type X
   t    Object of type X::value_type
   k    Object of type X::key_type
   p, q Object of type X::iterator
   c    Object of type X::key_compare

  Definitions

  Valid expressions

   In addition to the expressions defined in |stl-SortedAssociativeContainer|
   and |stl-UniqueAssociativeContainer|, the following expressions must be
   valid.

   +------------------------------------------------------------------------+
   |     Name      | Expression  |      Type requirements       |  Return   |
   |               |             |                              |   type    |
   |---------------+-------------+------------------------------+-----------|
   | Range         |X(i, j)      | i and j are                  |           |
   | constructor   |X a(i, j);   | |stl-InputIterator| whose    |           |
   |               |             | value type is convertible to |           |
   |               |             | T [3][1].                    |           |
   |---------------+-------------+------------------------------+-----------|
   | Range         |             | i and j are                  |           |
   | constructor   |X(i, j, c)   | |stl-InputIterator| whose    |           |
   | with compare  |X a(i, j, c);| value type is convertible to |           |
   |               |             | T [4][1]. c is an object of  |           |
   |               |             | type key_compare.            |           |
   |---------------+-------------+------------------------------+-----------|
   | Insert with   | a.insert(p, |                              | iterator  |
   | hint          | t)          |                              |           |
   |---------------+-------------+------------------------------+-----------|
   | Insert range  | a.insert(i, | i and j are                  | void      |
   |               | j)          | |stl-InputIterator| whose    |           |
   |               |             | value type is convertible to |           |
   |               |             | X::value_type. [5][1]        |           |
   +------------------------------------------------------------------------+

  Expression semantics

  +----------------------------------------------------------------------------+
  |    Name     | Expression  | Precondition |    Semantics    | Postcondition |
  |-------------+-------------+--------------+-----------------+---------------|
  |Range        |X(i, j)      |[i,j) is a    |Creates an       |size() is less |
  |constructor  |X a(i, j);   |valid range.  |associative      |than or equal  |
  |             |             |              |container that   |to the distance|
  |             |             |              |contains all of  |from i to j.   |
  |             |             |              |the elements in  |               |
  |             |             |              |the range [i,j)  |               |
  |             |             |              |that have unique |               |
  |             |             |              |keys. The        |               |
  |             |             |              |comparison object|               |
  |             |             |              |used by the      |               |
  |             |             |              |container is     |               |
  |             |             |              |key_compare().   |               |
  |-------------+-------------+--------------+-----------------+---------------|
  |Range        |             |[i,j) is a    |Creates an       |size() is less |
  |constructor  |X(i, j, c)   |valid range.  |associative      |than or equal  |
  |with compare |X a(i, j, c);|              |container that   |to the distance|
  |             |             |              |contains all of  |from i to j.   |
  |             |             |              |the elements in  |               |
  |             |             |              |the range [i,j)  |               |
  |             |             |              |that have unique |               |
  |             |             |              |keys. The        |               |
  |             |             |              |comparison object|               |
  |             |             |              |used by the      |               |
  |             |             |              |container is c.  |               |
  |-------------+-------------+--------------+-----------------+---------------|
  |Insert with  |a.insert(p,  |p is a        |Inserts t into a |a contains an  |
  |hint         |t)           |nonsingular   |if and only if a |element whose  |
  |             |             |iterator in a.|does not already |key is the same|
  |             |             |              |contain an       |as that of t.  |
  |             |             |              |element whose key|The size of a  |
  |             |             |              |is equivalent to |is incremented |
  |             |             |              |t's key. The     |by either 1 or |
  |             |             |              |argument p is a  |0.             |
  |             |             |              |hint: it points  |               |
  |             |             |              |to the location  |               |
  |             |             |              |where the search |               |
  |             |             |              |will begin. The  |               |
  |             |             |              |return value is a|               |
  |             |             |              |dereferenceable  |               |
  |             |             |              |iterator that    |               |
  |             |             |              |points to the    |               |
  |             |             |              |element with a   |               |
  |             |             |              |key that is      |               |
  |             |             |              |equivalent to    |               |
  |             |             |              |that of t.       |               |
  |-------------+-------------+--------------+-----------------+---------------|
  |Insert range |a.insert(i,  |[i, j) is a   |Equivalent to    |The size of a  |
  |             |j)           |valid range.  |a.insert(t) for  |is incremented |
  |             |             |              |each object t    |by at most j - |
  |             |             |              |that is pointed  |i.             |
  |             |             |              |to by an iterator|               |
  |             |             |              |in the range [i, |               |
  |             |             |              |j). Each element |               |
  |             |             |              |is inserted into |               |
  |             |             |              |a if and only if |               |
  |             |             |              |a does not       |               |
  |             |             |              |already contain  |               |
  |             |             |              |an element with  |               |
  |             |             |              |an equivalent    |               |
  |             |             |              |key.             |               |
  +----------------------------------------------------------------------------+

  Complexity guarantees

   The range constructor, and range constructor with compare, are in general
   O(N * log(N)), where N is the size of the range. However, they are linear
   in N if the range is already sorted by value_comp().

   Insert with hint is logarithmic in general, but it is amortized constant
   time if t is inserted immediately before p.

   Insert range is in general O(N * log(N)), where N is the size of the
   range. However, it is linear in N if the range is already sorted by
   value_comp().

  Invariants

   +------------------------------------------------------------------------+
   | Strictly         | The elements in a Unique Sorted Associative         |
   | ascending order  | Container are always arranged in strictly ascending |
   |                  | order by key. That is, if a is a Unique Sorted      |
   |                  | Associative Container, then                         |
   |                  | |stl-is_sorted|(a.begin(), a.end(), a.value_comp()) |
   |                  | is always true. Furthermore, if i and j are         |
   |                  | dereferenceable iterators in a such that i precedes |
   |                  | j, then a.value_comp()(*i, *j) is always true.      |
   |                  | [6][2]                                              |
   +------------------------------------------------------------------------+

  Models

     * |stl-Map|
     * |stl-set|

  Notes

   [1] At present (early 1998), not all compilers support "member templates".
   If your compiler supports member templates then i and j may be of any type
   that conforms to the |stl-InputIterator| requirements. If your compiler
   does not yet support member templates, however, then i and j must be of
   type const T* or of type X::const_iterator.

   [2] This is a more stringent invariant than that of
   |stl-SortedAssociativeContainer|. In a |stl-SortedAssociativeContainer| we
   merely know that every element is less than or equal to its successor; in
   a |stl-UniqueSortedAssociativeContainer|, however, we know that it must be
   less than its successor.

  See also

   |stl-AssociativeContainer|, |stl-SortedAssociativeContainer|,
   |stl-MultipleSortedAssociativeContainer|, |stl-HashedAssociativeContainer|

*stl-MultipleSortedAssociativeContainer*

                     Multiple Sorted Associative Container

   Category: containers                               Component type: concept

  Description

   A Multiple Sorted Associative Container is a [2]Sorted Associative
   Container that is also a |stl-MultipleAssociativeContainer|. That is, it
   is a |stl-SortedAssociativeContainer| with the property that any number of
   elements in the container may have equivalent keys.

  Refinement of

   |stl-SortedAssociativeContainer|, |stl-MultipleAssociativeContainer|

  Associated types

   None, except for those described in the |stl-SortedAssociativeContainer|
   and |stl-MultipleAssociativeContainer| requirements.

  Notation

   X    A type that is a model of Multiple Sorted Associative Container
   a    Object of type X
   t    Object of type X::value_type
   k    Object of type X::key_type
   p, q Object of type X::iterator
   c    Object of type X::key_compare

  Definitions

  Valid expressions

   In addition to the expressions defined in |stl-SortedAssociativeContainer|
   and |stl-MultipleAssociativeContainer|, the following expressions must be
   valid.

   +------------------------------------------------------------------------+
   |     Name      | Expression  |      Type requirements       |  Return   |
   |               |             |                              |   type    |
   |---------------+-------------+------------------------------+-----------|
   | Range         |X(i, j)      | i and j are                  | X         |
   | constructor   |X a(i, j);   | |stl-InputIterator| whose    |           |
   |               |             | value type is convertible to |           |
   |               |             | T [3][1].                    |           |
   |---------------+-------------+------------------------------+-----------|
   | Range         |             | i and j are                  | X         |
   | constructor   |X(i, j, c)   | |stl-InputIterator| whose    |           |
   | with compare  |X a(i, j, c);| value type is convertible to |           |
   |               |             | T [4][1]. c is an object of  |           |
   |               |             | type key_compare.            |           |
   |---------------+-------------+------------------------------+-----------|
   | Insert with   | a.insert(p, |                              | iterator  |
   | hint          | t)          |                              |           |
   |---------------+-------------+------------------------------+-----------|
   | Insert range  | a.insert(i, | i and j are                  | void      |
   |               | j)          | |stl-InputIterator| whose    |           |
   |               |             | value type is convertible to |           |
   |               |             | X::value_type. [5][1]        |           |
   +------------------------------------------------------------------------+

  Expression semantics

  +----------------------------------------------------------------------------+
  |    Name     | Expression  | Precondition |    Semantics    | Postcondition |
  |-------------+-------------+--------------+-----------------+---------------|
  |Range        |X(i, j)      |[i,j) is a    |Creates an       |size() is equal|
  |constructor  |X a(i, j);   |valid range.  |associative      |to the distance|
  |             |             |              |container that   |from i to j.   |
  |             |             |              |contains all of  |               |
  |             |             |              |the elements in  |               |
  |             |             |              |the range [i,j). |               |
  |             |             |              |The comparison   |               |
  |             |             |              |object used by   |               |
  |             |             |              |the container is |               |
  |             |             |              |key_compare().   |               |
  |-------------+-------------+--------------+-----------------+---------------|
  |Range        |             |[i,j) is a    |Creates an       |size() is equal|
  |constructor  |X(i, j, c)   |valid range.  |associative      |to the distance|
  |with compare |X a(i, j, c);|              |container that   |from i to j.   |
  |             |             |              |contains all of  |               |
  |             |             |              |the elements in  |               |
  |             |             |              |the range [i,j). |               |
  |             |             |              |The comparison   |               |
  |             |             |              |object used by   |               |
  |             |             |              |the container is |               |
  |             |             |              |c.               |               |
  |-------------+-------------+--------------+-----------------+---------------|
  |Insert with  |a.insert(p,  |p is a        |Inserts t into a.|a contains an  |
  |hint         |t)           |nonsingular   |The argument p is|element whose  |
  |             |             |iterator in a.|a hint: it points|key is the same|
  |             |             |              |to the location  |as that of t.  |
  |             |             |              |where the search |The size of a  |
  |             |             |              |will begin. The  |is incremented |
  |             |             |              |return value is a|by 1.          |
  |             |             |              |dereferenceable  |               |
  |             |             |              |iterator that    |               |
  |             |             |              |points to the    |               |
  |             |             |              |element that was |               |
  |             |             |              |just inserted.   |               |
  |-------------+-------------+--------------+-----------------+---------------|
  |Insert range |a.insert(i,  |[i, j) is a   |Equivalent to    |The size of a  |
  |             |j)           |valid range.  |a.insert(t) for  |is incremented |
  |             |             |              |each object t    |by j - i.      |
  |             |             |              |that is pointed  |               |
  |             |             |              |to by an iterator|               |
  |             |             |              |in the range [i, |               |
  |             |             |              |j). Each element |               |
  |             |             |              |is inserted into |               |
  |             |             |              |a.               |               |
  +----------------------------------------------------------------------------+

  Complexity guarantees

   The range constructor, and range constructor with compare, are in general
   O(N * log(N)), where N is the size of the range. However, they are linear
   in N if the range is already sorted by value_comp().

   Insert with hint is logarithmic in general, but it is amortized constant
   time if t is inserted immediately before p.

   Insert range is in general O(N * log(N)), where N is the size of the
   range. However, it is linear in N if the range is already sorted by
   value_comp().

  Invariants

  Models

     * |stl-Multimap|
     * |stl-multiset|

  Notes

   [1] At present (early 1998), not all compilers support "member templates".
   If your compiler supports member templates then i and j may be of any type
   that conforms to the |stl-InputIterator| requirements. If your compiler
   does not yet support member templates, however, then i and j must be of
   type const T* or of type X::const_iterator.

  See also

   |stl-AssociativeContainer|, |stl-SortedAssociativeContainer|,
   |stl-UniqueSortedAssociativeContainer| |stl-HashedAssociativeContainer|

*stl-UniqueHashedAssociativeContainer*

                      Unique Hashed Associative Container

   Category: containers                               Component type: concept

  Description

   A Unique Hashed Associative Container is a |stl-Hashed-Associative-Container|
   that is also a |stl-UniqueAssociativeContainer|. That is, it is a
   |stl-HashedAssociativeContainer| with the property that no two elements in
   the container have the same key.

  Refinement of

   |stl-HashedAssociativeContainer|, |stl-UniqueAssociativeContainer|

  Associated types

   None, except for those described in the |stl-HashedAssociativeContainer|
   and |stl-UniqueAssociativeContainer| requirements.

  Notation

   X    A type that is a model of Hashed Associative Container
   a    Object of type X
   t    Object of type X::value_type
   k    Object of type X::key_type
   p, q Object of type X::iterator
   n    Object of type X::size_type
   h    Object of type X::hasher
   c    Object of type X::key_equal

  Definitions

  Valid expressions

   In addition to the expressions defined in |stl-HashedAssociativeContainer|
   and |stl-UniqueAssociativeContainer|, the following expressions must be
   valid.

   +------------------------------------------------------------------------+
   |      Name      |    Expression     |    Type requirements     | Return |
   |                |                   |                          |  type  |
   |----------------+-------------------+--------------------------+--------|
   | Range          |X(i, j)            | i and j are              | X      |
   | constructor    |X a(i, j);         | |stl-InputIterator|      |        |
   |                |                   | whose value type is      |        |
   |                |                   | convertible to T [3][1]. |        |
   |----------------+-------------------+--------------------------+--------|
   | Range          |X(i, j, n)         | i and j are              | X      |
   | constructor    |X a(i, j, n);      | |stl-InputIterator|      |        |
   | with bucket    |                   | whose value type is      |        |
   | count          |                   | convertible to T [4][1]. |        |
   |----------------+-------------------+--------------------------+--------|
   | Range          |X(i, j, n, h)      | i and j are              | X      |
   | constructor    |X a(i, j, n, h);   | |stl-InputIterator|      |        |
   | with hash      |                   | whose value type is      |        |
   | function       |                   | convertible to T [5][1]. |        |
   |----------------+-------------------+--------------------------+--------|
   | Range          |X(i, j, n, h, k)   | i and j are              | X      |
   | constructor    |X a(i, j, n, h, k);| |stl-InputIterator|      |        |
   | with key equal |                   | whose value type is      |        |
   |                |                   | convertible to T [6][1]. |        |
   +------------------------------------------------------------------------+

  Expression semantics

+------------------------------------------------------------------------------+
|    Name    |    Expression     |Precondition |   Semantics   | Postcondition |
|------------+-------------------+-------------+---------------+---------------|
|Range       |X(i, j)            |[i,j) is a   |Creates an     |size() is less |
|constructor |X a(i, j);         |valid range. |associative    |than or equal  |
|            |                   |             |container that |to the distance|
|            |                   |             |contains all of|from i to j.   |
|            |                   |             |the elements in|The bucket     |
|            |                   |             |the range [i,j)|count is an    |
|            |                   |             |that have      |unspecified    |
|            |                   |             |unique keys,   |default value. |
|            |                   |             |using hasher() |The hash       |
|            |                   |             |as the hash    |function is    |
|            |                   |             |function and   |hasher(), and  |
|            |                   |             |key_equal() as |the key        |
|            |                   |             |the key        |equality       |
|            |                   |             |equality       |function is    |
|            |                   |             |function.      |key_equal().   |
|------------+-------------------+-------------+---------------+---------------|
|Range       |X(i, j, n)         |[i,j) is a   |Creates an     |size() is less |
|constructor |X a(i, j, n);      |valid range. |associative    |than or equal  |
|with bucket |                   |             |container that |to the distance|
|count       |                   |             |contains all of|from i to j.   |
|            |                   |             |the elements in|The bucket     |
|            |                   |             |the range [i,j)|count is       |
|            |                   |             |that have      |greater than or|
|            |                   |             |unique keys,   |equal to n. The|
|            |                   |             |using at least |hash function  |
|            |                   |             |n buckets, and |is hasher(),   |
|            |                   |             |using hasher() |and the key    |
|            |                   |             |as the hash    |equality       |
|            |                   |             |function and   |function is    |
|            |                   |             |key_equal() as |key_equal().   |
|            |                   |             |the key        |               |
|            |                   |             |equality       |               |
|            |                   |             |function.      |               |
|------------+-------------------+-------------+---------------+---------------|
|Range       |X(i, j, n, h)      |[i,j) is a   |Creates an     |size() is less |
|constructor |X a(i, j, n, h);   |valid range. |associative    |than or equal  |
|with hash   |                   |             |container that |to the distance|
|function    |                   |             |contains all of|from i to j.   |
|            |                   |             |the elements in|The bucket     |
|            |                   |             |the range [i,j)|count is       |
|            |                   |             |that have      |greater than or|
|            |                   |             |unique keys,   |equal to n. The|
|            |                   |             |using at least |hash function  |
|            |                   |             |n buckets, and |is h, and the  |
|            |                   |             |using h as the |key equality   |
|            |                   |             |hash function  |function is    |
|            |                   |             |and key_equal()|key_equal().   |
|            |                   |             |as the key     |               |
|            |                   |             |equality       |               |
|            |                   |             |function.      |               |
|------------+-------------------+-------------+---------------+---------------|
|Range       |X(i, j, n, h, k)   |[i,j) is a   |Creates an     |size() is less |
|constructor |X a(i, j, n, h, k);|valid range. |associative    |than or equal  |
|with key    |                   |             |container that |to the distance|
|equal       |                   |             |contains all of|from i to j.   |
|            |                   |             |the elements in|The bucket     |
|            |                   |             |the range [i,j)|count is       |
|            |                   |             |that have      |greater than or|
|            |                   |             |unique keys,   |equal to n. The|
|            |                   |             |using at least |hash function  |
|            |                   |             |n buckets, and |is h, and the  |
|            |                   |             |using h as the |key equality   |
|            |                   |             |hash function  |function is k. |
|            |                   |             |and k as the   |               |
|            |                   |             |key equality   |               |
|            |                   |             |function.      |               |
+------------------------------------------------------------------------------+

  Complexity guarantees

   The range constructor, range constructor with bucket count, range
   constructor with hash function, and range constructor with key equal, are
   all linear in j - i.

  Invariants

  Models

     * |stl-hash_set|
     * |stl-hash_map|

  Notes

   [1] At present (early 1998), not all compilers support "member templates".
   If your compiler supports member templates then i and j may be of any type
   that conforms to the |stl-InputIterator| requirements. If your compiler
   does not yet support member templates, however, then i and j must be of
   type const T* or of type X::const_iterator.

  See also

   |stl-AssociativeContainer|, |stl-HashedAssociativeContainer|,
   |stl-MultipleHashedAssociativeContainer| |stl-SortedAssociativeContainer|

*stl-MultipleHashedAssociativeContainer*

                     Multiple Hashed Associative Container

   Category: containers                               Component type: concept

  Description

   A Multiple Hashed Associative Container is a [2]Hashed Associative
   Container that is also a |stl-MultipleAssociativeContainer|. That is, it
   is a |stl-HashedAssociativeContainer| with the property that any number of
   elements in the container may have the same key

  Refinement of

   |stl-HashedAssociativeContainer|, |stl-MultipleAssociativeContainer|

  Associated types

   None, except for those described in the |stl-HashedAssociativeContainer|
   and |stl-MultipleAssociativeContainer| requirements.

  Notation

   X    A type that is a model of Hashed Associative Container
   a    Object of type X
   t    Object of type X::value_type
   k    Object of type X::key_type
   p, q Object of type X::iterator
   n    Object of type X::size_type
   h    Object of type X::hasher
   c    Object of type X::key_equal

  Definitions

  Valid expressions

   In addition to the expressions defined in |stl-HashedAssociativeContainer|
   and and |stl-MultipleAssociativeContainer|, the following expressions must
   be valid.

   +------------------------------------------------------------------------+
   |      Name      |    Expression     |    Type requirements     | Return |
   |                |                   |                          |  type  |
   |----------------+-------------------+--------------------------+--------|
   | Range          |X(i, j)            | i and j are              | X      |
   | constructor    |X a(i, j);         | |stl-InputIterator|      |        |
   |                |                   | whose value type is      |        |
   |                |                   | convertible to T [3][1]. |        |
   |----------------+-------------------+--------------------------+--------|
   | Range          |X(i, j, n)         | i and j are              | X      |
   | constructor    |X a(i, j, n);      | |stl-InputIterator|      |        |
   | with bucket    |                   | whose value type is      |        |
   | count          |                   | convertible to T [4][1]. |        |
   |----------------+-------------------+--------------------------+--------|
   | Range          |X(i, j, n, h)      | i and j are              | X      |
   | constructor    |X a(i, j, n, h);   | |stl-InputIterator|      |        |
   | with hash      |                   | whose value type is      |        |
   | function       |                   | convertible to T [5][1]. |        |
   |----------------+-------------------+--------------------------+--------|
   | Range          |X(i, j, n, h, k)   | i and j are              | X      |
   | constructor    |X a(i, j, n, h, k);| |stl-InputIterator|      |        |
   | with key equal |                   | whose value type is      |        |
   |                |                   | convertible to T [6][1]. |        |
   +------------------------------------------------------------------------+

  Expression semantics

+------------------------------------------------------------------------------+
|    Name    |    Expression     |Precondition |   Semantics   | Postcondition |
|------------+-------------------+-------------+---------------+---------------|
|Range       |X(i, j)            |[i,j) is a   |Creates an     |size() is equal|
|constructor |X a(i, j);         |valid range. |associative    |to the distance|
|            |                   |             |container that |from i to j.   |
|            |                   |             |contains all   |The bucket     |
|            |                   |             |elements in the|count is an    |
|            |                   |             |range [i,j),   |unspecified    |
|            |                   |             |using hasher() |default value. |
|            |                   |             |as the hash    |The hash       |
|            |                   |             |function and   |function is    |
|            |                   |             |key_equal() as |hasher(), and  |
|            |                   |             |the key        |the key        |
|            |                   |             |equality       |equality       |
|            |                   |             |function.      |function is    |
|            |                   |             |               |key_equal().   |
|------------+-------------------+-------------+---------------+---------------|
|Range       |X(i, j, n)         |[i,j) is a   |Creates an     |size() is equal|
|constructor |X a(i, j, n);      |valid range. |associative    |to the distance|
|with bucket |                   |             |container that |from i to j.   |
|count       |                   |             |contains all   |The bucket     |
|            |                   |             |elements in the|count is       |
|            |                   |             |range [i,j),   |greater than or|
|            |                   |             |using at least |equal to n. The|
|            |                   |             |n buckets, and |hash function  |
|            |                   |             |using hasher() |is hasher(),   |
|            |                   |             |as the hash    |and the key    |
|            |                   |             |function and   |equality       |
|            |                   |             |key_equal() as |function is    |
|            |                   |             |the key        |key_equal().   |
|            |                   |             |equality       |               |
|            |                   |             |function.      |               |
|------------+-------------------+-------------+---------------+---------------|
|Range       |X(i, j, n, h)      |[i,j) is a   |Creates an     |size() is equal|
|constructor |X a(i, j, n, h);   |valid range. |associative    |to the distance|
|with hash   |                   |             |container that |from i to j.   |
|function    |                   |             |contains all   |The bucket     |
|            |                   |             |elements in the|count is       |
|            |                   |             |range [i,j),   |greater than or|
|            |                   |             |using at least |equal to n. The|
|            |                   |             |n buckets, and |hash function  |
|            |                   |             |using h as the |is h, and the  |
|            |                   |             |hash function  |key equality   |
|            |                   |             |and key_equal()|function is    |
|            |                   |             |as the key     |key_equal().   |
|            |                   |             |equality       |               |
|            |                   |             |function.      |               |
|------------+-------------------+-------------+---------------+---------------|
|Range       |X(i, j, n, h, k)   |[i,j) is a   |Creates an     |size() is equal|
|constructor |X a(i, j, n, h, k);|valid range. |associative    |to the distance|
|with key    |                   |             |container that |from i to j.   |
|equal       |                   |             |contains all   |The bucket     |
|            |                   |             |elements in the|count is       |
|            |                   |             |range [i,j),   |greater than or|
|            |                   |             |using at least |equal to n. The|
|            |                   |             |n buckets, and |hash function  |
|            |                   |             |using h as the |is h, and the  |
|            |                   |             |hash function  |key equality   |
|            |                   |             |and k as the   |function is k. |
|            |                   |             |key equality   |               |
|            |                   |             |function.      |               |
+------------------------------------------------------------------------------+

  Complexity guarantees

   The range constructor, range constructor with bucket count, range
   constructor with hash function, and range constructor with key equal, are
   all linear in j - i.

  Invariants

  Models

     * |stl-hash_multiset|
     * |stl-hash_multimap|

  Notes

   [1] At present (early 1998), not all compilers support "member templates".
   If your compiler supports member templates then i and j may be of any type
   that conforms to the |stl-InputIterator| requirements. If your compiler
   does not yet support member templates, however, then i and j must be of
   type const T* or of type X::const_iterator.

  See also

   |stl-AssociativeContainer|, |stl-HashedAssociativeContainer|,
   |stl-UniqueHashedAssociativeContainer| |stl-SortedAssociativeContainer|




    ----------------------------------------------------------------------------
                                Container classes
    ----------------------------------------------------------------------------
        ________________________________________________________________________
                                      Sequences
*stl-Vector*

                                vector<T, Alloc>

   Category: containers                                  Component type: type

  Description

   A vector is a |stl-Sequence| that supports random access to elements,
   constant time insertion and removal of elements at the end, and linear
   time insertion and removal of elements at the beginning or in the middle.
   The number of elements in a vector may vary dynamically; memory management
   is automatic. Vector is the simplest of the STL container classes, and in
   many cases the most efficient.

*stl-Vector-example*

 vector<int> V;
 V.insert(V.begin(), 3);
 assert(V.size() == 1 && V.capacity() >= 1 && V[0] == 3);

  Definition

   Defined in the standard header |stl-vector|, and in the nonstandard
   backward-compatibility header |stl-vector|.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |               Description               |     Default      |
   |-----------+-----------------------------------------+------------------|
   | T         | The vector's value type: the type of    |                  |
   |           | object that is stored in the vector.    |                  |
   |-----------+-----------------------------------------+------------------|
   | Alloc     | The vector's allocator, used for all    | |stl-Allocators| |
   |           | internal memory management.             |                  |
   +------------------------------------------------------------------------+

  Model of

   |stl-RandomAccessContainer|, |stl-BackInsertionSequence|.

  Type requirements

   None, except for those imposed by the requirements of
   |stl-RandomAccessContainer| and |stl-BackInsertionSequence|.

  Public base classes

   None.

  Members

+----------------------------------------------------------------------------------------------------+
|                   Member                    |       Where defined        |       Description       |
|---------------------------------------------+----------------------------+-------------------------|
|value_type                                   ||stl-Container|             |The type of object, T,   |
|                                             |                            |stored in the vector.    |
|---------------------------------------------+----------------------------+-------------------------|
|pointer                                      ||stl-Container|             |Pointer to T.            |
|---------------------------------------------+----------------------------+-------------------------|
|reference                                    ||stl-Container|             |Reference to T           |
|---------------------------------------------+----------------------------+-------------------------|
|const_reference                              ||stl-Container|             |Const reference to T     |
|---------------------------------------------+----------------------------+-------------------------|
|size_type                                    ||stl-Container|             |An unsigned integral     |
|                                             |                            |type.                    |
|---------------------------------------------+----------------------------+-------------------------|
|difference_type                              ||stl-Container|             |A signed integral type.  |
|---------------------------------------------+----------------------------+-------------------------|
|iterator                                     ||stl-Container|             |Iterator used to iterate |
|                                             |                            |through a vector.        |
|---------------------------------------------+----------------------------+-------------------------|
|const_iterator                               ||stl-Container|             |Const iterator used to   |
|                                             |                            |iterate through a vector.|
|---------------------------------------------+----------------------------+-------------------------|
|reverse_iterator                             ||stl-ReversibleContainer|   |Iterator used to iterate |
|                                             |                            |backwards through a      |
|                                             |                            |vector.                  |
|---------------------------------------------+----------------------------+-------------------------|
|const_reverse_iterator                       ||stl-ReversibleContainer|   |Const iterator used to   |
|                                             |                            |iterate backwards through|
|                                             |                            |a vector.                |
|---------------------------------------------+----------------------------+-------------------------|
|iterator begin()                             ||stl-Container|             |Returns an iterator      |
|                                             |                            |pointing to the beginning|
|                                             |                            |of the vector.           |
|---------------------------------------------+----------------------------+-------------------------|
|iterator end()                               ||stl-Container|             |Returns an iterator      |
|                                             |                            |pointing to the end of   |
|                                             |                            |the vector.              |
|---------------------------------------------+----------------------------+-------------------------|
|const_iterator begin() const                 ||stl-Container|             |Returns a const_iterator |
|                                             |                            |pointing to the beginning|
|                                             |                            |of the vector.           |
|---------------------------------------------+----------------------------+-------------------------|
|const_iterator end() const                   ||stl-Container|             |Returns a const_iterator |
|                                             |                            |pointing to the end of   |
|                                             |                            |the vector.              |
|---------------------------------------------+----------------------------+-------------------------|
|reverse_iterator rbegin()                    ||stl-ReversibleContainer|   |Returns a                |
|                                             |                            |reverse_iterator pointing|
|                                             |                            |to the beginning of the  |
|                                             |                            |reversed vector.         |
|---------------------------------------------+----------------------------+-------------------------|
|reverse_iterator rend()                      ||stl-ReversibleContainer|   |Returns a                |
|                                             |                            |reverse_iterator pointing|
|                                             |                            |to the end of the        |
|                                             |                            |reversed vector.         |
|---------------------------------------------+----------------------------+-------------------------|
|const_reverse_iterator rbegin() const        ||stl-ReversibleContainer|   |Returns a                |
|                                             |                            |const_reverse_iterator   |
|                                             |                            |pointing to the beginning|
|                                             |                            |of the reversed vector.  |
|---------------------------------------------+----------------------------+-------------------------|
|const_reverse_iterator rend() const          ||stl-ReversibleContainer|   |Returns a                |
|                                             |                            |const_reverse_iterator   |
|                                             |                            |pointing to the end of   |
|                                             |                            |the reversed vector.     |
|---------------------------------------------+----------------------------+-------------------------|
|size_type size() const                       ||stl-Container|             |Returns the size of the  |
|                                             |                            |vector.                  |
|---------------------------------------------+----------------------------+-------------------------|
|size_type max_size() const                   ||stl-Container|             |Returns the largest      |
|                                             |                            |possible size of the     |
|                                             |                            |vector.                  |
|---------------------------------------------+----------------------------+-------------------------|
|size_type capacity() const                   |vector                      |See below.               |
|---------------------------------------------+----------------------------+-------------------------|
|bool empty() const                           ||stl-Container|             |true if the vector's size|
|                                             |                            |is 0.                    |
|---------------------------------------------+----------------------------+-------------------------|
|reference operator[](size_type n)            ||stl-RandomAccessContainer| |Returns the n'th element.|
|---------------------------------------------+----------------------------+-------------------------|
|const_reference operator[](size_type n) const||stl-RandomAccessContainer| |Returns the n'th element.|
|---------------------------------------------+----------------------------+-------------------------|
|vector()                                     ||stl-Container|             |Creates an empty vector. |
|---------------------------------------------+----------------------------+-------------------------|
|vector(size_type n)                          ||stl-Sequence|              |Creates a vector with n  |
|                                             |                            |elements.                |
|---------------------------------------------+----------------------------+-------------------------|
|vector(size_type n, const T& t)              ||stl-Sequence|              |Creates a vector with n  |
|                                             |                            |copies of t.             |
|---------------------------------------------+----------------------------+-------------------------|
|vector(const vector&)                        ||stl-Container|             |The copy constructor.    |
|---------------------------------------------+----------------------------+-------------------------|
|template <class |stl-InputIterator|>         ||stl-Sequence|              |Creates a vector with a  |
|vector(InputIterator, InputIterator)         |                            |copy of a range.         |
|[4][1]                                       |                            |                         |
|---------------------------------------------+----------------------------+-------------------------|
|~vector()                                    ||stl-Container|             |The destructor.          |
|---------------------------------------------+----------------------------+-------------------------|
|vector& operator=(const vector&)             ||stl-Container|             |The assignment operator  |
|---------------------------------------------+----------------------------+-------------------------|
|void reserve(size_t)                         |vector                      |See below.               |
|---------------------------------------------+----------------------------+-------------------------|
|reference front()                            ||stl-Sequence|              |Returns the first        |
|                                             |                            |element.                 |
|---------------------------------------------+----------------------------+-------------------------|
|const_reference front() const                ||stl-Sequence|              |Returns the first        |
|                                             |                            |element.                 |
|---------------------------------------------+----------------------------+-------------------------|
|reference back()                             ||stl-BackInsertionSequence| |Returns the last element.|
|---------------------------------------------+----------------------------+-------------------------|
|const_reference back() const                 ||stl-BackInsertionSequence| |Returns the last element.|
|---------------------------------------------+----------------------------+-------------------------|
|void push_back(const T&)                     ||stl-BackInsertionSequence| |Inserts a new element at |
|                                             |                            |the end.                 |
|---------------------------------------------+----------------------------+-------------------------|
|void pop_back()                              ||stl-BackInsertionSequence| |Removes the last element.|
|---------------------------------------------+----------------------------+-------------------------|
|void swap(vector&)                           ||stl-Container|             |Swaps the contents of two|
|                                             |                            |vectors.                 |
|---------------------------------------------+----------------------------+-------------------------|
|iterator insert(iterator pos,                ||stl-Sequence|              |Inserts x before pos.    |
|                const T& x)                  |                            |                         |
|---------------------------------------------+----------------------------+-------------------------|
|template <class |stl-InputIterator|>         ||stl-Sequence|              |Inserts the range [first,|
|void insert(iterator pos,                    |                            |last) before pos.        |
|            InputIterator f, InputIterator l)|                            |                         |
|[5][1]                                       |                            |                         |
|---------------------------------------------+----------------------------+-------------------------|
|void insert(iterator pos,                    ||stl-Sequence|              |Inserts n copies of x    |
|            size_type n, const T& x)         |                            |before pos.              |
|---------------------------------------------+----------------------------+-------------------------|
|iterator erase(iterator pos)                 ||stl-Sequence|              |Erases the element at    |
|                                             |                            |position pos.            |
|---------------------------------------------+----------------------------+-------------------------|
|iterator erase(iterator first, iterator last)||stl-Sequence|              |Erases the range [first, |
|                                             |                            |last)                    |
|---------------------------------------------+----------------------------+-------------------------|
|void clear()                                 ||stl-Sequence|              |Erases all of the        |
|                                             |                            |elements.                |
|---------------------------------------------+----------------------------+-------------------------|
|void resize(n, t = T())                      ||stl-Sequence|              |Inserts or erases        |
|                                             |                            |elements at the end such |
|                                             |                            |that the size becomes n. |
|---------------------------------------------+----------------------------+-------------------------|
|bool operator==(const vector&,               ||stl-ForwardContainer|      |Tests two vectors for    |
|                const vector&)               |                            |equality. This is a      |
|                                             |                            |global function, not a   |
|                                             |                            |member function.         |
|---------------------------------------------+----------------------------+-------------------------|
|bool operator<(const vector&,                ||stl-ForwardContainer|      |Lexicographical          |
|               const vector&)                |                            |comparison. This is a    |
|                                             |                            |global function, not a   |
|                                             |                            |member function.         |
+----------------------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-RandomAccessContainer| and
   |stl-BackInsertionSequence| requirements, but are specific to vector.

   +------------------------------------------------------------------------+
   |           Member           |                Description                |
   |----------------------------+-------------------------------------------|
   | size_type capacity() const | Number of elements for which memory has   |
   |                            | been allocated. capacity() is always      |
   |                            | greater than or equal to size(). [6][2]   |
   |                            | [7][3]                                    |
   |----------------------------+-------------------------------------------|
   | void reserve(size_type n)  | If n is less than or equal to capacity(), |
   |                            | this call has no effect. Otherwise, it is |
   |                            | a request for allocation of additional    |
   |                            | memory. If the request is successful,     |
   |                            | then capacity() is greater than or equal  |
   |                            | to n; otherwise, capacity() is unchanged. |
   |                            | In either case, size() is unchanged.      |
   |                            | [8][2] [9][4]                             |
   +------------------------------------------------------------------------+

  Notes

   [1] This member function relies on member template functions, which at
   present (early 1998) are not supported by all compilers. If your compiler
   supports member templates, you can call this function with any type of
   |stl-InputIterator|. If your compiler does not yet support member
   templates, though, then the arguments must be of type const value_type*.

   [2] Memory will be reallocated automatically if more than capacity() -
   size() elements are inserted into the vector. Reallocation does not change
   size(), nor does it change the values of any elements of the vector. It
   does, however, increase capacity(), and it invalidates [10][5] any
   iterators that point into the vector.

   [3] When it is necessary to increase capacity(), vector usually increases
   it by a factor of two. It is crucial that the amount of growth is
   proportional to the current capacity(), rather than a fixed constant: in
   the former case inserting a series of elements into a vector is a linear
   time operation, and in the latter case it is quadratic.

   [4] Reserve() causes a reallocation manually. The main reason for using
   reserve() is efficiency: if you know the capacity to which your vector
   must eventually grow, then it is usually more efficient to allocate that
   memory all at once rather than relying on the automatic reallocation
   scheme. The other reason for using reserve() is so that you can control
   the invalidation of iterators. [11][5]

   [5] A vector's iterators are invalidated when its memory is reallocated.
   Additionally, inserting or deleting an element in the middle of a vector
   invalidates all iterators that point to elements following the insertion
   or deletion point. It follows that you can prevent a vector's iterators
   from being invalidated if you use reserve() to preallocate as much memory
   as the vector will ever use, and if all insertions and deletions are at
   the vector's end.

  See also

   |stl-Deque|, |stl-List|, |stl-Slist|

*stl-Deque*

                                deque<T, Alloc>

   Category: containers                                  Component type: type

  Description

   A deque |stl-#1">[1] is very much like a [2][2]. Additionally, deque does
   not have any member functions analogous to vector's capacity() and
   reserve(), and does not provide any of the guarantees on iterator validity
   that are associated with those member functions. [3][3]

*stl-Deque-example*

 deque<int> Q;
 Q.push_back(3);
 Q.push_front(1);
 Q.insert(Q.begin() + 1, 2);
 Q[2] = 0;
 |stl-copy|(Q.begin(), Q.end(), |stl-ostream_iterator|<int>(cout, " "));
 // The values that are printed are 1 2 0

  Definition

   Defined in the standard header |stl-deque|, and in the nonstandard
   backward-compatibility header |stl-deque|.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |               Description               |     Default      |
   |-----------+-----------------------------------------+------------------|
   | T         | The deque's value type: the type of     |                  |
   |           | object that is stored in the deque.     |                  |
   |-----------+-----------------------------------------+------------------|
   | Alloc     | The deque's allocator, used for all     | |stl-Allocators| |
   |           | internal memory management.             |                  |
   +------------------------------------------------------------------------+

  Model of

   |stl-RandomAccessContainer|, |stl-FrontInsertionSequence|,
   |stl-BackInsertionSequence|.

  Type requirements

   None, except for those imposed by the requirements of
   |stl-RandomAccessContainer|, |stl-FrontInsertionSequence|, and
   |stl-BackInsertionSequence|.

  Public base classes

   None.

  Members

+-----------------------------------------------------------------------------------------------------+
|                   Member                    |        Where defined        |       Description       |
|---------------------------------------------+-----------------------------+-------------------------|
|value_type                                   ||stl-Container|              |The type of object, T,   |
|                                             |                             |stored in the deque.     |
|---------------------------------------------+-----------------------------+-------------------------|
|pointer                                      ||stl-Container|              |Pointer to T.            |
|---------------------------------------------+-----------------------------+-------------------------|
|reference                                    ||stl-Container|              |Reference to T           |
|---------------------------------------------+-----------------------------+-------------------------|
|const_reference                              ||stl-Container|              |Const reference to T     |
|---------------------------------------------+-----------------------------+-------------------------|
|size_type                                    ||stl-Container|              |An unsigned integral     |
|                                             |                             |type.                    |
|---------------------------------------------+-----------------------------+-------------------------|
|difference_type                              ||stl-Container|              |A signed integral type.  |
|---------------------------------------------+-----------------------------+-------------------------|
|iterator                                     ||stl-Container|              |Iterator used to iterate |
|                                             |                             |through a deque.         |
|---------------------------------------------+-----------------------------+-------------------------|
|const_iterator                               ||stl-Container|              |Const iterator used to   |
|                                             |                             |iterate through a deque. |
|---------------------------------------------+-----------------------------+-------------------------|
|reverse_iterator                             ||stl-ReversibleContainer|    |Iterator used to iterate |
|                                             |                             |backwards through a      |
|                                             |                             |deque.                   |
|---------------------------------------------+-----------------------------+-------------------------|
|const_reverse_iterator                       ||stl-ReversibleContainer|    |Const iterator used to   |
|                                             |                             |iterate backwards through|
|                                             |                             |a deque.                 |
|---------------------------------------------+-----------------------------+-------------------------|
|iterator begin()                             ||stl-Container|              |Returns an iterator      |
|                                             |                             |pointing to the beginning|
|                                             |                             |of the deque.            |
|---------------------------------------------+-----------------------------+-------------------------|
|iterator end()                               ||stl-Container|              |Returns an iterator      |
|                                             |                             |pointing to the end of   |
|                                             |                             |the deque.               |
|---------------------------------------------+-----------------------------+-------------------------|
|const_iterator begin() const                 ||stl-Container|              |Returns a const_iterator |
|                                             |                             |pointing to the beginning|
|                                             |                             |of the deque.            |
|---------------------------------------------+-----------------------------+-------------------------|
|const_iterator end() const                   ||stl-Container|              |Returns a const_iterator |
|                                             |                             |pointing to the end of   |
|                                             |                             |the deque.               |
|---------------------------------------------+-----------------------------+-------------------------|
|reverse_iterator rbegin()                    ||stl-ReversibleContainer|    |Returns a                |
|                                             |                             |reverse_iterator pointing|
|                                             |                             |to the beginning of the  |
|                                             |                             |reversed deque.          |
|---------------------------------------------+-----------------------------+-------------------------|
|reverse_iterator rend()                      ||stl-ReversibleContainer|    |Returns a                |
|                                             |                             |reverse_iterator pointing|
|                                             |                             |to the end of the        |
|                                             |                             |reversed deque.          |
|---------------------------------------------+-----------------------------+-------------------------|
|const_reverse_iterator rbegin() const        ||stl-ReversibleContainer|    |Returns a                |
|                                             |                             |const_reverse_iterator   |
|                                             |                             |pointing to the beginning|
|                                             |                             |of the reversed deque.   |
|---------------------------------------------+-----------------------------+-------------------------|
|const_reverse_iterator rend() const          ||stl-ReversibleContainer|    |Returns a                |
|                                             |                             |const_reverse_iterator   |
|                                             |                             |pointing to the end of   |
|                                             |                             |the reversed deque.      |
|---------------------------------------------+-----------------------------+-------------------------|
|size_type size() const                       ||stl-Container|              |Returns the size of the  |
|                                             |                             |deque.                   |
|---------------------------------------------+-----------------------------+-------------------------|
|size_type max_size() const                   ||stl-Container|              |Returns the largest      |
|                                             |                             |possible size of the     |
|                                             |                             |deque.                   |
|---------------------------------------------+-----------------------------+-------------------------|
|bool empty() const                           ||stl-Container|              |true if the deque's size |
|                                             |                             |is 0.                    |
|---------------------------------------------+-----------------------------+-------------------------|
|reference operator[](size_type n)            ||stl-RandomAccessContainer|  |Returns the n'th element.|
|---------------------------------------------+-----------------------------+-------------------------|
|const_reference operator[](size_type n) const||stl-RandomAccessContainer|  |Returns the n'th element.|
|---------------------------------------------+-----------------------------+-------------------------|
|deque()                                      ||stl-Container|              |Creates an empty deque.  |
|---------------------------------------------+-----------------------------+-------------------------|
|deque(size_type n)                           ||stl-Sequence|               |Creates a deque with n   |
|                                             |                             |elements.                |
|---------------------------------------------+-----------------------------+-------------------------|
|deque(size_type n, const T& t)               ||stl-Sequence|               |Creates a deque with n   |
|                                             |                             |copies of t.             |
|---------------------------------------------+-----------------------------+-------------------------|
|deque(const deque&)                          ||stl-Container|              |The copy constructor.    |
|---------------------------------------------+-----------------------------+-------------------------|
|template <class |stl-InputIterator|>         ||stl-Sequence|               |Creates a deque with a   |
|deque(InputIterator f, InputIterator l)      |                             |copy of a range.         |
|[6][4]                                       |                             |                         |
|---------------------------------------------+-----------------------------+-------------------------|
|~deque()                                     ||stl-Container|              |The destructor.          |
|---------------------------------------------+-----------------------------+-------------------------|
|deque& operator=(const deque&)               ||stl-Container|              |The assignment operator  |
|---------------------------------------------+-----------------------------+-------------------------|
|reference front()                            ||stl-FrontInsertionSequence| |Returns the first        |
|                                             |                             |element.                 |
|---------------------------------------------+-----------------------------+-------------------------|
|const_reference front() const                ||stl-FrontInsertionSequence| |Returns the first        |
|                                             |                             |element.                 |
|---------------------------------------------+-----------------------------+-------------------------|
|reference back()                             ||stl-BackInsertionSequence|  |Returns the last element.|
|---------------------------------------------+-----------------------------+-------------------------|
|const_reference back() const                 ||stl-BackInsertionSequence|  |Returns the last element.|
|---------------------------------------------+-----------------------------+-------------------------|
|void push_front(const T&)                    ||stl-FrontInsertionSequence| |Inserts a new element at |
|                                             |                             |the beginning.           |
|---------------------------------------------+-----------------------------+-------------------------|
|void push_back(const T&)                     ||stl-BackInsertionSequence|  |Inserts a new element at |
|                                             |                             |the end.                 |
|---------------------------------------------+-----------------------------+-------------------------|
|void pop_front()                             ||stl-FrontInsertionSequence| |Removes the first        |
|                                             |                             |element.                 |
|---------------------------------------------+-----------------------------+-------------------------|
|void pop_back()                              ||stl-BackInsertionSequence|  |Removes the last element.|
|---------------------------------------------+-----------------------------+-------------------------|
|void swap(deque&)                            ||stl-Container|              |Swaps the contents of two|
|                                             |                             |deques.                  |
|---------------------------------------------+-----------------------------+-------------------------|
|iterator insert(iterator pos,                ||stl-Sequence|               |Inserts x before pos.    |
|                const T& x)                  |                             |                         |
|---------------------------------------------+-----------------------------+-------------------------|
|template <class |stl-InputIterator|>         ||stl-Sequence|               |Inserts the range [f, l) |
|void insert(iterator pos,                    |                             |before pos.              |
|            InputIterator f, InputIterator l)|                             |                         |
|[7][4]                                       |                             |                         |
|---------------------------------------------+-----------------------------+-------------------------|
|void insert(iterator pos,                    ||stl-Sequence|               |Inserts n copies of x    |
|            size_type n, const T& x)         |                             |before pos.              |
|---------------------------------------------+-----------------------------+-------------------------|
|iterator erase(iterator pos)                 ||stl-Sequence|               |Erases the element at    |
|                                             |                             |position pos.            |
|---------------------------------------------+-----------------------------+-------------------------|
|iterator erase(iterator first, iterator last)||stl-Sequence|               |Erases the range [first, |
|                                             |                             |last)                    |
|---------------------------------------------+-----------------------------+-------------------------|
|void clear()                                 ||stl-Sequence|               |Erases all of the        |
|                                             |                             |elements.                |
|---------------------------------------------+-----------------------------+-------------------------|
|void resize(n, t = T())                      ||stl-Sequence|               |Inserts or erases        |
|                                             |                             |elements at the end such |
|                                             |                             |that the size becomes n. |
|---------------------------------------------+-----------------------------+-------------------------|
|bool operator==(const deque&,                ||stl-ForwardContainer|       |Tests two deques for     |
|                const deque&)                |                             |equality. This is a      |
|                                             |                             |global function, not a   |
|                                             |                             |member function.         |
|---------------------------------------------+-----------------------------+-------------------------|
|bool operator<(const deque&,                 ||stl-ForwardContainer|       |Lexicographical          |
|               const deque&)                 |                             |comparison. This is a    |
|                                             |                             |global function, not a   |
|                                             |                             |member function.         |
+-----------------------------------------------------------------------------------------------------+

  New members

   All of deque's members are defined in the |stl-RandomAccessContainer|,
   |stl-FrontInsertionSequence|, and |stl-BackInsertionSequence|
   requirements. Deque does not introduce any new members.

  Notes

   [1] The name deque is pronounced "deck", and stands for "double-ended
   queue." Knuth (section 2.6) reports that the name was coined by E. J.
   Schweppe. See section 2.2.1 of Knuth for more information about deques.
   (D. E. Knuth, The Art of Computer Programming. Volume 1: Fundamental
   Algorithms, second edition. Addison-Wesley, 1973.)

   [2] Inserting an element at the beginning or end of a deque takes
   amortized constant time. Inserting an element in the middle is linear in
   n, where n is the smaller of the number of elements from the insertion
   point to the beginning, and the number of elements from the insertion
   point to the end.

   [3] The semantics of iterator invalidation for deque is as follows. Insert
   (including push_front and push_back) invalidates all iterators that refer
   to a deque. Erase in the middle of a deque invalidates all iterators that
   refer to the deque. Erase at the beginning or end of a deque (including
   pop_front and pop_back) invalidates an iterator only if it points to the
   erased element.

   [4] This member function relies on member template functions, which at
   present (early 1998) are not supported by all compilers. If your compiler
   supports member templates, you can call this function with any type of
   |stl-InputIterator|. If your compiler does not yet support member
   templates, though, then the arguments must either be of type const
   value_type* or of type deque::const_iterator.

  See also

   |stl-Vector|, |stl-List|, |stl-Slist|

*stl-List*

                                 list<T, Alloc>

   Category: containers                                  Component type: type

  Description

   A list is a doubly linked list. That is, it is a |stl-Sequence| that
   supports both forward and backward traversal, and (amortized) constant
   time insertion and removal of elements at the beginning or the end, or in
   the middle. Lists have the important property that insertion and splicing
   do not invalidate iterators to list elements, and that even removal
   invalidates only the iterators that point to the elements that are
   removed. The ordering of iterators may be changed (that is,
   list<T>::iterator might have a different predecessor or successor after a
   list operation than it did before), but the iterators themselves will not
   be invalidated or made to point to different elements unless that
   invalidation or mutation is explicit. [2][1]

   Note that singly linked lists, which only support forward traversal, are
   also sometimes useful. If you do not need backward traversal, then
   |stl-Slist| may be more efficient than list.

  Definition

   Defined in the standard header |stl-list|, and in the nonstandard
   backward-compatibility header |stl-list|.h.

*stl-List-example*

 list<int> L;
 L.push_back(0);
 L.push_front(1);
 L.insert(++L.begin(), 2);
 |stl-copy|(L.begin(), L.end(), |stl-ostream_iterator|<int>(cout, " "));
 // The values that are printed are 1 2 0

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |               Description               |     Default      |
   |-----------+-----------------------------------------+------------------|
   | T         | The list's value type: the type of      |                  |
   |           | object that is stored in the list.      |                  |
   |-----------+-----------------------------------------+------------------|
   | Alloc     | The list's allocator, used for all      | |stl-Allocators| |
   |           | internal memory management.             |                  |
   +------------------------------------------------------------------------+

  Model of

   |stl-ReversibleContainer|, |stl-FrontInsertionSequence|,
   |stl-BackInsertionSequence|.

  Type requirements

   None, except for those imposed by the requirements of
   |stl-ReversibleContainer|, |stl-FrontInsertionSequence|, and
   |stl-BackInsertionSequence|.

  Public base classes

   None.

  Members

+----------------------------------------------------------------------------------------------+
|                Member                |        Where defined        |       Description       |
|--------------------------------------+-----------------------------+-------------------------|
|value_type                            ||stl-Container|              |The type of object, T,   |
|                                      |                             |stored in the list.      |
|--------------------------------------+-----------------------------+-------------------------|
|pointer                               ||stl-Container|              |Pointer to T.            |
|--------------------------------------+-----------------------------+-------------------------|
|reference                             ||stl-Container|              |Reference to T           |
|--------------------------------------+-----------------------------+-------------------------|
|const_reference                       ||stl-Container|              |Const reference to T     |
|--------------------------------------+-----------------------------+-------------------------|
|size_type                             ||stl-Container|              |An unsigned integral     |
|                                      |                             |type.                    |
|--------------------------------------+-----------------------------+-------------------------|
|difference_type                       ||stl-Container|              |A signed integral type.  |
|--------------------------------------+-----------------------------+-------------------------|
|iterator                              ||stl-Container|              |Iterator used to iterate |
|                                      |                             |through a list.          |
|--------------------------------------+-----------------------------+-------------------------|
|const_iterator                        ||stl-Container|              |Const iterator used to   |
|                                      |                             |iterate through a list.  |
|--------------------------------------+-----------------------------+-------------------------|
|reverse_iterator                      ||stl-ReversibleContainer|    |Iterator used to iterate |
|                                      |                             |backwards through a list.|
|--------------------------------------+-----------------------------+-------------------------|
|const_reverse_iterator                ||stl-ReversibleContainer|    |Const iterator used to   |
|                                      |                             |iterate backwards through|
|                                      |                             |a list.                  |
|--------------------------------------+-----------------------------+-------------------------|
|iterator begin()                      ||stl-Container|              |Returns an iterator      |
|                                      |                             |pointing to the beginning|
|                                      |                             |of the list.             |
|--------------------------------------+-----------------------------+-------------------------|
|iterator end()                        ||stl-Container|              |Returns an iterator      |
|                                      |                             |pointing to the end of   |
|                                      |                             |the list.                |
|--------------------------------------+-----------------------------+-------------------------|
|const_iterator begin() const          ||stl-Container|              |Returns a const_iterator |
|                                      |                             |pointing to the beginning|
|                                      |                             |of the list.             |
|--------------------------------------+-----------------------------+-------------------------|
|const_iterator end() const            ||stl-Container|              |Returns a const_iterator |
|                                      |                             |pointing to the end of   |
|                                      |                             |the list.                |
|--------------------------------------+-----------------------------+-------------------------|
|reverse_iterator rbegin()             ||stl-ReversibleContainer|    |Returns a                |
|                                      |                             |reverse_iterator pointing|
|                                      |                             |to the beginning of the  |
|                                      |                             |reversed list.           |
|--------------------------------------+-----------------------------+-------------------------|
|reverse_iterator rend()               ||stl-ReversibleContainer|    |Returns a                |
|                                      |                             |reverse_iterator pointing|
|                                      |                             |to the end of the        |
|                                      |                             |reversed list.           |
|--------------------------------------+-----------------------------+-------------------------|
|const_reverse_iterator rbegin() const ||stl-ReversibleContainer|    |Returns a                |
|                                      |                             |const_reverse_iterator   |
|                                      |                             |pointing to the beginning|
|                                      |                             |of the reversed list.    |
|--------------------------------------+-----------------------------+-------------------------|
|const_reverse_iterator rend() const   ||stl-ReversibleContainer|    |Returns a                |
|                                      |                             |const_reverse_iterator   |
|                                      |                             |pointing to the end of   |
|                                      |                             |the reversed list.       |
|--------------------------------------+-----------------------------+-------------------------|
|size_type size() const                ||stl-Container|              |Returns the size of the  |
|                                      |                             |list. Note: you should   |
|                                      |                             |not assume that this     |
|                                      |                             |function is constant     |
|                                      |                             |time. It is permitted to |
|                                      |                             |be O(N), where N is the  |
|                                      |                             |number of elements in the|
|                                      |                             |list. If you wish to test|
|                                      |                             |whether a list is empty, |
|                                      |                             |you should write         |
|                                      |                             |L.empty() rather than    |
|                                      |                             |L.size() == 0.           |
|--------------------------------------+-----------------------------+-------------------------|
|size_type max_size() const            ||stl-Container|              |Returns the largest      |
|                                      |                             |possible size of the     |
|                                      |                             |list.                    |
|--------------------------------------+-----------------------------+-------------------------|
|bool empty() const                    ||stl-Container|              |true if the list's size  |
|                                      |                             |is 0.                    |
|--------------------------------------+-----------------------------+-------------------------|
|list()                                ||stl-Container|              |Creates an empty list.   |
|--------------------------------------+-----------------------------+-------------------------|
|list(size_type n)                     ||stl-Sequence|               |Creates a list with n    |
|                                      |                             |elements, each of which  |
|                                      |                             |is a copy of T().        |
|--------------------------------------+-----------------------------+-------------------------|
|list(size_type n, const T& t)         ||stl-Sequence|               |Creates a list with n    |
|                                      |                             |copies of t.             |
|--------------------------------------+-----------------------------+-------------------------|
|list(const list&)                     ||stl-Container|              |The copy constructor.    |
|--------------------------------------+-----------------------------+-------------------------|
|template <class |stl-InputIterator|>  ||stl-Sequence|               |Creates a list with a    |
|list(InputIterator f, InputIterator l)|                             |copy of a range.         |
|[5][2]                                |                             |                         |
|--------------------------------------+-----------------------------+-------------------------|
|~list()                               ||stl-Container|              |The destructor.          |
|--------------------------------------+-----------------------------+-------------------------|
|list& operator=(const list&)          ||stl-Container|              |The assignment operator  |
|--------------------------------------+-----------------------------+-------------------------|
|reference front()                     ||stl-FrontInsertionSequence| |Returns the first        |
|                                      |                             |element.                 |
|--------------------------------------+-----------------------------+-------------------------|
|const_reference front() const         ||stl-FrontInsertionSequence| |Returns the first        |
|                                      |                             |element.                 |
|--------------------------------------+-----------------------------+-------------------------|
|reference back()                      ||stl-Sequence|               |Returns the last element.|
|--------------------------------------+-----------------------------+-------------------------|
|const_reference back() const          ||stl-BackInsertionSequence|  |Returns the last element.|
|--------------------------------------+-----------------------------+-------------------------|
|void push_front(const T&)             ||stl-FrontInsertionSequence| |Inserts a new element at |
|                                      |                             |the beginning.           |
|--------------------------------------+-----------------------------+-------------------------|
|void push_back(const T&)              ||stl-BackInsertionSequence|  |Inserts a new element at |
|                                      |                             |the end.                 |
|--------------------------------------+-----------------------------+-------------------------|
|void pop_front()                      ||stl-FrontInsertionSequence| |Removes the first        |
|                                      |                             |element.                 |
|--------------------------------------+-----------------------------+-------------------------|
|void pop_back()                       ||stl-BackInsertionSequence|  |Removes the last element.|
|--------------------------------------+-----------------------------+-------------------------|
|void swap(list&)                      ||stl-Container|              |Swaps the contents of two|
|                                      |                             |lists.                   |
|--------------------------------------+-----------------------------+-------------------------|
|iterator insert(iterator pos, const T&||stl-Sequence|               |Inserts x before pos.    |
|x)                                    |                             |                         |
|--------------------------------------+-----------------------------+-------------------------|
|template <class |stl-InputIterator|>  ||stl-Sequence|               |Inserts the range [f, l) |
|void insert(iterator pos,             |                             |before pos.              |
|            InputIterator f,          |                             |                         |
|            InputIterator l)          |                             |                         |
|[6][2]                                |                             |                         |
|--------------------------------------+-----------------------------+-------------------------|
|void insert(iterator pos,             ||stl-Sequence|               |Inserts n copies of x    |
|            size_type n, const T& x)  |                             |before pos.              |
|--------------------------------------+-----------------------------+-------------------------|
|iterator erase(iterator pos)          ||stl-Sequence|               |Erases the element at    |
|                                      |                             |position pos.            |
|--------------------------------------+-----------------------------+-------------------------|
|iterator erase(iterator first,        ||stl-Sequence|               |Erases the range [first, |
|iterator last)                        |                             |last)                    |
|--------------------------------------+-----------------------------+-------------------------|
|void clear()                          ||stl-Sequence|               |Erases all of the        |
|                                      |                             |elements.                |
|--------------------------------------+-----------------------------+-------------------------|
|void resize(n, t = T())               ||stl-Sequence|               |Inserts or erases        |
|                                      |                             |elements at the end such |
|                                      |                             |that the size becomes n. |
|--------------------------------------+-----------------------------+-------------------------|
|void splice(iterator pos, list& L)    |list                         |See below.               |
|--------------------------------------+-----------------------------+-------------------------|
|void splice(iterator pos,             |list                         |See below.               |
|            list& L,                  |                             |                         |
|            iterator i)               |                             |                         |
|--------------------------------------+-----------------------------+-------------------------|
|void splice(iterator pos,             |list                         |See below.               |
|            list& L,                  |                             |                         |
|            iterator f, iterator l)   |                             |                         |
|--------------------------------------+-----------------------------+-------------------------|
|void remove(const T& value)           |list                         |See below.               |
|--------------------------------------+-----------------------------+-------------------------|
|void unique()                         |list                         |See below.               |
|--------------------------------------+-----------------------------+-------------------------|
|void merge(list& L)                   |list                         |See below.               |
|--------------------------------------+-----------------------------+-------------------------|
|void sort()                           |list                         |See below.               |
|--------------------------------------+-----------------------------+-------------------------|
|bool operator==(const list&,          ||stl-ForwardContainer|       |Tests two lists for      |
|                const list&)          |                             |equality. This is a      |
|                                      |                             |global function, not a   |
|                                      |                             |member function.         |
|--------------------------------------+-----------------------------+-------------------------|
|bool operator<(const list&,           ||stl-ForwardContainer|       |Lexicographical          |
|               const list&)           |                             |comparison. This is a    |
|                                      |                             |global function, not a   |
|                                      |                             |member function.         |
+----------------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-ReversibleContainer|,
   |stl-FrontInsertionSequence|, and |stl-BackInsertionSequence|
   requirements, but are specific to list.

   +------------------------------------------------------------------------+
   |               Function               |           Description           |
   |--------------------------------------+---------------------------------|
   |void splice(iterator position,        | position must be a valid        |
   |            list<T, Alloc>& x);       | iterator in *this, and x must   |
   |                                      | be a list that is distinct from |
   |                                      | *this. (That is, it is required |
   |                                      | that &x != this.) All of the    |
   |                                      | elements of x are inserted      |
   |                                      | before position and removed     |
   |                                      | from x. All iterators remain    |
   |                                      | valid, including iterators that |
   |                                      | point to elements of x. [7][3]  |
   |                                      | This function is constant time. |
   |--------------------------------------+---------------------------------|
   |                                      | position must be a valid        |
   |void splice(iterator position,        | iterator in *this, and i must   |
   |            list<T, Alloc>& x,        | be a dereferenceable iterator   |
   |            iterator i);              | in x. Splice moves the element  |
   |                                      | pointed to by i from x to       |
   |                                      | *this, inserting it before      |
   |                                      | position. All iterators remain  |
   |                                      | valid, including iterators that |
   |                                      | point to elements of x. [8][3]  |
   |                                      | If position == i or position == |
   |                                      | ++i, this function is a null    |
   |                                      | operation. This function is     |
   |                                      | constant time.                  |
   |--------------------------------------+---------------------------------|
   |                                      | position must be a valid        |
   |void splice(iterator position,        | iterator in *this, and [first,  |
   |            list<T, Alloc>& x,        | last) must be a valid range in  |
   |            iterator f, iterator l);  | x. position may not be an       |
   |                                      | iterator in the range [first,   |
   |                                      | last). Splice moves the         |
   |                                      | elements in [first, last) from  |
   |                                      | x to *this, inserting them      |
   |                                      | before position. All iterators  |
   |                                      | remain valid, including         |
   |                                      | iterators that point to         |
   |                                      | elements of x. [9][3] This      |
   |                                      | function is constant time.      |
   |--------------------------------------+---------------------------------|
   | void remove(const T& val);           | Removes all elements that       |
   |                                      | compare equal to val. The       |
   |                                      | relative order of elements that |
   |                                      | are not removed is unchanged,   |
   |                                      | and iterators to elements that  |
   |                                      | are not removed remain valid.   |
   |                                      | This function is linear time:   |
   |                                      | it performs exactly size()      |
   |                                      | comparisons for equality.       |
   |--------------------------------------+---------------------------------|
   |template<class |stl-Predicate|>       | Removes all elements *i such    |
   |void remove_if(|stl-Predicate| p);    | that p(*i) is true. The         |
   |[10][4]                               | relative order of elements that |
   |                                      | are not removed is unchanged,   |
   |                                      | and iterators to elements that  |
   |                                      | are not removed remain valid.   |
   |                                      | This function is linear time:   |
   |                                      | it performs exactly size()      |
   |                                      | applications of p.              |
   |--------------------------------------+---------------------------------|
   | void unique();                       | Removes all but the first       |
   |                                      | element in every consecutive    |
   |                                      | group of equal elements. The    |
   |                                      | relative order of elements that |
   |                                      | are not removed is unchanged,   |
   |                                      | and iterators to elements that  |
   |                                      | are not removed remain valid.   |
   |                                      | This function is linear time:   |
   |                                      | it performs exactly size() - 1  |
   |                                      | comparisons for equality.       |
   |--------------------------------------+---------------------------------|
   |template<class |stl-BinaryPredicate|> | Removes all but the first       |
   |void unique(|stl-BinaryPredicate| p); | element in every consecutive    |
   |[11][4]                               | group of equivalent elements,   |
   |                                      | where two elements *i and *j    |
   |                                      | are considered equivalent if    |
   |                                      | p(*i, *j) is true. The relative |
   |                                      | order of elements that are not  |
   |                                      | removed is unchanged, and       |
   |                                      | iterators to elements that are  |
   |                                      | not removed remain valid. This  |
   |                                      | function is linear time: it     |
   |                                      | performs exactly size() - 1     |
   |                                      | comparisons for equality.       |
   |--------------------------------------+---------------------------------|
   | void merge(list<T, Alloc>& x);       | Both *this and x must be sorted |
   |                                      | according to operator<, and     |
   |                                      | they must be distinct. (That    |
   |                                      | is, it is required that &x !=   |
   |                                      | this.) This function removes    |
   |                                      | all of x's elements and inserts |
   |                                      | them in order into *this. The   |
   |                                      | merge is stable; that is, if an |
   |                                      | element from *this is           |
   |                                      | equivalent to one from x, then  |
   |                                      | the element from *this will     |
   |                                      | precede the one from x. All     |
   |                                      | iterators to elements in *this  |
   |                                      | and x remain valid. This        |
   |                                      | function is linear time: it     |
   |                                      | performs at most size() +       |
   |                                      | x.size() - 1 comparisons.       |
   |--------------------------------------+---------------------------------|
   |template<class |stl-BinaryPredicate|> | Comp must be a comparison       |
   |void merge(list<T, Alloc>& x,         | function that induces a strict  |
   |           BinaryPredicate Comp);     | weak ordering (as defined in    |
   |[12][4]                               | the |stl-LessThanComparable|    |
   |                                      | requirements) on objects of     |
   |                                      | type T, and both *this and x    |
   |                                      | must be sorted according to     |
   |                                      | that ordering. The lists x and  |
   |                                      | *this must be distinct. (That   |
   |                                      | is, it is required that &x !=   |
   |                                      | this.) This function removes    |
   |                                      | all of x's elements and inserts |
   |                                      | them in order into *this. The   |
   |                                      | merge is stable; that is, if an |
   |                                      | element from *this is           |
   |                                      | equivalent to one from x, then  |
   |                                      | the element from *this will     |
   |                                      | precede the one from x. All     |
   |                                      | iterators to elements in *this  |
   |                                      | and x remain valid. This        |
   |                                      | function is linear time: it     |
   |                                      | performs at most size() +       |
   |                                      | x.size() - 1 applications of    |
   |                                      | Comp.                           |
   |--------------------------------------+---------------------------------|
   | void reverse();                      | Reverses the order of elements  |
   |                                      | in the list. All iterators      |
   |                                      | remain valid and continue to    |
   |                                      | point to the same elements.     |
   |                                      | [13][5] This function is linear |
   |                                      | time.                           |
   |--------------------------------------+---------------------------------|
   | void sort();                         | Sorts *this according to        |
   |                                      | operator<. The sort is stable,  |
   |                                      | that is, the relative order of  |
   |                                      | equivalent elements is          |
   |                                      | preserved. All iterators remain |
   |                                      | valid and continue to point to  |
   |                                      | the same elements. [14][6] The  |
   |                                      | number of comparisons is        |
   |                                      | approximately N log N, where N  |
   |                                      | is the list's size.             |
   |--------------------------------------+---------------------------------|
   |template<class |stl-BinaryPredicate|> | Comp must be a comparison       |
   |void sort(BinaryPredicate comp);      | function that induces a strict  |
   |[15][4]                               | weak ordering (as defined in    |
   |                                      | the |stl-LessThanComparable|    |
   |                                      | requirements on objects of type |
   |                                      | T. This function sorts the list |
   |                                      | *this according to Comp. The    |
   |                                      | sort is stable, that is, the    |
   |                                      | relative order of equivalent    |
   |                                      | elements is preserved. All      |
   |                                      | iterators remain valid and      |
   |                                      | continue to point to the same   |
   |                                      | elements. [16][6] The number of |
   |                                      | comparisons is approximately N  |
   |                                      | log N, where N is the list's    |
   |                                      | size.                           |
   +------------------------------------------------------------------------+

  Notes

   [1] A comparison with |stl-Vector| is instructive. Suppose that i is a
   valid |stl-Vector|<T>::iterator. If an element is inserted or removed in a
   position that precedes i, then this operation will either result in i
   pointing to a different element than it did before, or else it will
   invalidate i entirely. (A |stl-Vector|<T>::iterator will be invalidated,
   for example, if an insertion requires a reallocation.) However, suppose
   that i and j are both iterators into a |stl-Vector|, and there exists some
   integer n such that i == j + n. In that case, even if elements are
   inserted into the vector and i and j point to different elements, the
   relation between the two iterators will still hold. A list is exactly the
   opposite: iterators will not be invalidated, and will not be made to point
   to different elements, but, for list iterators, the predecessor/successor
   relationship is not invariant.

   [2] This member function relies on member template functions, which at
   present (early 1998) are not supported by all compilers. If your compiler
   supports member templates, you can call this function with any type of
   |stl-InputIterator|. If your compiler does not yet support member
   templates, though, then the arguments must either be of type const
   value_type* or of type list::const_iterator.

   [3] A similar property holds for all versions of insert() and erase().
   List<T, Alloc>::insert() never invalidates any iterators, and list<T,
   Alloc>::erase() only invalidates iterators pointing to the elements that
   are actually being erased.

   [4] This member function relies on member template functions, which at
   present (early 1998) are not supported by all compilers. You can only use
   this member function if your compiler supports member templates.

   [5] If L is a list, note that L.reverse() and |stl-reverse|(L.begin(),
   L.end()) are both correct ways of reversing the list. They differ in that
   L.reverse() will preserve the value that each iterator into L points to
   but will not preserve the iterators' predecessor/successor relationships,
   while |stl-reverse|(L.begin(), L.end()) will not preserve the value that
   each iterator points to but will preserve the iterators'
   predecessor/successor relationships. Note also that the algorithm
   |stl-reverse|(L.begin(), L.end()) will use T's assignment operator, while
   the member function L.reverse() will not.

   [6] The |stl-sort| algorithm works only for |stl-RandomAccessIterator|. In
   principle, however, it would be possible to write a sort algorithm that
   also accepted |stl-BidirectionalIterator|. Even if there were such a
   version of |stl-sort|, it would still be useful for list to have a sort
   member function. That is, sort is provided as a member function not only
   for the sake of efficiency, but also because of the property that it
   preserves the values that list iterators point to.

  See also

   |stl-BidirectionalIterator|, |stl-ReversibleContainer|, |stl-Sequence|,
   |stl-Slist| |stl-Vector|.

*stl-Slist*

                                slist<T, Alloc>

   Category: containers                                  Component type: type

  Description

   An slist is a singly linked list: a list where each element is linked to
   the next element, but not to the previous element. [2][1] That is, it is a
   |stl-Sequence| that supports forward but not backward traversal, and
   (amortized) constant time insertion and removal of elements. Slists, like
   |stl-List|s, have the important property that insertion and splicing do
   not invalidate iterators to list elements, and that even removal
   invalidates only the iterators that point to the elements that are
   removed. The ordering of iterators may be changed (that is,
   slist<T>::iterator might have a different predecessor or successor after a
   list operation than it did before), but the iterators themselves will not
   be invalidated or made to point to different elements unless that
   invalidation or mutation is explicit. [3][2]

   The main difference between slist and |stl-List| is that |stl-List|'s
   iterators are |stl-BidirectionalIterator|, while slist's iterators are
   |stl-ForwardIterator|. This means that slist is less versatile than
   |stl-List|; frequently, however, |stl-BidirectionalIterator| are
   unnecessary. You should usually use slist unless you actually need the
   extra functionality of |stl-List|, because singly linked lists are smaller
   and faster than double linked lists.

   Important performance note: like every other |stl-Sequence|, slist defines
   the member functions insert and erase. Using these member functions
   carelessly, however, can result in disastrously slow programs. The problem
   is that insert's first argument is an iterator pos, and that it inserts
   the new element(s) before pos. This means that insert must find the
   iterator just before pos; this is a constant-time operation for
   |stl-List|, since |stl-List| has bidirectional iterators, but for slist it
   must find that iterator by traversing the list from the beginning up to
   pos. In other words: insert and erase are slow operations anywhere but
   near the beginning of the slist.

   Slist provides the member functions insert_after and erase_after, which
   are constant time operations: you should always use insert_after and
   erase_after whenever possible. If you find that insert_after and
   erase_after aren't adequate for your needs, and that you often need to use
   insert and erase in the middle of the list, then you should probably use
   |stl-List| instead of slist.

  Definition

   Defined in the header |stl-slist|, and in the backward-compatibility header
   |stl-slist|.h. The slist class, and the |stl-slist| header, are an SGI
   extension; they are not part of the C++ standard.

*stl-Slist-example*

 int main() {
   slist<int> L;
   L.push_front(0);
   L.push_front(1);
   L.insert_after(L.begin(), 2);
   |stl-copy|(L.begin(), L.end(),        // The output is 1 2 0
        |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;

   slist<int>::iterator back = L.previous(L.end());
   back = L.insert_after(back, 3);
   back = L.insert_after(back, 4);
   back = L.insert_after(back, 5);
   |stl-copy|(L.begin(), L.end(),        // The output is 1 2 0 3 4 5
        |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;
 }

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |               Description               |     Default      |
   |-----------+-----------------------------------------+------------------|
   | T         | The slist's value type: the type of     |                  |
   |           | object that is stored in the list.      |                  |
   |-----------+-----------------------------------------+------------------|
   | Alloc     | The slist's allocator, used for all     | |stl-Allocators| |
   |           | internal memory management.             |                  |
   +------------------------------------------------------------------------+

  Model of

   |stl-FrontInsertionSequence|

  Type requirements

   None, except for those imposed by the requirements of
   |stl-FrontInsertionSequence|.

  Public base classes

   None.

  Members

+------------------------------------------------------------------------------------------------------------+
|                          Member                           |        Where defined        |   Description    |
|-----------------------------------------------------------+-----------------------------+------------------|
|value_type                                                 ||stl-Container|              |The type of       |
|                                                           |                             |object, T, stored |
|                                                           |                             |in the slist.     |
|-----------------------------------------------------------+-----------------------------+------------------|
|pointer                                                    ||stl-Container|              |Pointer to T.     |
|-----------------------------------------------------------+-----------------------------+------------------|
|reference                                                  ||stl-Container|              |Reference to T    |
|-----------------------------------------------------------+-----------------------------+------------------|
|const_reference                                            ||stl-Container|              |Const reference to|
|                                                           |                             |T                 |
|-----------------------------------------------------------+-----------------------------+------------------|
|size_type                                                  ||stl-Container|              |An unsigned       |
|                                                           |                             |integral type.    |
|-----------------------------------------------------------+-----------------------------+------------------|
|difference_type                                            ||stl-Container|              |A signed integral |
|                                                           |                             |type.             |
|-----------------------------------------------------------+-----------------------------+------------------|
|iterator                                                   ||stl-Container|              |Iterator used to  |
|                                                           |                             |iterate through an|
|                                                           |                             |slist.            |
|-----------------------------------------------------------+-----------------------------+------------------|
|const_iterator                                             ||stl-Container|              |Const iterator    |
|                                                           |                             |used to iterate   |
|                                                           |                             |through an slist. |
|-----------------------------------------------------------+-----------------------------+------------------|
|iterator begin()                                           ||stl-Container|              |Returns an        |
|                                                           |                             |iterator pointing |
|                                                           |                             |to the beginning  |
|                                                           |                             |of the slist.     |
|-----------------------------------------------------------+-----------------------------+------------------|
|iterator end()                                             ||stl-Container|              |Returns an        |
|                                                           |                             |iterator pointing |
|                                                           |                             |to the end of the |
|                                                           |                             |slist.            |
|-----------------------------------------------------------+-----------------------------+------------------|
|const_iterator begin() const                               ||stl-Container|              |Returns a         |
|                                                           |                             |const_iterator    |
|                                                           |                             |pointing to the   |
|                                                           |                             |beginning of the  |
|                                                           |                             |slist.            |
|-----------------------------------------------------------+-----------------------------+------------------|
|const_iterator end() const                                 ||stl-Container|              |Returns a         |
|                                                           |                             |const_iterator    |
|                                                           |                             |pointing to the   |
|                                                           |                             |end of the slist. |
|-----------------------------------------------------------+-----------------------------+------------------|
|size_type size() const                                     ||stl-Container|              |Returns the size  |
|                                                           |                             |of the slist.     |
|                                                           |                             |Note: you should  |
|                                                           |                             |not assume that   |
|                                                           |                             |this function is  |
|                                                           |                             |constant time. It |
|                                                           |                             |is permitted to be|
|                                                           |                             |O(N), where N is  |
|                                                           |                             |the number of     |
|                                                           |                             |elements in the   |
|                                                           |                             |slist. If you wish|
|                                                           |                             |to test whether an|
|                                                           |                             |slist is empty,   |
|                                                           |                             |you should write  |
|                                                           |                             |L.empty() rather  |
|                                                           |                             |than L.size() ==  |
|                                                           |                             |0.                |
|-----------------------------------------------------------+-----------------------------+------------------|
|size_type max_size() const                                 ||stl-Container|              |Returns the       |
|                                                           |                             |largest possible  |
|                                                           |                             |size of the slist.|
|-----------------------------------------------------------+-----------------------------+------------------|
|bool empty() const                                         ||stl-Container|              |true if the       |
|                                                           |                             |slist's size is 0.|
|-----------------------------------------------------------+-----------------------------+------------------|
|slist()                                                    ||stl-Container|              |Creates an empty  |
|                                                           |                             |slist.            |
|-----------------------------------------------------------+-----------------------------+------------------|
|slist(size_type n)                                         ||stl-Sequence|               |Creates an slist  |
|                                                           |                             |with n elements,  |
|                                                           |                             |each of which is a|
|                                                           |                             |copy of T().      |
|-----------------------------------------------------------+-----------------------------+------------------|
|slist(size_type n, const T& t)                             ||stl-Sequence|               |Creates an slist  |
|                                                           |                             |with n copies of  |
|                                                           |                             |t.                |
|-----------------------------------------------------------+-----------------------------+------------------|
|slist(const slist&)                                        ||stl-Container|              |The copy          |
|                                                           |                             |constructor.      |
|-----------------------------------------------------------+-----------------------------+------------------|
|template <class InputIterator>                             ||stl-Sequence|               |Creates an slist  |
|slist(InputIterator f, InputIterator l)                    |                             |with a copy of a  |
|[7][3]                                                     |                             |range.            |
|-----------------------------------------------------------+-----------------------------+------------------|
|~slist()                                                   ||stl-Container|              |The destructor.   |
|-----------------------------------------------------------+-----------------------------+------------------|
|slist& operator=(const slist&)                             ||stl-Container|              |The assignment    |
|                                                           |                             |operator          |
|-----------------------------------------------------------+-----------------------------+------------------|
|void swap(slist&)                                          ||stl-Container|              |Swaps the contents|
|                                                           |                             |of two slists.    |
|-----------------------------------------------------------+-----------------------------+------------------|
|reference front()                                          ||stl-FrontInsertionSequence| |Returns the first |
|                                                           |                             |element.          |
|-----------------------------------------------------------+-----------------------------+------------------|
|const_reference front() const                              ||stl-FrontInsertionSequence| |Returns the first |
|                                                           |                             |element.          |
|-----------------------------------------------------------+-----------------------------+------------------|
|void push_front(const T&)                                  ||stl-FrontInsertionSequence| |Inserts a new     |
|                                                           |                             |element at the    |
|                                                           |                             |beginning.        |
|-----------------------------------------------------------+-----------------------------+------------------|
|void pop_front()                                           ||stl-FrontInsertionSequence| |Removes the first |
|                                                           |                             |element.          |
|-----------------------------------------------------------+-----------------------------+------------------|
|iterator previous(iterator pos)                            |slist                        |See below         |
|-----------------------------------------------------------+-----------------------------+------------------|
|const_iterator previous(const_iterator pos)                |slist                        |See below         |
|-----------------------------------------------------------+-----------------------------+------------------|
|iterator insert(iterator pos, const T& x)                  ||stl-Sequence|               |Inserts x before  |
|                                                           |                             |pos.              |
|-----------------------------------------------------------+-----------------------------+------------------|
|template<class InputIterator>                              ||stl-Sequence|               |Inserts the range |
|void insert(iterator pos, InputIterator f, InputIterator l)|                             |[first, last)     |
|[8][3]                                                     |                             |before pos.       |
|-----------------------------------------------------------+-----------------------------+------------------|
|void insert(iterator pos,                                  ||stl-Sequence|               |Inserts n copies  |
|            size_type n, const value_type& x)              |                             |of x before pos.  |
|-----------------------------------------------------------+-----------------------------+------------------|
|iterator erase(iterator pos)                               ||stl-Sequence|               |Erases the element|
|                                                           |                             |at position pos.  |
|-----------------------------------------------------------+-----------------------------+------------------|
|iterator erase(iterator first, iterator last)              ||stl-Sequence|               |Erases the range  |
|                                                           |                             |[first, last)     |
|-----------------------------------------------------------+-----------------------------+------------------|
|void clear()                                               ||stl-Sequence|               |Erases all of the |
|                                                           |                             |elements.         |
|-----------------------------------------------------------+-----------------------------+------------------|
|void resize(n, t = T())                                    ||stl-Sequence|               |Inserts or erases |
|                                                           |                             |elements at the   |
|                                                           |                             |end such that the |
|                                                           |                             |size becomes n.   |
|-----------------------------------------------------------+-----------------------------+------------------|
|iterator insert_after(iterator pos)                        |slist                        |See below.        |
|-----------------------------------------------------------+-----------------------------+------------------|
|iterator insert_after(iterator pos, const value_type& x)   |slist                        |See below.        |
|-----------------------------------------------------------+-----------------------------+------------------|
|template<class InputIterator>                              |slist                        |See below.        |
|void insert_after(iterator pos,                            |                             |                  |
|                  InputIterator f, InputIterator l)        |                             |                  |
|-----------------------------------------------------------+-----------------------------+------------------|
|void insert_after(iterator pos,                            |slist                        |See below.        |
|                  size_type n, const value_type& x)        |                             |                  |
|-----------------------------------------------------------+-----------------------------+------------------|
|iterator erase_after(iterator pos)                         |slist                        |See below.        |
|-----------------------------------------------------------+-----------------------------+------------------|
|iterator erase_after(iterator before_first, iterator last) |slist                        |See below.        |
|-----------------------------------------------------------+-----------------------------+------------------|
|void splice(iterator position, slist& L)                   |slist                        |See below.        |
|-----------------------------------------------------------+-----------------------------+------------------|
|void splice(iterator position, slist& L, iterator i)       |slist                        |See below.        |
|-----------------------------------------------------------+-----------------------------+------------------|
|void splice(iterator position, slist& L, iterator f,       |slist                        |See below.        |
|iterator l)                                                |                             |                  |
|-----------------------------------------------------------+-----------------------------+------------------|
|void splice_after(iterator pos, iterator prev)             |slist                        |See below.        |
|-----------------------------------------------------------+-----------------------------+------------------|
|void splice_after(iterator pos,                            |slist                        |See below.        |
|                  iterator before_first,                   |                             |                  |
|                  iterator before_last)                    |                             |                  |
|-----------------------------------------------------------+-----------------------------+------------------|
|void remove(const T& value)                                |slist                        |See below.        |
|-----------------------------------------------------------+-----------------------------+------------------|
|void unique()                                              |slist                        |See below.        |
|-----------------------------------------------------------+-----------------------------+------------------|
|void merge(slist& L)                                       |slist                        |See below.        |
|-----------------------------------------------------------+-----------------------------+------------------|
|void sort()                                                |slist                        |See below.        |
|-----------------------------------------------------------+-----------------------------+------------------|
|bool operator==(const slist&,                              ||stl-ForwardContainer|       |Tests two slists  |
|                const slist&)                              |                             |for equality. This|
|                                                           |                             |is a global       |
|                                                           |                             |function, not a   |
|                                                           |                             |member function.  |
|-----------------------------------------------------------+-----------------------------+------------------|
|bool operator<(const slist&,                               ||stl-ForwardContainer|       |Lexicographical   |
|               const slist&)                               |                             |comparison. This  |
|                                                           |                             |is a global       |
|                                                           |                             |function, not a   |
|                                                           |                             |member function.  |
+------------------------------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-FrontInsertionSequence|
   requirements, but are specific to slist:

+------------------------------------------------------------------------------+
|                     Function                      |       Description        |
|---------------------------------------------------+--------------------------|
|iterator previous(iterator pos)                    |pos must be a valid       |
|                                                   |iterator in *this. The    |
|                                                   |return value is an        |
|                                                   |iterator prev such that   |
|                                                   |++prev == pos. Complexity:|
|                                                   |linear in the number of   |
|                                                   |iterators in the range    |
|                                                   |[begin(), pos).           |
|---------------------------------------------------+--------------------------|
|const_iterator previous(const_iterator pos)        |pos must be a valid       |
|                                                   |iterator in *this. The    |
|                                                   |return value is an        |
|                                                   |iterator prev such that   |
|                                                   |++prev == pos. Complexity:|
|                                                   |linear in the number of   |
|                                                   |iterators in the range    |
|                                                   |[begin(), pos).           |
|---------------------------------------------------+--------------------------|
|iterator insert_after(iterator pos)                |pos must be a             |
|                                                   |dereferenceable iterator  |
|                                                   |in *this. (That is, pos   |
|                                                   |may not be end().) Inserts|
|                                                   |a copy of T() immediately |
|                                                   |following pos. The return |
|                                                   |value is an iterator that |
|                                                   |points to the new element.|
|                                                   |Complexity: constant time.|
|---------------------------------------------------+--------------------------|
|iterator insert_after(iterator pos,                |pos must be a             |
|                      const value_type& x)         |dereferenceable iterator  |
|                                                   |in *this. (That is, pos   |
|                                                   |may not be end().) Inserts|
|                                                   |a copy of x immediately   |
|                                                   |following pos. The return |
|                                                   |value is an iterator that |
|                                                   |points to the new element.|
|                                                   |Complexity: constant time.|
|---------------------------------------------------+--------------------------|
|template<class InputIterator>                      |Inserts elements from the |
|void insert_after(iterator pos,                    |range [f, l) immediately  |
|                  InputIterator f, InputIterator l)|following pos. Complexity:|
|                                                   |linear in last - first.   |
|---------------------------------------------------+--------------------------|
|void insert_after(iterator pos,                    |Inserts n copies of x     |
|                  size_type n, const value_type& x)|immediately following pos.|
|                                                   |Complexity: linear in n.  |
|---------------------------------------------------+--------------------------|
|iterator erase_after(iterator pos)                 |Erases the element pointed|
|                                                   |to by the iterator        |
|                                                   |following pos. Complexity:|
|                                                   |constant time.            |
|---------------------------------------------------+--------------------------|
|iterator erase_after(iterator before_first,        |Erases all elements in the|
|iterator last)                                     |range [before_first + 1,  |
|                                                   |last). Complexity: linear |
|                                                   |in last - (before_first + |
|                                                   |1).                       |
|---------------------------------------------------+--------------------------|
|void splice(iterator position,                     |position must be a valid  |
|            slist<T, Alloc>& x);                   |iterator in *this, and x  |
|                                                   |must be an slist that is  |
|                                                   |distinct from *this. (That|
|                                                   |is, it is required that &x|
|                                                   |!= this.) All of the      |
|                                                   |elements of x are inserted|
|                                                   |before position and       |
|                                                   |removed from x. All       |
|                                                   |iterators remain valid,   |
|                                                   |including iterators that  |
|                                                   |point to elements of x.   |
|                                                   |[9][4] Complexity:        |
|                                                   |proportional to c1        |
|                                                   |(position - begin()) +    |
|                                                   |c2(x.size()), where c1 and|
|                                                   |c2 are unknown constants. |
|---------------------------------------------------+--------------------------|
|                                                   |position must be a valid  |
|void splice(iterator position,                     |iterator in *this, and i  |
|            slist<T, Alloc>& x,                    |must be a dereferenceable |
|            iterator i);                           |iterator in x. Splice     |
|                                                   |moves the element pointed |
|                                                   |to by i from x to *this,  |
|                                                   |inserting it before       |
|                                                   |position. All iterators   |
|                                                   |remain valid, including   |
|                                                   |iterators that point to   |
|                                                   |elements of x. [10][4] If |
|                                                   |position == i or position |
|                                                   |== ++i, this function is a|
|                                                   |null operation.           |
|                                                   |Complexity: proportional  |
|                                                   |to c1 (position - begin())|
|                                                   |+ c2 (i - x.begin()),     |
|                                                   |where c1 and c2 are       |
|                                                   |unknown constants.        |
|---------------------------------------------------+--------------------------|
|                                                   |position must be a valid  |
|void splice(iterator position,                     |iterator in *this, and    |
|            slist<T, Alloc>& x,                    |[first, last) must be a   |
|            iterator f, iterator l);               |valid range in x. position|
|                                                   |may not be an iterator in |
|                                                   |the range [first, last).  |
|                                                   |Splice moves the elements |
|                                                   |in [first, last) from x to|
|                                                   |*this, inserting them     |
|                                                   |before position. All      |
|                                                   |iterators remain valid,   |
|                                                   |including iterators that  |
|                                                   |point to elements of x.   |
|                                                   |[11][4] Complexity:       |
|                                                   |proportional to c1        |
|                                                   |(position - begin()) + c2 |
|                                                   |(f - x.begin()) + c3 (l - |
|                                                   |f), where c1, c2, and c3  |
|                                                   |are unknown constants.    |
|---------------------------------------------------+--------------------------|
|void remove(const T& val);                         |Removes all elements that |
|                                                   |compare equal to val. The |
|                                                   |relative order of elements|
|                                                   |that are not removed is   |
|                                                   |unchanged, and iterators  |
|                                                   |to elements that are not  |
|                                                   |removed remain valid. This|
|                                                   |function is linear time:  |
|                                                   |it performs exactly size()|
|                                                   |comparisons for equality. |
|---------------------------------------------------+--------------------------|
|void splice_after(iterator pos, iterator prev)     |pos must be a             |
|                                                   |dereferenceable iterator  |
|                                                   |in *this, and prev must be|
|                                                   |a dereferenceable iterator|
|                                                   |either in *this or in some|
|                                                   |other slist. (Note:       |
|                                                   |"dereferenceable iterator"|
|                                                   |implies that neither pos  |
|                                                   |nor prev may be an        |
|                                                   |off-the-end iterator.)    |
|                                                   |Moves the element         |
|                                                   |following prev to *this,  |
|                                                   |inserting it immediately  |
|                                                   |after pos. Complexity:    |
|                                                   |constant time.            |
|---------------------------------------------------+--------------------------|
|void splice_after(iterator pos,                    |pos must be a             |
|                  iterator before_first,           |dereferenceable iterator  |
|                  iterator before_last)            |in *this, and before_first|
|                                                   |and before_last must be   |
|                                                   |dereferenceable iterators |
|                                                   |either in *this or in some|
|                                                   |other slist. (Note:       |
|                                                   |"dereferenceable iterator"|
|                                                   |implies that none of these|
|                                                   |iterators may be          |
|                                                   |off-the-end iterators.)   |
|                                                   |Moves the elements in the |
|                                                   |range [before_first + 1,  |
|                                                   |before_last + 1) to *this,|
|                                                   |inserting them immediately|
|                                                   |after pos. Complexity:    |
|                                                   |constant time.            |
|---------------------------------------------------+--------------------------|
|template<class |stl-Predicate|>                    |Removes all elements *i   |
|void remove_if(|stl-Predicate| p);                 |such that p(*i) is true.  |
|[12][5]                                            |The relative order of     |
|                                                   |elements that are not     |
|                                                   |removed is unchanged, and |
|                                                   |iterators to elements that|
|                                                   |are not removed remain    |
|                                                   |valid. This function is   |
|                                                   |linear time: it performs  |
|                                                   |exactly size()            |
|                                                   |applications of p.        |
|---------------------------------------------------+--------------------------|
|void unique();                                     |Removes all but the first |
|                                                   |element in every          |
|                                                   |consecutive group of equal|
|                                                   |elements. The relative    |
|                                                   |order of elements that are|
|                                                   |not removed is unchanged, |
|                                                   |and iterators to elements |
|                                                   |that are not removed      |
|                                                   |remain valid. This        |
|                                                   |function is linear time:  |
|                                                   |it performs exactly size()|
|                                                   |- 1 comparisons for       |
|                                                   |equality.                 |
|---------------------------------------------------+--------------------------|
|template<class |stl-BinaryPredicate|>              |Removes all but the first |
|void unique(|stl-BinaryPredicate| p);              |element in every          |
|[13][5]                                            |consecutive group of      |
|                                                   |equivalent elements, where|
|                                                   |two elements *i and *j are|
|                                                   |considered equivalent if  |
|                                                   |p(*i, *j) is true. The    |
|                                                   |relative order of elements|
|                                                   |that are not removed is   |
|                                                   |unchanged, and iterators  |
|                                                   |to elements that are not  |
|                                                   |removed remain valid. This|
|                                                   |function is linear time:  |
|                                                   |it performs exactly size()|
|                                                   |- 1 comparisons for       |
|                                                   |equality.                 |
|---------------------------------------------------+--------------------------|
|void merge(slist<T, Alloc>& x);                    |Both *this and x must be  |
|                                                   |sorted according to       |
|                                                   |operator<, and they must  |
|                                                   |be distinct. (That is, it |
|                                                   |is required that &x !=    |
|                                                   |this.) This function      |
|                                                   |removes all of x's        |
|                                                   |elements and inserts them |
|                                                   |in order into *this. The  |
|                                                   |merge is stable; that is, |
|                                                   |if an element from *this  |
|                                                   |is equivalent to one from |
|                                                   |x, then the element from  |
|                                                   |*this will precede the one|
|                                                   |from x. All iterators to  |
|                                                   |elements in *this and x   |
|                                                   |remain valid. This        |
|                                                   |function is linear time:  |
|                                                   |it performs at most size()|
|                                                   |+ x.size() - 1            |
|                                                   |comparisons.              |
|---------------------------------------------------+--------------------------|
|template<class |stl-BinaryPredicate|>              |Comp must be a comparison |
|void merge(slist<T, Alloc>& x,                     |function that induces a   |
|           BinaryPredicate Comp);                  |strict weak ordering (as  |
|[14][5]                                            |defined in the            |
|                                                   ||stl-LessThanComparable|  |
|                                                   |requirements) on objects  |
|                                                   |of type T, and both *this |
|                                                   |and x must be sorted      |
|                                                   |according to that         |
|                                                   |ordering. The slists x and|
|                                                   |*this must be distinct.   |
|                                                   |(That is, it is required  |
|                                                   |that &x != this.) This    |
|                                                   |function removes all of   |
|                                                   |x's elements and inserts  |
|                                                   |them in order into *this. |
|                                                   |The merge is stable; that |
|                                                   |is, if an element from    |
|                                                   |*this is equivalent to one|
|                                                   |from x, then the element  |
|                                                   |from *this will precede   |
|                                                   |the one from x. All       |
|                                                   |iterators to elements in  |
|                                                   |*this and x remain valid. |
|                                                   |This function is linear   |
|                                                   |time: it performs at most |
|                                                   |size() + x.size() - 1     |
|                                                   |applications of Comp.     |
|---------------------------------------------------+--------------------------|
|void reverse();                                    |Reverses the order of     |
|                                                   |elements in the slist. All|
|                                                   |iterators remain valid and|
|                                                   |continue to point to the  |
|                                                   |same elements. [15][6]    |
|                                                   |This function is linear   |
|                                                   |time.                     |
|---------------------------------------------------+--------------------------|
|void sort();                                       |Sorts *this according to  |
|                                                   |operator<. The sort is    |
|                                                   |stable, that is, the      |
|                                                   |relative order of         |
|                                                   |equivalent elements is    |
|                                                   |preserved. All iterators  |
|                                                   |remain valid and continue |
|                                                   |to point to the same      |
|                                                   |elements. [16][7] The     |
|                                                   |number of comparisons is  |
|                                                   |approximately N log N,    |
|                                                   |where N is the slist's    |
|                                                   |size.                     |
|---------------------------------------------------+--------------------------|
|template<class |stl-BinaryPredicate|>              |Comp must be a comparison |
|void sort(BinaryPredicate comp);                   |function that induces a   |
|[17][5]                                            |strict weak ordering (as  |
|                                                   |defined in the            |
|                                                   ||stl-LessThanComparable|  |
|                                                   |requirements) on objects  |
|                                                   |of type T. This function  |
|                                                   |sorts the slist *this     |
|                                                   |according to Comp. The    |
|                                                   |sort is stable, that is,  |
|                                                   |the relative order of     |
|                                                   |equivalent elements is    |
|                                                   |preserved. All iterators  |
|                                                   |remain valid and continue |
|                                                   |to point to the same      |
|                                                   |elements. [18][7] The     |
|                                                   |number of comparisons is  |
|                                                   |approximately N log N,    |
|                                                   |where N is the slist's    |
|                                                   |size.                     |
+------------------------------------------------------------------------------+

  Notes

   [1] The lists in such languages as Common Lisp, Scheme, and ML are singly
   linked lists. In some programming languages, almost all data structures
   are represented as singly linked lists.

   [2] A comparison with |stl-Vector| is instructive. Suppose that i is a
   valid |stl-Vector|<T>::iterator. If an element is inserted or removed in a
   position that precedes i, then this operation will either result in i
   pointing to a different element than it did before, or else it will
   invalidate i entirely. (A |stl-Vector|<T>::iterator will be invalidated,
   for example, if an insertion requires a reallocation.) However, suppose
   that i and j are both iterators into a |stl-Vector|, and there exists some
   integer n such that i == j + n. In that case, even if elements are
   inserted into the vector and i and j point to different elements, the
   relation between the two iterators will still hold. An slist is exactly
   the opposite: iterators will not be invalidated, and will not be made to
   point to different elements, but, for slist iterators, the
   predecessor/successor relationship is not invariant.

   [3] This member function relies on member template functions, which at
   present (early 1998) are not supported by all compilers. If your compiler
   supports member templates, you can call this function with any type of
   |stl-InputIterator|. If your compiler does not yet support member
   templates, though, then the arguments must either be of type const
   value_type* or of type slist::const_iterator.

   [4] A similar property holds for all versions of insert() and erase().
   Slist<T, Alloc>::insert() never invalidates any iterators, and slist<T,
   Alloc>::erase() only invalidates iterators pointing to the elements that
   are actually being erased.

   [5] This member function relies on member template functions, which at
   present (early 1998) are not supported by all compilers. You can only use
   this member function if your compiler supports member templates.

   [6] The |stl-reverse| algorithm works only for
   |stl-BidirectionalIterator|. Even if |stl-reverse| were extended to work
   with |stl-ForwardIterator|, however, it would still be useful to have the
   reverse member function: it has different iterator invalidation semantics.
   That is, the reverse member function preserves the value that each
   iterator points to. Note also that the algorithm |stl-reverse|(L.begin(),
   L.end()) uses T's assignment operator, but the member function L.reverse()
   does not.

   [7] The |stl-sort| algorithm works only for |stl-RandomAccessIterator|. In
   principle, however, it would be possible to write a sort algorithm that
   also accepted |stl-ForwardIterator|. Even if there were such a version of
   |stl-sort|, it would still be useful for slist to have a sort member
   function. That is, sort is provided as a member function not only for the
   sake of efficiency, but also because of the property that it preserves the
   values that list iterators point to.

  See also

   |stl-BidirectionalIterator|, |stl-ReversibleContainer|, |stl-Sequence|,
   |stl-List|, |stl-Vector|

*stl-bit_vector*

                                   bit_vector

   Category: containers                                  Component type: type

  Description

   A bit_vector is essentially a |stl-Vector|<bool>: it is a |stl-Sequence|
   that has the same interface as |stl-Vector|. The main difference is that
   bit_vector is optimized for space efficiency. A vector always requires at
   least one byte per element, but a bit_vector only requires one bit per
   element.

   Warning: The name bit_vector will be removed in a future release of the
   STL. The only reason that bit_vector is a separate class, instead of a
   template specialization of vector<bool>, is that this would require
   partial specialization of templates. On compilers that support partial
   specialization, bit_vector is a specialization of vector<bool>. The name
   bit_vector is a typedef. This typedef is not defined in the C++ standard,
   and is retained only for backward compatibility.

*stl-bit_vector-example*

 bit_vector V(5);
 V[0] = true;
 V[1] = false;
 V[2] = false;
 V[3] = true;
 V[4] = false;

 for (bit_vector::iterator i = V.begin(); i < V.end(); ++i)
   cout << (*i ? '1' : '0');
 cout << endl;

  Definition

   Defined in the standard header |stl-vector|, and in the nonstandard
   backward-compatibility header [3]bvector.h.

  Template parameters

   None. Bit_vector is not a class template.

  Model of

   |stl-RandomAccessContainer|, |stl-BackInsertionSequence|.

  Type requirements

   None.

  Public base classes

   None.

  Members

+----------------------------------------------------------------------------------------------------+
|                   Member                    |       Where defined        |       Description       |
|---------------------------------------------+----------------------------+-------------------------|
|value_type                                   ||stl-Container|             |The type of object stored|
|                                             |                            |in the bit_vector: bool  |
|---------------------------------------------+----------------------------+-------------------------|
|reference                                    |bit_vector                  |A proxy class that acts  |
|                                             |                            |as a reference to a      |
|                                             |                            |single bit. See below for|
|                                             |                            |details.                 |
|---------------------------------------------+----------------------------+-------------------------|
|const_reference                              ||stl-Container|             |Const reference to       |
|                                             |                            |value_type. In bit_vector|
|                                             |                            |this is simply defined to|
|                                             |                            |be bool.                 |
|---------------------------------------------+----------------------------+-------------------------|
|size_type                                    ||stl-Container|             |An unsigned integral     |
|                                             |                            |type.                    |
|---------------------------------------------+----------------------------+-------------------------|
|difference_type                              ||stl-Container|             |A signed integral type.  |
|---------------------------------------------+----------------------------+-------------------------|
|iterator                                     ||stl-Container|             |Iterator used to iterate |
|                                             |                            |through a bit_vector.    |
|---------------------------------------------+----------------------------+-------------------------|
|const_iterator                               ||stl-Container|             |Const iterator used to   |
|                                             |                            |iterate through a        |
|                                             |                            |bit_vector.              |
|---------------------------------------------+----------------------------+-------------------------|
|reverse_iterator                             ||stl-ReversibleContainer|   |Iterator used to iterate |
|                                             |                            |backwards through a      |
|                                             |                            |bit_vector.              |
|---------------------------------------------+----------------------------+-------------------------|
|const_reverse_iterator                       ||stl-ReversibleContainer|   |Const iterator used to   |
|                                             |                            |iterate backwards through|
|                                             |                            |a bit_vector.            |
|---------------------------------------------+----------------------------+-------------------------|
|iterator begin()                             ||stl-Container|             |Returns an iterator      |
|                                             |                            |pointing to the beginning|
|                                             |                            |of the bit_vector.       |
|---------------------------------------------+----------------------------+-------------------------|
|iterator end()                               ||stl-Container|             |Returns an iterator      |
|                                             |                            |pointing to the end of   |
|                                             |                            |the bit_vector.          |
|---------------------------------------------+----------------------------+-------------------------|
|const_iterator begin() const                 ||stl-Container|             |Returns a const_iterator |
|                                             |                            |pointing to the beginning|
|                                             |                            |of the bit_vector.       |
|---------------------------------------------+----------------------------+-------------------------|
|const_iterator end() const                   ||stl-Container|             |Returns a const_iterator |
|                                             |                            |pointing to the end of   |
|                                             |                            |the bit_vector.          |
|---------------------------------------------+----------------------------+-------------------------|
|reverse_iterator rbegin()                    ||stl-ReversibleContainer|   |Returns a                |
|                                             |                            |reverse_iterator pointing|
|                                             |                            |to the beginning of the  |
|                                             |                            |reversed bit_vector.     |
|---------------------------------------------+----------------------------+-------------------------|
|reverse_iterator rend()                      ||stl-ReversibleContainer|   |Returns a                |
|                                             |                            |reverse_iterator pointing|
|                                             |                            |to the end of the        |
|                                             |                            |reversed bit_vector.     |
|---------------------------------------------+----------------------------+-------------------------|
|const_reverse_iterator rbegin() const        ||stl-ReversibleContainer|   |Returns a                |
|                                             |                            |const_reverse_iterator   |
|                                             |                            |pointing to the beginning|
|                                             |                            |of the reversed          |
|                                             |                            |bit_vector.              |
|---------------------------------------------+----------------------------+-------------------------|
|const_reverse_iterator rend() const          ||stl-ReversibleContainer|   |Returns a                |
|                                             |                            |const_reverse_iterator   |
|                                             |                            |pointing to the end of   |
|                                             |                            |the reversed bit_vector. |
|---------------------------------------------+----------------------------+-------------------------|
|size_type size() const                       ||stl-Container|             |Returns the number of    |
|                                             |                            |elements in the          |
|                                             |                            |bit_vector.              |
|---------------------------------------------+----------------------------+-------------------------|
|size_type max_size() const                   ||stl-Container|             |Returns the largest      |
|                                             |                            |possible size of the     |
|                                             |                            |bit_vector.              |
|---------------------------------------------+----------------------------+-------------------------|
|size_type capacity() const                   |bit_vector                  |See below.               |
|---------------------------------------------+----------------------------+-------------------------|
|bool empty() const                           ||stl-Container|             |true if the bit_vector's |
|                                             |                            |size is 0.               |
|---------------------------------------------+----------------------------+-------------------------|
|reference operator[](size_type n)            ||stl-RandomAccessContainer| |Returns the n'th element.|
|---------------------------------------------+----------------------------+-------------------------|
|const_reference operator[](size_type n) const||stl-RandomAccessContainer| |Returns the n'th element.|
|---------------------------------------------+----------------------------+-------------------------|
|bit_vector()                                 ||stl-Container|             |Creates an empty         |
|                                             |                            |bit_vector.              |
|---------------------------------------------+----------------------------+-------------------------|
|bit_vector(size_type n)                      ||stl-Sequence|              |Creates a bit_vector with|
|                                             |                            |n elements.              |
|---------------------------------------------+----------------------------+-------------------------|
|bit_vector(size_type n, bool t)              ||stl-Sequence|              |Creates a bit_vector with|
|                                             |                            |n copies of t.           |
|---------------------------------------------+----------------------------+-------------------------|
|bit_vector(const bit_vector&)                ||stl-Container|             |The copy constructor.    |
|---------------------------------------------+----------------------------+-------------------------|
|template <class |stl-InputIterator|>         ||stl-Sequence|              |Creates a bit_vector with|
|bit_vector(InputIterator, InputIterator)     |                            |a copy of a range.       |
|[4][1]                                       |                            |                         |
|---------------------------------------------+----------------------------+-------------------------|
|~bit_vector()                                ||stl-Container|             |The destructor.          |
|---------------------------------------------+----------------------------+-------------------------|
|bit_vector& operator=(const bit_vector&)     ||stl-Container|             |The assignment operator  |
|---------------------------------------------+----------------------------+-------------------------|
|void reserve(size_t)                         |bit_vector                  |See below.               |
|---------------------------------------------+----------------------------+-------------------------|
|reference front()                            ||stl-Sequence|              |Returns the first        |
|                                             |                            |element.                 |
|---------------------------------------------+----------------------------+-------------------------|
|const_reference front() const                ||stl-Sequence|              |Returns the first        |
|                                             |                            |element.                 |
|---------------------------------------------+----------------------------+-------------------------|
|reference back()                             ||stl-BackInsertionSequence| |Returns the last element.|
|---------------------------------------------+----------------------------+-------------------------|
|const_reference back() const                 ||stl-BackInsertionSequence| |Returns the last element.|
|---------------------------------------------+----------------------------+-------------------------|
|void push_back(const T&)                     ||stl-BackInsertionSequence| |Inserts a new element at |
|                                             |                            |the end.                 |
|---------------------------------------------+----------------------------+-------------------------|
|void pop_back()                              ||stl-BackInsertionSequence| |Removes the last element.|
|---------------------------------------------+----------------------------+-------------------------|
|void swap(bit_vector&)                       ||stl-Container|             |Swaps the contents of two|
|                                             |                            |bit_vectors.             |
|---------------------------------------------+----------------------------+-------------------------|
|void swap(bit_vector::reference x,           |bit_vector                  |See below.               |
|          bit_vector::reference y)           |                            |                         |
|---------------------------------------------+----------------------------+-------------------------|
|iterator insert(iterator pos, bool x)        ||stl-Sequence|              |Inserts x before pos.    |
|---------------------------------------------+----------------------------+-------------------------|
|template <class |stl-InputIterator|>         ||stl-Sequence|              |Inserts the range [f, l) |
|void insert(iterator pos,                    |                            |before pos.              |
|            InputIterator f, InputIterator l)|                            |                         |
|[5][1]                                       |                            |                         |
|---------------------------------------------+----------------------------+-------------------------|
|void insert(iterator pos,                    ||stl-Sequence|              |Inserts n copies of x    |
|            size_type n, bool x)             |                            |before pos.              |
|---------------------------------------------+----------------------------+-------------------------|
|void erase(iterator pos)                     ||stl-Sequence|              |Erases the element at    |
|                                             |                            |position pos.            |
|---------------------------------------------+----------------------------+-------------------------|
|void erase(iterator first, iterator last)    ||stl-Sequence|              |Erases the range [first, |
|                                             |                            |last)                    |
|---------------------------------------------+----------------------------+-------------------------|
|void clear()                                 ||stl-Sequence|              |Erases all of the        |
|                                             |                            |elements.                |
|---------------------------------------------+----------------------------+-------------------------|
|bool operator==(const bit_vector&,           ||stl-ForwardContainer|      |Tests two bit_vectors for|
|                const bit_vector&)           |                            |equality. This is a      |
|                                             |                            |global function, not a   |
|                                             |                            |member function.         |
|---------------------------------------------+----------------------------+-------------------------|
|bool operator<(const bit_vector&,            ||stl-ForwardContainer|      |Lexicographical          |
|               const bit_vector&)            |                            |comparison. This is a    |
|                                             |                            |global function, not a   |
|                                             |                            |member function.         |
+----------------------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-RandomAccessContainer| and
   |stl-BackInsertionSequence| requirements, but are specific to vector.

   +------------------------------------------------------------------------+
   |              Member              |             Description             |
   |----------------------------------+-------------------------------------|
   | reference                        | A proxy class that acts as a        |
   |                                  | reference to a single bit; the      |
   |                                  | reason it exists is to allow        |
   |                                  | expressions like V[0] = true. (A    |
   |                                  | proxy class like this is necessary, |
   |                                  | because the C++ memory model does   |
   |                                  | not include independent addressing  |
   |                                  | of objects smaller than one byte.)  |
   |                                  | The public member functions of      |
   |                                  | reference are operator bool()       |
   |                                  | const, reference& operator=(bool),  |
   |                                  | and void flip(). That is, reference |
   |                                  | acts like an ordinary reference:    |
   |                                  | you can convert a reference to      |
   |                                  | bool, assign a bool value through a |
   |                                  | reference, or flip the bit that a   |
   |                                  | reference refers to.                |
   |----------------------------------+-------------------------------------|
   | size_type capacity() const       | Number of bits for which memory has |
   |                                  | been allocated. capacity() is       |
   |                                  | always greater than or equal to     |
   |                                  | size(). [6][2] [7][3]               |
   |----------------------------------+-------------------------------------|
   | void reserve(size_type n)        | If n is less than or equal to       |
   |                                  | capacity(), this call has no        |
   |                                  | effect. Otherwise, it is a request  |
   |                                  | for the allocation of additional    |
   |                                  | memory. If the request is           |
   |                                  | successful, then capacity() is      |
   |                                  | greater than or equal to n;         |
   |                                  | otherwise, capacity() is unchanged. |
   |                                  | In either case, size() is           |
   |                                  | unchanged. [8][2] [9][4]            |
   |----------------------------------+-------------------------------------|
   |void swap(bit_vector::reference x,| Swaps the bits referred to by x and |
   |          bit_vector::reference y)| y. This is a global function, not a |
   |                                  | member function. It is necessary    |
   |                                  | because the ordinary version of     |
   |                                  | |stl-swap| takes arguments of type  |
   |                                  | T&, and bit_vector::reference is a  |
   |                                  | class, not a built-in C++           |
   |                                  | reference.                          |
   +------------------------------------------------------------------------+

  Notes

   [1] This member function relies on member template functions, which at
   present (early 1998) are not supported by all compilers. If your compiler
   supports member templates, you can call this function with any type of
   |stl-InputIterator|. If your compiler does not yet support member
   templates, though, then the arguments must either be of type const bool*
   or of type bit_vector::const_iterator.

   [2] Memory will be reallocated automatically if more than capacity() -
   size() bits are inserted into the bit_vector. Reallocation does not change
   size(), nor does it change the values of any bits of the bit_vector. It
   does, however, increase capacity(), and it invalidates [10][5] any
   iterators that point into the bit_vector.

   [3] When it is necessary to increase capacity(), bit_vector usually
   increases it by a factor of two. It is crucial that the amount of growth
   is proportional to the current capacity(), rather than a fixed constant:
   in the former case inserting a series of bits into a bit_vector is a
   linear time operation, and in the latter case it is quadratic.

   [4] reserve() is used to cause a reallocation manually. The main reason
   for using reserve() is efficiency: if you know the capacity to which your
   bit_vector must eventually grow, then it is probably more efficient to
   allocate that memory all at once rather than relying on the automatic
   reallocation scheme. The other reason for using reserve() is to control
   the invalidation of iterators. [11][5]

   [5] A bit_vector's iterators are invalidated when its memory is
   reallocated. Additionally, inserting or deleting a bit in the middle of a
   bit_vector invalidates all iterators that point to bits following the
   insertion or deletion point. It follows that you can prevent a
   bit_vector's iterators from being invalidated if you use reserve() to
   preallocate as much storage as the bit_vector will ever use, and if all
   insertions and deletions are at the bit_vector's end.

  See also

   |stl-Vector|


        ________________________________________________________________________
                                Associative Containers
*stl-set*

                            set<Key, Compare, Alloc>

   Category: containers                                  Component type: type

  Description

   Set is a |stl-SortedAssociativeContainer| that stores objects of type Key.
   Set is a |stl-SimpleAssociativeContainer|, meaning that its value type, as
   well as its key type, is Key. It is also a
   |stl-UniqueAssociativeContainer|, meaning that no two elements are the
   same.

   Set and |stl-multiset| are particularly well suited to the set algorithms
   |stl-includes|, |stl-set_union|, |stl-set_intersection|,
   |stl-set_difference|, and |stl-set_symmetric_difference|. The reason for
   this is twofold. First, the set algorithms require their arguments to be
   sorted ranges, and, since |stl-set| and |stl-multiset| are
   |stl-SortedAssociativeContainer|, their elements are always sorted in
   ascending order. Second, the output range of these algorithms is always
   sorted, and inserting a sorted range into a set or multiset is a fast
   operation: the |stl-UniqueSortedAssociativeContainer| and
   |stl-MultipleSortedAssociativeContainer| requirements guarantee that
   inserting a range takes only linear time if the range is already sorted.

   Set has the important property that inserting a new element into a set
   does not invalidate iterators that point to existing elements. Erasing an
   element from a set also does not invalidate any iterators, except, of
   course, for iterators that actually point to the element that is being
   erased.

*stl-set-example*

 struct ltstr
 {
   bool operator()(const char* s1, const char* s2) const
   {
     return strcmp(s1, s2) < 0;
   }
 };

 int main()
 {
   const int N = 6;
   const char* a[N] = {"isomer", "ephemeral", "prosaic",
                       "nugatory", "artichoke", "serif"};
   const char* b[N] = {"flat", "this", "artichoke",
                       "frigate", "prosaic", "isomer"};

   set<const char*, ltstr> A(a, a + N);
   set<const char*, ltstr> B(b, b + N);
   set<const char*, ltstr> C;

   cout << "Set A: ";
   |stl-copy|(A.begin(), A.end(), |stl-ostream_iterator|<const char*>(cout, " "));
   cout << endl;
   cout << "Set B: ";
   |stl-copy|(B.begin(), B.end(), |stl-ostream_iterator|<const char*>(cout, " "));
   cout << endl;

   cout << "Union: ";
   |stl-set_union|(A.begin(), A.end(), B.begin(), B.end(),
             |stl-ostream_iterator|<const char*>(cout, " "),
             ltstr());
   cout << endl;

   cout << "Intersection: ";
   |stl-set_intersection|(A.begin(), A.end(), B.begin(), B.end(),
                    |stl-ostream_iterator|<const char*>(cout, " "),
                    ltstr());
   cout << endl;

   |stl-set_difference|(A.begin(), A.end(), B.begin(), B.end(),
                  |stl-insert_iterator|(C, C.begin()),
                  ltstr());
   cout << "Set C (difference of A and B): ";
   |stl-copy|(C.begin(), C.end(), |stl-ostream_iterator|<const char*>(cout, " "));
   cout << endl;
 }

  Definition

   Defined in the standard header |stl-set|, and in the nonstandard
   backward-compatibility header |stl-set|.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |               Description               |     Default      |
   |-----------+-----------------------------------------+------------------|
   | Key       | The set's key type and value type. This |                  |
   |           | is also defined as set::key_type and    |                  |
   |           | set::value_type                         |                  |
   |-----------+-----------------------------------------+------------------|
   | Compare   | The key comparison function, a          | |stl-less|<Key>  |
   |           | |stl-StrictWeakOrdering| whose argument |                  |
   |           | type is key_type; it returns true if    |                  |
   |           | its first argument is less than its     |                  |
   |           | second argument, and false otherwise.   |                  |
   |           | This is also defined as                 |                  |
   |           | set::key_compare and                    |                  |
   |           | set::value_compare.                     |                  |
   |-----------+-----------------------------------------+------------------|
   | Alloc     | The set's allocator, used for all       | |stl-Allocators| |
   |           | internal memory management.             |                  |
   +------------------------------------------------------------------------+

  Model of

   |stl-UniqueSortedAssociativeContainer|, |stl-SimpleAssociativeContainer|

  Type requirements

     * Key is |stl-Assignable|.
     * Compare is a |stl-StrictWeakOrdering| whose argument type is Key.
     * Alloc is an |stl-Allocators|.

  Public base classes

   None.

  Members

+-----------------------------------------------------------------------------------------------------------+
|                 Member                  |             Where defined             |       Description       |
|-----------------------------------------+---------------------------------------+-------------------------|
|value_type                               ||stl-Container|                        |The type of object, T,   |
|                                         |                                       |stored in the set.       |
|-----------------------------------------+---------------------------------------+-------------------------|
|key_type                                 ||stl-AssociativeContainer|             |The key type associated  |
|                                         |                                       |with value_type.         |
|-----------------------------------------+---------------------------------------+-------------------------|
|key_compare                              ||stl-SortedAssociativeContainer|       ||stl-functors| that      |
|                                         |                                       |compares two keys for    |
|                                         |                                       |ordering.                |
|-----------------------------------------+---------------------------------------+-------------------------|
|value_compare                            ||stl-SortedAssociativeContainer|       ||stl-functors| that      |
|                                         |                                       |compares two values for  |
|                                         |                                       |ordering.                |
|-----------------------------------------+---------------------------------------+-------------------------|
|pointer                                  ||stl-Container|                        |Pointer to T.            |
|-----------------------------------------+---------------------------------------+-------------------------|
|reference                                ||stl-Container|                        |Reference to T           |
|-----------------------------------------+---------------------------------------+-------------------------|
|const_reference                          ||stl-Container|                        |Const reference to T     |
|-----------------------------------------+---------------------------------------+-------------------------|
|size_type                                ||stl-Container|                        |An unsigned integral     |
|                                         |                                       |type.                    |
|-----------------------------------------+---------------------------------------+-------------------------|
|difference_type                          ||stl-Container|                        |A signed integral type.  |
|-----------------------------------------+---------------------------------------+-------------------------|
|iterator                                 ||stl-Container|                        |Iterator used to iterate |
|                                         |                                       |through a set.           |
|-----------------------------------------+---------------------------------------+-------------------------|
|const_iterator                           ||stl-Container|                        |Const iterator used to   |
|                                         |                                       |iterate through a set.   |
|                                         |                                       |(Iterator and            |
|                                         |                                       |const_iterator are the   |
|                                         |                                       |same type.)              |
|-----------------------------------------+---------------------------------------+-------------------------|
|reverse_iterator                         ||stl-ReversibleContainer|              |Iterator used to iterate |
|                                         |                                       |backwards through a set. |
|-----------------------------------------+---------------------------------------+-------------------------|
|const_reverse_iterator                   ||stl-ReversibleContainer|              |Const iterator used to   |
|                                         |                                       |iterate backwards through|
|                                         |                                       |a set. (Reverse_iterator |
|                                         |                                       |and                      |
|                                         |                                       |const_reverse_iterator   |
|                                         |                                       |are the same type.)      |
|-----------------------------------------+---------------------------------------+-------------------------|
|iterator begin() const                   ||stl-Container|                        |Returns an iterator      |
|                                         |                                       |pointing to the beginning|
|                                         |                                       |of the set.              |
|-----------------------------------------+---------------------------------------+-------------------------|
|iterator end() const                     ||stl-Container|                        |Returns an iterator      |
|                                         |                                       |pointing to the end of   |
|                                         |                                       |the set.                 |
|-----------------------------------------+---------------------------------------+-------------------------|
|reverse_iterator rbegin() const          ||stl-ReversibleContainer|              |Returns a                |
|                                         |                                       |reverse_iterator pointing|
|                                         |                                       |to the beginning of the  |
|                                         |                                       |reversed set.            |
|-----------------------------------------+---------------------------------------+-------------------------|
|reverse_iterator rend() const            ||stl-ReversibleContainer|              |Returns a                |
|                                         |                                       |reverse_iterator pointing|
|                                         |                                       |to the end of the        |
|                                         |                                       |reversed set.            |
|-----------------------------------------+---------------------------------------+-------------------------|
|size_type size() const                   ||stl-Container|                        |Returns the size of the  |
|                                         |                                       |set.                     |
|-----------------------------------------+---------------------------------------+-------------------------|
|size_type max_size() const               ||stl-Container|                        |Returns the largest      |
|                                         |                                       |possible size of the set.|
|-----------------------------------------+---------------------------------------+-------------------------|
|bool empty() const                       ||stl-Container|                        |true if the set's size is|
|                                         |                                       |0.                       |
|-----------------------------------------+---------------------------------------+-------------------------|
|key_compare key_comp() const             ||stl-SortedAssociativeContainer|       |Returns the key_compare  |
|                                         |                                       |object used by the set.  |
|-----------------------------------------+---------------------------------------+-------------------------|
|value_compare value_comp() const         ||stl-SortedAssociativeContainer|       |Returns the value_compare|
|                                         |                                       |object used by the set.  |
|-----------------------------------------+---------------------------------------+-------------------------|
|set()                                    ||stl-Container|                        |Creates an empty set.    |
|-----------------------------------------+---------------------------------------+-------------------------|
|set(const key_compare& comp)             ||stl-SortedAssociativeContainer|       |Creates an empty set,    |
|                                         |                                       |using comp as the        |
|                                         |                                       |key_compare object.      |
|-----------------------------------------+---------------------------------------+-------------------------|
|template <class |stl-InputIterator|>     ||stl-UniqueSortedAssociativeContainer| |Creates a set with a copy|
|set(InputIterator f, InputIterator l)    |                                       |of a range.              |
|[4][1]                                   |                                       |                         |
|-----------------------------------------+---------------------------------------+-------------------------|
|template <class |stl-InputIterator|>     ||stl-UniqueSortedAssociativeContainer| |Creates a set with a copy|
|set(InputIterator f, InputIterator l,    |                                       |of a range, using comp as|
|    const key_compare& comp)             |                                       |the key_compare object.  |
|[5][1]                                   |                                       |                         |
|-----------------------------------------+---------------------------------------+-------------------------|
|set(const set&)                          ||stl-Container|                        |The copy constructor.    |
|-----------------------------------------+---------------------------------------+-------------------------|
|set& operator=(const set&)               ||stl-Container|                        |The assignment operator  |
|-----------------------------------------+---------------------------------------+-------------------------|
|void swap(set&)                          ||stl-Container|                        |Swaps the contents of two|
|                                         |                                       |sets.                    |
|-----------------------------------------+---------------------------------------+-------------------------|
|pair<iterator, bool>                     ||stl-UniqueAssociativeContainer|       |Inserts x into the set.  |
|insert(const value_type& x)              |                                       |                         |
|-----------------------------------------+---------------------------------------+-------------------------|
|iterator insert(iterator pos,            ||stl-UniqueSortedAssociativeContainer| |Inserts x into the set,  |
|                const value_type& x)     |                                       |using pos as a hint to   |
|                                         |                                       |where it will be         |
|                                         |                                       |inserted.                |
|-----------------------------------------+---------------------------------------+-------------------------|
|template <class |stl-InputIterator|>     ||stl-UniqueSortedAssociativeContainer| |Inserts a range into the |
|void insert(InputIterator, InputIterator)|                                       |set.                     |
|[6][1]                                   |                                       |                         |
|-----------------------------------------+---------------------------------------+-------------------------|
|void erase(iterator pos)                 ||stl-AssociativeContainer|             |Erases the element       |
|                                         |                                       |pointed to by pos.       |
|-----------------------------------------+---------------------------------------+-------------------------|
|size_type erase(const key_type& k)       ||stl-AssociativeContainer|             |Erases the element whose |
|                                         |                                       |key is k.                |
|-----------------------------------------+---------------------------------------+-------------------------|
|void erase(iterator first, iterator last)||stl-AssociativeContainer|             |Erases all elements in a |
|                                         |                                       |range.                   |
|-----------------------------------------+---------------------------------------+-------------------------|
|void clear()                             ||stl-AssociativeContainer|             |Erases all of the        |
|                                         |                                       |elements.                |
|-----------------------------------------+---------------------------------------+-------------------------|
|iterator find(const key_type& k) const   ||stl-AssociativeContainer|             |Finds an element whose   |
|                                         |                                       |key is k.                |
|-----------------------------------------+---------------------------------------+-------------------------|
|size_type count(const key_type& k) const ||stl-UniqueAssociativeContainer|       |Counts the number of     |
|                                         |                                       |elements whose key is k. |
|-----------------------------------------+---------------------------------------+-------------------------|
|iterator lower_bound(const key_type& k)  ||stl-SortedAssociativeContainer|       |Finds the first element  |
|const                                    |                                       |whose key is not less    |
|                                         |                                       |than k.                  |
|-----------------------------------------+---------------------------------------+-------------------------|
|iterator upper_bound(const key_type& k)  ||stl-SortedAssociativeContainer|       |Finds the first element  |
|const                                    |                                       |whose key greater than k.|
|-----------------------------------------+---------------------------------------+-------------------------|
|pair<iterator, iterator>                 ||stl-SortedAssociativeContainer|       |Finds a range containing |
|equal_range(const key_type& k) const     |                                       |all elements whose key is|
|                                         |                                       |k.                       |
|-----------------------------------------+---------------------------------------+-------------------------|
|bool operator==(const set&,              ||stl-ForwardContainer|                 |Tests two sets for       |
|                const set&)              |                                       |equality. This is a      |
|                                         |                                       |global function, not a   |
|                                         |                                       |member function.         |
|-----------------------------------------+---------------------------------------+-------------------------|
|bool operator<(const set&,               ||stl-ForwardContainer|                 |Lexicographical          |
|               const set&)               |                                       |comparison. This is a    |
|                                         |                                       |global function, not a   |
|                                         |                                       |member function.         |
+-----------------------------------------------------------------------------------------------------------+

  New members

   All of set's members are defined in the
   |stl-UniqueSortedAssociativeContainer| and
   |stl-SimpleAssociativeContainer| requirements. Set does not introduce any
   new members.

  Notes

   [1] This member function relies on member template functions, which at
   present (early 1998) are not supported by all compilers. If your compiler
   supports member templates, you can call this function with any type of
   |stl-InputIterator|. If your compiler does not yet support member
   templates, though, then the arguments must either be of type const
   value_type* or of type set::const_iterator.

  See also

   |stl-AssociativeContainer|, |stl-SortedAssociativeContainer|,
   |stl-SimpleAssociativeContainer|, |stl-UniqueSortedAssociativeContainer|,
   |stl-Map|, |stl-multiset|, |stl-Multimap|, |stl-hash_set|, |stl-hash_map|,
   |stl-hash_multiset|, |stl-hash_multimap|

*stl-Map*

                         map<Key, Data, Compare, Alloc>

   Category: containers                                  Component type: type

  Description

   Map is a |stl-SortedAssociativeContainer| that associates objects of type
   Key with objects of type Data. Map is a |stl-PairAssociativeContainer|,
   meaning that its value type is |stl-pair|<const Key, Data>. It is also a
   |stl-UniqueAssociativeContainer|, meaning that no two elements have the
   same key.

   Map has the important property that inserting a new element into a map
   does not invalidate iterators that point to existing elements. Erasing an
   element from a map also does not invalidate any iterators, except, of
   course, for iterators that actually point to the element that is being
   erased.

*stl-Map-example*

 struct ltstr
 {
   bool operator()(const char* s1, const char* s2) const
   {
     return strcmp(s1, s2) < 0;
   }
 };

 int main()
 {
   map<const char*, int, ltstr> months;

   months["january"] = 31;
   months["february"] = 28;
   months["march"] = 31;
   months["april"] = 30;
   months["may"] = 31;
   months["june"] = 30;
   months["july"] = 31;
   months["august"] = 31;
   months["september"] = 30;
   months["october"] = 31;
   months["november"] = 30;
   months["december"] = 31;

   cout << "june -> " << months["june"] << endl;
   map<const char*, int, ltstr>::iterator cur  = months.find("june");
   map<const char*, int, ltstr>::iterator prev = cur;
   map<const char*, int, ltstr>::iterator next = cur;
   ++next;
   --prev;
   cout << "Previous (in alphabetical order) is " << (*prev).first << endl;
   cout << "Next (in alphabetical order) is " << (*next).first << endl;
 }


  Definition

   Defined in the standard header |stl-map|, and in the nonstandard
   backward-compatibility header |stl-map|.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |               Description               |     Default      |
   |-----------+-----------------------------------------+------------------|
   | Key       | The map's key type. This is also        |                  |
   |           | defined as map::key_type.               |                  |
   |-----------+-----------------------------------------+------------------|
   | Data      | The map's data type. This is also       |                  |
   |           | defined as map::data_type.              |                  |
   |-----------+-----------------------------------------+------------------|
   | Compare   | The key comparison function, a          | |stl-less|<Key>  |
   |           | |stl-StrictWeakOrdering| whose argument |                  |
   |           | type is key_type; it returns true if    |                  |
   |           | its first argument is less than its     |                  |
   |           | second argument, and false otherwise.   |                  |
   |           | This is also defined as                 |                  |
   |           | map::key_compare.                       |                  |
   |-----------+-----------------------------------------+------------------|
   | Alloc     | The map's allocator, used for all       | |stl-Allocators| |
   |           | internal memory management.             |                  |
   +------------------------------------------------------------------------+

  Model of

   |stl-UniqueSortedAssociativeContainer|, |stl-PairAssociativeContainer|

  Type requirements

     * Data is |stl-Assignable|.
     * Compare is a |stl-StrictWeakOrdering| whose argument type is Key.
     * Alloc is an |stl-Allocators|.

  Public base classes

   None.

  Members

+-----------------------------------------------------------------------------------------------------------+
|                 Member                  |             Where defined             |       Description       |
|-----------------------------------------+---------------------------------------+-------------------------|
|key_type                                 ||stl-AssociativeContainer|             |The map's key type, Key. |
|-----------------------------------------+---------------------------------------+-------------------------|
|data_type                                ||stl-PairAssociativeContainer|         |The type of object       |
|                                         |                                       |associated with the keys.|
|-----------------------------------------+---------------------------------------+-------------------------|
|value_type                               ||stl-PairAssociativeContainer|         |The type of object,      |
|                                         |                                       |pair<const key_type,     |
|                                         |                                       |data_type>, stored in the|
|                                         |                                       |map.                     |
|-----------------------------------------+---------------------------------------+-------------------------|
|key_compare                              ||stl-SortedAssociativeContainer|       ||stl-functors| that      |
|                                         |                                       |compares two keys for    |
|                                         |                                       |ordering.                |
|-----------------------------------------+---------------------------------------+-------------------------|
|value_compare                            ||stl-SortedAssociativeContainer|       ||stl-functors| that      |
|                                         |                                       |compares two values for  |
|                                         |                                       |ordering.                |
|-----------------------------------------+---------------------------------------+-------------------------|
|pointer                                  ||stl-Container|                        |Pointer to T.            |
|-----------------------------------------+---------------------------------------+-------------------------|
|reference                                ||stl-Container|                        |Reference to T           |
|-----------------------------------------+---------------------------------------+-------------------------|
|const_reference                          ||stl-Container|                        |Const reference to T     |
|-----------------------------------------+---------------------------------------+-------------------------|
|size_type                                ||stl-Container|                        |An unsigned integral     |
|                                         |                                       |type.                    |
|-----------------------------------------+---------------------------------------+-------------------------|
|difference_type                          ||stl-Container|                        |A signed integral type.  |
|-----------------------------------------+---------------------------------------+-------------------------|
|iterator                                 ||stl-Container|                        |Iterator used to iterate |
|                                         |                                       |through a map. [4][1]    |
|-----------------------------------------+---------------------------------------+-------------------------|
|const_iterator                           ||stl-Container|                        |Const iterator used to   |
|                                         |                                       |iterate through a map.   |
|-----------------------------------------+---------------------------------------+-------------------------|
|reverse_iterator                         ||stl-ReversibleContainer|              |Iterator used to iterate |
|                                         |                                       |backwards through a map. |
|                                         |                                       |[5][1]                   |
|-----------------------------------------+---------------------------------------+-------------------------|
|const_reverse_iterator                   ||stl-ReversibleContainer|              |Const iterator used to   |
|                                         |                                       |iterate backwards through|
|                                         |                                       |a map.                   |
|-----------------------------------------+---------------------------------------+-------------------------|
|iterator begin()                         ||stl-Container|                        |Returns an iterator      |
|                                         |                                       |pointing to the beginning|
|                                         |                                       |of the map.              |
|-----------------------------------------+---------------------------------------+-------------------------|
|iterator end()                           ||stl-Container|                        |Returns an iterator      |
|                                         |                                       |pointing to the end of   |
|                                         |                                       |the map.                 |
|-----------------------------------------+---------------------------------------+-------------------------|
|const_iterator begin() const             ||stl-Container|                        |Returns a const_iterator |
|                                         |                                       |pointing to the beginning|
|                                         |                                       |of the map.              |
|-----------------------------------------+---------------------------------------+-------------------------|
|const_iterator end() const               ||stl-Container|                        |Returns a const_iterator |
|                                         |                                       |pointing to the end of   |
|                                         |                                       |the map.                 |
|-----------------------------------------+---------------------------------------+-------------------------|
|reverse_iterator rbegin()                ||stl-ReversibleContainer|              |Returns a                |
|                                         |                                       |reverse_iterator pointing|
|                                         |                                       |to the beginning of the  |
|                                         |                                       |reversed map.            |
|-----------------------------------------+---------------------------------------+-------------------------|
|reverse_iterator rend()                  ||stl-ReversibleContainer|              |Returns a                |
|                                         |                                       |reverse_iterator pointing|
|                                         |                                       |to the end of the        |
|                                         |                                       |reversed map.            |
|-----------------------------------------+---------------------------------------+-------------------------|
|const_reverse_iterator rbegin() const    ||stl-ReversibleContainer|              |Returns a                |
|                                         |                                       |const_reverse_iterator   |
|                                         |                                       |pointing to the beginning|
|                                         |                                       |of the reversed map.     |
|-----------------------------------------+---------------------------------------+-------------------------|
|const_reverse_iterator rend() const      ||stl-ReversibleContainer|              |Returns a                |
|                                         |                                       |const_reverse_iterator   |
|                                         |                                       |pointing to the end of   |
|                                         |                                       |the reversed map.        |
|-----------------------------------------+---------------------------------------+-------------------------|
|size_type size() const                   ||stl-Container|                        |Returns the size of the  |
|                                         |                                       |map.                     |
|-----------------------------------------+---------------------------------------+-------------------------|
|size_type max_size() const               ||stl-Container|                        |Returns the largest      |
|                                         |                                       |possible size of the map.|
|-----------------------------------------+---------------------------------------+-------------------------|
|bool empty() const                       ||stl-Container|                        |true if the map's size is|
|                                         |                                       |0.                       |
|-----------------------------------------+---------------------------------------+-------------------------|
|key_compare key_comp() const             ||stl-SortedAssociativeContainer|       |Returns the key_compare  |
|                                         |                                       |object used by the map.  |
|-----------------------------------------+---------------------------------------+-------------------------|
|value_compare value_comp() const         ||stl-SortedAssociativeContainer|       |Returns the value_compare|
|                                         |                                       |object used by the map.  |
|-----------------------------------------+---------------------------------------+-------------------------|
|map()                                    ||stl-Container|                        |Creates an empty map.    |
|-----------------------------------------+---------------------------------------+-------------------------|
|map(const key_compare& comp)             ||stl-SortedAssociativeContainer|       |Creates an empty map,    |
|                                         |                                       |using comp as the        |
|                                         |                                       |key_compare object.      |
|-----------------------------------------+---------------------------------------+-------------------------|
|template <class |stl-InputIterator|>     ||stl-UniqueSortedAssociativeContainer| |Creates a map with a copy|
|map(InputIterator f, InputIterator l)    |                                       |of a range.              |
|[6][2]                                   |                                       |                         |
|-----------------------------------------+---------------------------------------+-------------------------|
|template <class |stl-InputIterator|>     ||stl-UniqueSortedAssociativeContainer| |Creates a map with a copy|
|map(InputIterator f, InputIterator l,    |                                       |of a range, using comp as|
|    const key_compare& comp)             |                                       |the key_compare object.  |
|[7][2]                                   |                                       |                         |
|-----------------------------------------+---------------------------------------+-------------------------|
|map(const map&)                          ||stl-Container|                        |The copy constructor.    |
|-----------------------------------------+---------------------------------------+-------------------------|
|map& operator=(const map&)               ||stl-Container|                        |The assignment operator  |
|-----------------------------------------+---------------------------------------+-------------------------|
|void swap(map&)                          ||stl-Container|                        |Swaps the contents of two|
|                                         |                                       |maps.                    |
|-----------------------------------------+---------------------------------------+-------------------------|
|pair<iterator, bool>                     ||stl-UniqueAssociativeContainer|       |Inserts x into the map.  |
|insert(const value_type& x)              |                                       |                         |
|-----------------------------------------+---------------------------------------+-------------------------|
|iterator insert(iterator pos,            ||stl-UniqueSortedAssociativeContainer| |Inserts x into the map,  |
|                const value_type& x)     |                                       |using pos as a hint to   |
|                                         |                                       |where it will be         |
|                                         |                                       |inserted.                |
|-----------------------------------------+---------------------------------------+-------------------------|
|template <class |stl-InputIterator|>     ||stl-UniqueSortedAssociativeContainer| |Inserts a range into the |
|void insert(InputIterator, InputIterator)|                                       |map.                     |
|[8][2]                                   |                                       |                         |
|-----------------------------------------+---------------------------------------+-------------------------|
|void erase(iterator pos)                 ||stl-AssociativeContainer|             |Erases the element       |
|                                         |                                       |pointed to by pos.       |
|-----------------------------------------+---------------------------------------+-------------------------|
|size_type erase(const key_type& k)       ||stl-AssociativeContainer|             |Erases the element whose |
|                                         |                                       |key is k.                |
|-----------------------------------------+---------------------------------------+-------------------------|
|void erase(iterator first, iterator last)||stl-AssociativeContainer|             |Erases all elements in a |
|                                         |                                       |range.                   |
|-----------------------------------------+---------------------------------------+-------------------------|
|void clear()                             ||stl-AssociativeContainer|             |Erases all of the        |
|                                         |                                       |elements.                |
|-----------------------------------------+---------------------------------------+-------------------------|
|iterator find(const key_type& k)         ||stl-AssociativeContainer|             |Finds an element whose   |
|                                         |                                       |key is k.                |
|-----------------------------------------+---------------------------------------+-------------------------|
|const_iterator find(const key_type& k)   ||stl-AssociativeContainer|             |Finds an element whose   |
|const                                    |                                       |key is k.                |
|-----------------------------------------+---------------------------------------+-------------------------|
|size_type count(const key_type& k)       ||stl-UniqueAssociativeContainer|       |Counts the number of     |
|                                         |                                       |elements whose key is k. |
|-----------------------------------------+---------------------------------------+-------------------------|
|iterator lower_bound(const key_type& k)  ||stl-SortedAssociativeContainer|       |Finds the first element  |
|                                         |                                       |whose key is not less    |
|                                         |                                       |than k.                  |
|-----------------------------------------+---------------------------------------+-------------------------|
|const_iterator lower_bound(const         ||stl-SortedAssociativeContainer|       |Finds the first element  |
|key_type& k) const                       |                                       |whose key is not less    |
|                                         |                                       |than k.                  |
|-----------------------------------------+---------------------------------------+-------------------------|
|iterator upper_bound(const key_type& k)  ||stl-SortedAssociativeContainer|       |Finds the first element  |
|                                         |                                       |whose key greater than k.|
|-----------------------------------------+---------------------------------------+-------------------------|
|const_iterator upper_bound(const         ||stl-SortedAssociativeContainer|       |Finds the first element  |
|key_type& k) const                       |                                       |whose key greater than k.|
|-----------------------------------------+---------------------------------------+-------------------------|
|pair<iterator, iterator>                 ||stl-SortedAssociativeContainer|       |Finds a range containing |
|equal_range(const key_type& k)           |                                       |all elements whose key is|
|                                         |                                       |k.                       |
|-----------------------------------------+---------------------------------------+-------------------------|
|pair<const_iterator, const_iterator>     ||stl-SortedAssociativeContainer|       |Finds a range containing |
|equal_range(const key_type& k) const     |                                       |all elements whose key is|
|                                         |                                       |k.                       |
|-----------------------------------------+---------------------------------------+-------------------------|
|data_type&                               |map                                    |See below.               |
|operator[](const key_type& k) [9][3]     |                                       |                         |
|-----------------------------------------+---------------------------------------+-------------------------|
|bool operator==(const map&,              ||stl-ForwardContainer|                 |Tests two maps for       |
|                const map&)              |                                       |equality. This is a      |
|                                         |                                       |global function, not a   |
|                                         |                                       |member function.         |
|-----------------------------------------+---------------------------------------+-------------------------|
|bool operator<(const map&,               ||stl-ForwardContainer|                 |Lexicographical          |
|               const map&)               |                                       |comparison. This is a    |
|                                         |                                       |global function, not a   |
|                                         |                                       |member function.         |
+-----------------------------------------------------------------------------------------------------------+

  New members

   These members are not defined in the
   |stl-UniqueSortedAssociativeContainer| and |stl-PairAssociativeContainer|
   requirements, but are unique to map:

   +------------------------------------------------------------------------+
   |           Member function           |           Description            |
   |-------------------------------------+----------------------------------|
   |data_type&                           | Returns a reference to the       |
   |operator[](const key_type& k) [10][3]| object that is associated with a |
   |                                     | particular key. If the map does  |
   |                                     | not already contain such an      |
   |                                     | object, operator[] inserts the   |
   |                                     | default object data_type().      |
   |                                     | [11][3]                          |
   +------------------------------------------------------------------------+

  Notes

   [1] Map::iterator is not a mutable iterator, because map::value_type is
   not |stl-Assignable|. That is, if i is of type map::iterator and p is of
   type map::value_type, then *i = p is not a valid expression. However,
   map::iterator isn't a constant iterator either, because it can be used to
   modify the object that it points to. Using the same notation as above,
   (*i).second = p is a valid expression. The same point applies to
   map::reverse_iterator.

   [2] This member function relies on member template functions, which at
   present (early 1998) are not supported by all compilers. If your compiler
   supports member templates, you can call this function with any type of
   |stl-InputIterator|. If your compiler does not yet support member
   templates, though, then the arguments must either be of type const
   value_type* or of type map::const_iterator.

   [3] Since operator[] might insert a new element into the map, it can't
   possibly be a const member function. Note that the definition of
   operator[] is extremely simple: m[k] is equivalent to
   (*((m.insert(value_type(k, data_type()))).first)).second. Strictly
   speaking, this member function is unnecessary: it exists only for
   convenience.

  See also

   |stl-AssociativeContainer|, |stl-SortedAssociativeContainer|,
   |stl-PairAssociativeContainer|, |stl-UniqueSortedAssociativeContainer|,
   |stl-set| |stl-multiset|, |stl-Multimap|, |stl-hash_set|, |stl-hash_map|,
   |stl-hash_multiset|, |stl-hash_multimap|,

*stl-multiset*

                         multiset<Key, Compare, Alloc>

   Category: containers                                  Component type: type

  Description

   Multiset is a |stl-SortedAssociativeContainer| that stores objects of type
   Key. Multiset is a |stl-SimpleAssociativeContainer|, meaning that its
   value type, as well as its key type, is Key. It is also a
   |stl-MultipleAssociativeContainer|, meaning that two or more elements may
   be identical.

   |stl-set| and multiset are particularly well suited to the set algorithms
   |stl-includes|, |stl-set_union|, |stl-set_intersection|,
   |stl-set_difference|, and |stl-set_symmetric_difference|. The reason for
   this is twofold. First, the set algorithms require their arguments to be
   sorted ranges, and, since |stl-set| and |stl-multiset| are
   |stl-SortedAssociativeContainer|, their elements are always sorted in
   ascending order. Second, the output range of these algorithms is always
   sorted, and inserting a sorted range into a set or multiset is a fast
   operation: the |stl-UniqueSortedAssociativeContainer| and
   |stl-MultipleSortedAssociativeContainer| requirements guarantee that
   inserting a range takes only linear time if the range is already sorted.

   Multiset has the important property that inserting a new element into a
   multiset does not invalidate iterators that point to existing elements.
   Erasing an element from a multiset also does not invalidate any iterators,
   except, of course, for iterators that actually point to the element that
   is being erased.

*stl-multiset-example*

 int main()
 {
   const int N = 10;
   int a[N] = {4, 1, 1, 1, 1, 1, 0, 5, 1, 0};
   int b[N] = {4, 4, 2, 4, 2, 4, 0, 1, 5, 5};

   multiset<int> A(a, a + N);
   multiset<int> B(b, b + N);
   multiset<int> C;

   cout << "Set A: ";
   |stl-copy|(A.begin(), A.end(), |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;
   cout << "Set B: ";
   |stl-copy|(B.begin(), B.end(), |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;

   cout << "Union: ";
   |stl-set_union|(A.begin(), A.end(), B.begin(), B.end(),
             |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;

   cout << "Intersection: ";
   |stl-set_intersection|(A.begin(), A.end(), B.begin(), B.end(),
                    |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;

   |stl-set_difference|(A.begin(), A.end(), B.begin(), B.end(),
                  |stl-insert_iterator|(C, C.begin()));
   cout << "Set C (difference of A and B): ";
   |stl-copy|(C.begin(), C.end(), |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;
 }

  Definition

   Defined in the standard header |stl-set|, and in the nonstandard
   backward-compatibility header |stl-multiset|.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |               Description               |     Default      |
   |-----------+-----------------------------------------+------------------|
   | Key       | The set's key type and value type. This |                  |
   |           | is also defined as multiset::key_type   |                  |
   |           | and multiset::value_type                |                  |
   |-----------+-----------------------------------------+------------------|
   | Compare   | The key comparison function, a          | |stl-less|<Key>  |
   |           | |stl-StrictWeakOrdering| whose argument |                  |
   |           | type is key_type; it returns true if    |                  |
   |           | its first argument is less than its     |                  |
   |           | second argument, and false otherwise.   |                  |
   |           | This is also defined as                 |                  |
   |           | multiset::key_compare and               |                  |
   |           | multiset::value_compare.                |                  |
   |-----------+-----------------------------------------+------------------|
   | Alloc     | The multiset's allocator, used for all  | |stl-Allocators| |
   |           | internal memory management.             |                  |
   +------------------------------------------------------------------------+

  Model of

   |stl-MultipleSortedAssociativeContainer|, |stl-SimpleAssociativeContainer|

  Type requirements

     * Key is |stl-Assignable|.
     * Compare is a |stl-StrictWeakOrdering| whose argument type is Key.
     * Alloc is an |stl-Allocators|.

  Public base classes

   None.

  Members

+--------------------------------------------------------------------------------------------------------------+
|                  Member                  |              Where defined              |       Description       |
|------------------------------------------+-----------------------------------------+-------------------------|
|value_type                                ||stl-Container|                          |The type of object, T,   |
|                                          |                                         |stored in the multiset.  |
|------------------------------------------+-----------------------------------------+-------------------------|
|key_type                                  ||stl-AssociativeContainer|               |The key type associated  |
|                                          |                                         |with value_type.         |
|------------------------------------------+-----------------------------------------+-------------------------|
|key_compare                               ||stl-SortedAssociativeContainer|         ||stl-functors| that      |
|                                          |                                         |compares two keys for    |
|                                          |                                         |ordering.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|value_compare                             ||stl-SortedAssociativeContainer|         ||stl-functors| that      |
|                                          |                                         |compares two values for  |
|                                          |                                         |ordering.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|pointer                                   ||stl-Container|                          |Pointer to T.            |
|------------------------------------------+-----------------------------------------+-------------------------|
|reference                                 ||stl-Container|                          |Reference to T           |
|------------------------------------------+-----------------------------------------+-------------------------|
|const_reference                           ||stl-Container|                          |Const reference to T     |
|------------------------------------------+-----------------------------------------+-------------------------|
|size_type                                 ||stl-Container|                          |An unsigned integral     |
|                                          |                                         |type.                    |
|------------------------------------------+-----------------------------------------+-------------------------|
|difference_type                           ||stl-Container|                          |A signed integral type.  |
|------------------------------------------+-----------------------------------------+-------------------------|
|iterator                                  ||stl-Container|                          |Iterator used to iterate |
|                                          |                                         |through a multiset.      |
|------------------------------------------+-----------------------------------------+-------------------------|
|const_iterator                            ||stl-Container|                          |Const iterator used to   |
|                                          |                                         |iterate through a        |
|                                          |                                         |multiset. (Iterator and  |
|                                          |                                         |const_iterator are the   |
|                                          |                                         |same type.)              |
|------------------------------------------+-----------------------------------------+-------------------------|
|reverse_iterator                          ||stl-ReversibleContainer|                |Iterator used to iterate |
|                                          |                                         |backwards through a      |
|                                          |                                         |multiset.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|const_reverse_iterator                    ||stl-ReversibleContainer|                |Const iterator used to   |
|                                          |                                         |iterate backwards through|
|                                          |                                         |a multiset.              |
|                                          |                                         |(Reverse_iterator and    |
|                                          |                                         |const_reverse_iterator   |
|                                          |                                         |are the same type.)      |
|------------------------------------------+-----------------------------------------+-------------------------|
|iterator begin() const                    ||stl-Container|                          |Returns an iterator      |
|                                          |                                         |pointing to the beginning|
|                                          |                                         |of the multiset.         |
|------------------------------------------+-----------------------------------------+-------------------------|
|iterator end() const                      ||stl-Container|                          |Returns an iterator      |
|                                          |                                         |pointing to the end of   |
|                                          |                                         |the multiset.            |
|------------------------------------------+-----------------------------------------+-------------------------|
|reverse_iterator rbegin() const           ||stl-ReversibleContainer|                |Returns a                |
|                                          |                                         |reverse_iterator pointing|
|                                          |                                         |to the beginning of the  |
|                                          |                                         |reversed multiset.       |
|------------------------------------------+-----------------------------------------+-------------------------|
|reverse_iterator rend() const             ||stl-ReversibleContainer|                |Returns a                |
|                                          |                                         |reverse_iterator pointing|
|                                          |                                         |to the end of the        |
|                                          |                                         |reversed multiset.       |
|------------------------------------------+-----------------------------------------+-------------------------|
|size_type size() const                    ||stl-Container|                          |Returns the size of the  |
|                                          |                                         |multiset.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|size_type max_size() const                ||stl-Container|                          |Returns the largest      |
|                                          |                                         |possible size of the     |
|                                          |                                         |multiset.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|bool empty() const                        ||stl-Container|                          |true if the multiset's   |
|                                          |                                         |size is 0.               |
|------------------------------------------+-----------------------------------------+-------------------------|
|key_compare key_comp() const              ||stl-SortedAssociativeContainer|         |Returns the key_compare  |
|                                          |                                         |object used by the       |
|                                          |                                         |multiset.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|value_compare value_comp() const          ||stl-SortedAssociativeContainer|         |Returns the value_compare|
|                                          |                                         |object used by the       |
|                                          |                                         |multiset.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|multiset()                                ||stl-Container|                          |Creates an empty         |
|                                          |                                         |multiset.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|multiset(const key_compare& comp)         ||stl-SortedAssociativeContainer|         |Creates an empty         |
|                                          |                                         |multiset, using comp as  |
|                                          |                                         |the key_compare object.  |
|------------------------------------------+-----------------------------------------+-------------------------|
|template <class |stl-InputIterator|>      ||stl-MultipleSortedAssociativeContainer| |Creates a multiset with a|
|multiset(InputIterator f, InputIterator l)|                                         |copy of a range.         |
|[4][1]                                    |                                         |                         |
|------------------------------------------+-----------------------------------------+-------------------------|
|template <class |stl-InputIterator|>      ||stl-MultipleSortedAssociativeContainer| |Creates a multiset with a|
|multiset(InputIterator f, InputIterator l,|                                         |copy of a range, using   |
|         const key_compare& comp)         |                                         |comp as the key_compare  |
|[5][1]                                    |                                         |object.                  |
|------------------------------------------+-----------------------------------------+-------------------------|
|multiset(const multiset&)                 ||stl-Container|                          |The copy constructor.    |
|------------------------------------------+-----------------------------------------+-------------------------|
|multiset& operator=(const multiset&)      ||stl-Container|                          |The assignment operator  |
|------------------------------------------+-----------------------------------------+-------------------------|
|void swap(multiset&)                      ||stl-Container|                          |Swaps the contents of two|
|                                          |                                         |multisets.               |
|------------------------------------------+-----------------------------------------+-------------------------|
|iterator insert(const value_type& x)      ||stl-MultipleAssociativeContainer|       |Inserts x into the       |
|                                          |                                         |multiset.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|iterator insert(iterator pos,             ||stl-MultipleSortedAssociativeContainer| |Inserts x into the       |
|                const value_type& x)      |                                         |multiset, using pos as a |
|                                          |                                         |hint to where it will be |
|                                          |                                         |inserted.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|template <class |stl-InputIterator|>      ||stl-MultipleSortedAssociativeContainer| |Inserts a range into the |
|void insert(InputIterator, InputIterator) |                                         |multiset.                |
|[6][1]                                    |                                         |                         |
|------------------------------------------+-----------------------------------------+-------------------------|
|void erase(iterator pos)                  ||stl-AssociativeContainer|               |Erases the element       |
|                                          |                                         |pointed to by pos.       |
|------------------------------------------+-----------------------------------------+-------------------------|
|size_type erase(const key_type& k)        ||stl-AssociativeContainer|               |Erases the element whose |
|                                          |                                         |key is k.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|void erase(iterator first, iterator last) ||stl-AssociativeContainer|               |Erases all elements in a |
|                                          |                                         |range.                   |
|------------------------------------------+-----------------------------------------+-------------------------|
|void clear()                              ||stl-AssociativeContainer|               |Erases all of the        |
|                                          |                                         |elements.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|iterator find(const key_type& k) const    ||stl-AssociativeContainer|               |Finds an element whose   |
|                                          |                                         |key is k.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|size_type count(const key_type& k) const  ||stl-AssociativeContainer|               |Counts the number of     |
|                                          |                                         |elements whose key is k. |
|------------------------------------------+-----------------------------------------+-------------------------|
|iterator lower_bound(const key_type& k)   ||stl-SortedAssociativeContainer|         |Finds the first element  |
|const                                     |                                         |whose key is not less    |
|                                          |                                         |than k.                  |
|------------------------------------------+-----------------------------------------+-------------------------|
|iterator upper_bound(const key_type& k)   ||stl-SortedAssociativeContainer|         |Finds the first element  |
|const                                     |                                         |whose key greater than k.|
|------------------------------------------+-----------------------------------------+-------------------------|
|pair<iterator, iterator>                  ||stl-SortedAssociativeContainer|         |Finds a range containing |
|equal_range(const key_type& k) const      |                                         |all elements whose key is|
|                                          |                                         |k.                       |
|------------------------------------------+-----------------------------------------+-------------------------|
|bool operator==(const multiset&,          ||stl-ForwardContainer|                   |Tests two multisets for  |
|                const multiset&)          |                                         |equality. This is a      |
|                                          |                                         |global function, not a   |
|                                          |                                         |member function.         |
|------------------------------------------+-----------------------------------------+-------------------------|
|bool operator<(const multiset&,           ||stl-ForwardContainer|                   |Lexicographical          |
|               const multiset&)           |                                         |comparison. This is a    |
|                                          |                                         |global function, not a   |
|                                          |                                         |member function.         |
+--------------------------------------------------------------------------------------------------------------+

  New members

   All of multiset's members are defined in the
   |stl-MultipleSortedAssociativeContainer| and
   |stl-SimpleAssociativeContainer| requirements. Multiset does not introduce
   any new members.

  Notes

   [1] This member function relies on member template functions, which at
   present (early 1998) are not supported by all compilers. If your compiler
   supports member templates, you can call this function with any type of
   |stl-InputIterator|. If your compiler does not yet support member
   templates, though, then the arguments must either be of type const
   value_type* or of type multiset::const_iterator.

  See also

   |stl-AssociativeContainer|, |stl-SortedAssociativeContainer|,
   |stl-SimpleAssociativeContainer|,
   |stl-MultipleSortedAssociativeContainer|, |stl-set|, |stl-Map|,
   |stl-Multimap|, |stl-hash_set|, |stl-hash_map|, |stl-hash_multiset|,
   |stl-hash_multimap|

*stl-Multimap*

                      multimap<Key, Data, Compare, Alloc>

   Category: containers                                  Component type: type

  Description

   Multimap is a |stl-SortedAssociativeContainer| that associates objects of
   type Key with objects of type Data. multimap is a
   |stl-PairAssociativeContainer|, meaning that its value type is
   |stl-pair|<const Key, Data>. It is also a
   |stl-MultipleAssociativeContainer|, meaning that there is no limit on the
   number of elements with the same key.

   Multimap has the important property that inserting a new element into a
   multimap does not invalidate iterators that point to existing elements.
   Erasing an element from a multimap also does not invalidate any iterators,
   except, of course, for iterators that actually point to the element that
   is being erased.

*stl-Multimap-example*

 struct ltstr
 {
   bool operator()(const char* s1, const char* s2) const
   {
     return strcmp(s1, s2) < 0;
   }
 };

 int main()
 {
   multimap<const char*, int, ltstr> m;

   m.insert(pair<const char* const, int>("a", 1));
   m.insert(pair<const char* const, int>("c", 2));
   m.insert(pair<const char* const, int>("b", 3));
   m.insert(pair<const char* const, int>("b", 4));
   m.insert(pair<const char* const, int>("a", 5));
   m.insert(pair<const char* const, int>("b", 6));

   cout << "Number of elements with key a: " << m.count("a") << endl;
   cout << "Number of elements with key b: " << m.count("b") << endl;
   cout << "Number of elements with key c: " << m.count("c") << endl;

   cout << "Elements in m: " << endl;
   for (multimap<const char*, int, ltstr>::iterator it = m.begin();
        it != m.end();
        ++it)
    cout << "  [" << (*it).first << ", " << (*it).second << "]" << endl;
 }

  Definition

   Defined in the standard header |stl-map|, and in the nonstandard
   backward-compatibility header |stl-multimap|.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |               Description               |     Default      |
   |-----------+-----------------------------------------+------------------|
   | Key       | The multimap's key type. This is also   |                  |
   |           | defined as multimap::key_type.          |                  |
   |-----------+-----------------------------------------+------------------|
   | Data      | The multimap's data type. This is also  |                  |
   |           | defined as multimap::data_type.         |                  |
   |-----------+-----------------------------------------+------------------|
   | Compare   | The key comparison function, a          | |stl-less|<Key>  |
   |           | |stl-StrictWeakOrdering| whose argument |                  |
   |           | type is key_type; it returns true if    |                  |
   |           | its first argument is less than its     |                  |
   |           | second argument, and false otherwise.   |                  |
   |           | This is also defined as                 |                  |
   |           | multimap::key_compare.                  |                  |
   |-----------+-----------------------------------------+------------------|
   | Alloc     | The multimap's allocator, used for all  | |stl-Allocators| |
   |           | internal memory management.             |                  |
   +------------------------------------------------------------------------+

  Model of

   |stl-MultipleSortedAssociativeContainer|, |stl-PairAssociativeContainer|

  Type requirements

     * Data is |stl-Assignable|.
     * Compare is a |stl-StrictWeakOrdering| whose argument type is Key.
     * Alloc is an |stl-Allocators|.

  Public base classes

   None.

  Members

+--------------------------------------------------------------------------------------------------------------+
|                  Member                  |              Where defined              |       Description       |
|------------------------------------------+-----------------------------------------+-------------------------|
|key_type                                  ||stl-AssociativeContainer|               |The multimap's key type, |
|                                          |                                         |Key.                     |
|------------------------------------------+-----------------------------------------+-------------------------|
|data_type                                 ||stl-PairAssociativeContainer|           |The type of object       |
|                                          |                                         |associated with the keys.|
|------------------------------------------+-----------------------------------------+-------------------------|
|value_type                                ||stl-PairAssociativeContainer|           |The type of object,      |
|                                          |                                         |pair<const key_type,     |
|                                          |                                         |data_type>, stored in the|
|                                          |                                         |multimap.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|key_compare                               ||stl-SortedAssociativeContainer|         ||stl-functors| that      |
|                                          |                                         |compares two keys for    |
|                                          |                                         |ordering.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|value_compare                             ||stl-SortedAssociativeContainer|         ||stl-functors| that      |
|                                          |                                         |compares two values for  |
|                                          |                                         |ordering.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|pointer                                   ||stl-Container|                          |Pointer to T.            |
|------------------------------------------+-----------------------------------------+-------------------------|
|reference                                 ||stl-Container|                          |Reference to T           |
|------------------------------------------+-----------------------------------------+-------------------------|
|const_reference                           ||stl-Container|                          |Const reference to T     |
|------------------------------------------+-----------------------------------------+-------------------------|
|size_type                                 ||stl-Container|                          |An unsigned integral     |
|                                          |                                         |type.                    |
|------------------------------------------+-----------------------------------------+-------------------------|
|difference_type                           ||stl-Container|                          |A signed integral type.  |
|------------------------------------------+-----------------------------------------+-------------------------|
|iterator                                  ||stl-Container|                          |Iterator used to iterate |
|                                          |                                         |through a multimap.      |
|                                          |                                         |[4][1]                   |
|------------------------------------------+-----------------------------------------+-------------------------|
|const_iterator                            ||stl-Container|                          |Const iterator used to   |
|                                          |                                         |iterate through a        |
|                                          |                                         |multimap.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|reverse_iterator                          ||stl-ReversibleContainer|                |Iterator used to iterate |
|                                          |                                         |backwards through a      |
|                                          |                                         |multimap. [5][1]         |
|------------------------------------------+-----------------------------------------+-------------------------|
|const_reverse_iterator                    ||stl-ReversibleContainer|                |Const iterator used to   |
|                                          |                                         |iterate backwards through|
|                                          |                                         |a multimap.              |
|------------------------------------------+-----------------------------------------+-------------------------|
|iterator begin()                          ||stl-Container|                          |Returns an iterator      |
|                                          |                                         |pointing to the beginning|
|                                          |                                         |of the multimap.         |
|------------------------------------------+-----------------------------------------+-------------------------|
|iterator end()                            ||stl-Container|                          |Returns an iterator      |
|                                          |                                         |pointing to the end of   |
|                                          |                                         |the multimap.            |
|------------------------------------------+-----------------------------------------+-------------------------|
|const_iterator begin() const              ||stl-Container|                          |Returns a const_iterator |
|                                          |                                         |pointing to the beginning|
|                                          |                                         |of the multimap.         |
|------------------------------------------+-----------------------------------------+-------------------------|
|const_iterator end() const                ||stl-Container|                          |Returns a const_iterator |
|                                          |                                         |pointing to the end of   |
|                                          |                                         |the multimap.            |
|------------------------------------------+-----------------------------------------+-------------------------|
|reverse_iterator rbegin()                 ||stl-ReversibleContainer|                |Returns a                |
|                                          |                                         |reverse_iterator pointing|
|                                          |                                         |to the beginning of the  |
|                                          |                                         |reversed multimap.       |
|------------------------------------------+-----------------------------------------+-------------------------|
|reverse_iterator rend()                   ||stl-ReversibleContainer|                |Returns a                |
|                                          |                                         |reverse_iterator pointing|
|                                          |                                         |to the end of the        |
|                                          |                                         |reversed multimap.       |
|------------------------------------------+-----------------------------------------+-------------------------|
|const_reverse_iterator rbegin() const     ||stl-ReversibleContainer|                |Returns a                |
|                                          |                                         |const_reverse_iterator   |
|                                          |                                         |pointing to the beginning|
|                                          |                                         |of the reversed multimap.|
|------------------------------------------+-----------------------------------------+-------------------------|
|const_reverse_iterator rend() const       ||stl-ReversibleContainer|                |Returns a                |
|                                          |                                         |const_reverse_iterator   |
|                                          |                                         |pointing to the end of   |
|                                          |                                         |the reversed multimap.   |
|------------------------------------------+-----------------------------------------+-------------------------|
|size_type size() const                    ||stl-Container|                          |Returns the size of the  |
|                                          |                                         |multimap.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|size_type max_size() const                ||stl-Container|                          |Returns the largest      |
|                                          |                                         |possible size of the     |
|                                          |                                         |multimap.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|bool empty() const                        ||stl-Container|                          |true if the multimap's   |
|                                          |                                         |size is 0.               |
|------------------------------------------+-----------------------------------------+-------------------------|
|key_compare key_comp() const              ||stl-SortedAssociativeContainer|         |Returns the key_compare  |
|                                          |                                         |object used by the       |
|                                          |                                         |multimap.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|value_compare value_comp() const          ||stl-SortedAssociativeContainer|         |Returns the value_compare|
|                                          |                                         |object used by the       |
|                                          |                                         |multimap.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|multimap()                                ||stl-Container|                          |Creates an empty         |
|                                          |                                         |multimap.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|multimap(const key_compare& comp)         ||stl-SortedAssociativeContainer|         |Creates an empty         |
|                                          |                                         |multimap, using comp as  |
|                                          |                                         |the key_compare object.  |
|------------------------------------------+-----------------------------------------+-------------------------|
|template <class |stl-InputIterator|>      ||stl-MultipleSortedAssociativeContainer| |Creates a multimap with a|
|multimap(InputIterator f, InputIterator l)|                                         |copy of a range.         |
|[6][2]                                    |                                         |                         |
|------------------------------------------+-----------------------------------------+-------------------------|
|template <class |stl-InputIterator|>      ||stl-MultipleSortedAssociativeContainer| |Creates a multimap with a|
|multimap(InputIterator f, InputIterator l,|                                         |copy of a range, using   |
|         const key_compare& comp)         |                                         |comp as the key_compare  |
|[7][2]                                    |                                         |object.                  |
|------------------------------------------+-----------------------------------------+-------------------------|
|multimap(const multimap&)                 ||stl-Container|                          |The copy constructor.    |
|------------------------------------------+-----------------------------------------+-------------------------|
|multimap& operator=(const multimap&)      ||stl-Container|                          |The assignment operator  |
|------------------------------------------+-----------------------------------------+-------------------------|
|void swap(multimap&)                      ||stl-Container|                          |Swaps the contents of two|
|                                          |                                         |multimaps.               |
|------------------------------------------+-----------------------------------------+-------------------------|
|iterator insert(const value_type& x)      ||stl-MultipleAssociativeContainer|       |Inserts x into the       |
|                                          |                                         |multimap.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|iterator insert(iterator pos,             ||stl-MultipleSortedAssociativeContainer| |Inserts x into the       |
|                const value_type& x)      |                                         |multimap, using pos as a |
|                                          |                                         |hint to where it will be |
|                                          |                                         |inserted.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|template <class |stl-InputIterator|>      ||stl-MultipleSortedAssociativeContainer| |Inserts a range into the |
|void insert(InputIterator, InputIterator) |                                         |multimap.                |
|[8][2]                                    |                                         |                         |
|------------------------------------------+-----------------------------------------+-------------------------|
|void erase(iterator pos)                  ||stl-AssociativeContainer|               |Erases the element       |
|                                          |                                         |pointed to by pos.       |
|------------------------------------------+-----------------------------------------+-------------------------|
|size_type erase(const key_type& k)        ||stl-AssociativeContainer|               |Erases the element whose |
|                                          |                                         |key is k.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|void erase(iterator first, iterator last) ||stl-AssociativeContainer|               |Erases all elements in a |
|                                          |                                         |range.                   |
|------------------------------------------+-----------------------------------------+-------------------------|
|void clear()                              ||stl-AssociativeContainer|               |Erases all of the        |
|                                          |                                         |elements.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|iterator find(const key_type& k)          ||stl-AssociativeContainer|               |Finds an element whose   |
|                                          |                                         |key is k.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|const_iterator find(const key_type& k)    ||stl-AssociativeContainer|               |Finds an element whose   |
|const                                     |                                         |key is k.                |
|------------------------------------------+-----------------------------------------+-------------------------|
|size_type count(const key_type& k)        ||stl-AssociativeContainer|               |Counts the number of     |
|                                          |                                         |elements whose key is k. |
|------------------------------------------+-----------------------------------------+-------------------------|
|iterator lower_bound(const key_type& k)   ||stl-SortedAssociativeContainer|         |Finds the first element  |
|                                          |                                         |whose key is not less    |
|                                          |                                         |than k.                  |
|------------------------------------------+-----------------------------------------+-------------------------|
|const_iterator lower_bound(const key_type&||stl-SortedAssociativeContainer|         |Finds the first element  |
|k) const                                  |                                         |whose key is not less    |
|                                          |                                         |than k.                  |
|------------------------------------------+-----------------------------------------+-------------------------|
|iterator upper_bound(const key_type& k)   ||stl-SortedAssociativeContainer|         |Finds the first element  |
|                                          |                                         |whose key greater than k.|
|------------------------------------------+-----------------------------------------+-------------------------|
|const_iterator upper_bound(const key_type&||stl-SortedAssociativeContainer|         |Finds the first element  |
|k) const                                  |                                         |whose key greater than k.|
|------------------------------------------+-----------------------------------------+-------------------------|
|pair<iterator, iterator>                  ||stl-SortedAssociativeContainer|         |Finds a range containing |
|equal_range(const key_type& k)            |                                         |all elements whose key is|
|                                          |                                         |k.                       |
|------------------------------------------+-----------------------------------------+-------------------------|
|pair<const_iterator, const_iterator>      ||stl-SortedAssociativeContainer|         |Finds a range containing |
|equal_range(const key_type& k) const      |                                         |all elements whose key is|
|                                          |                                         |k.                       |
|------------------------------------------+-----------------------------------------+-------------------------|
|bool operator==(const multimap&,          ||stl-ForwardContainer|                   |Tests two multimaps for  |
|                const multimap&)          |                                         |equality. This is a      |
|                                          |                                         |global function, not a   |
|                                          |                                         |member function.         |
|------------------------------------------+-----------------------------------------+-------------------------|
|bool operator<(const multimap&,           ||stl-ForwardContainer|                   |Lexicographical          |
|               const multimap&)           |                                         |comparison. This is a    |
|                                          |                                         |global function, not a   |
|                                          |                                         |member function.         |
+--------------------------------------------------------------------------------------------------------------+

  New members

   All of multimap's members are defined in the
   |stl-MultipleSortedAssociativeContainer| and
   |stl-PairAssociativeContainer| requirements. Multimap does not introduce
   any new members.

  Notes

   [1] Multimap::iterator is not a mutable iterator, because
   multimap::value_type is not |stl-Assignable|. That is, if i is of type
   multimap::iterator and p is of type multimap::value_type, then *i = p is
   not a valid expression. However, multimap::iterator isn't a constant
   iterator either, because it can be used to modify the object that it
   points to. Using the same notation as above, (*i).second = p is a valid
   expression. The same point applies to multimap::reverse_iterator.

   [2] This member function relies on member template functions, which at
   present (early 1998) are not supported by all compilers. If your compiler
   supports member templates, you can call this function with any type of
   |stl-InputIterator|. If your compiler does not yet support member
   templates, though, then the arguments must either be of type const
   value_type* or of type multimap::const_iterator.

  See also

   |stl-AssociativeContainer|, |stl-SortedAssociativeContainer|,
   |stl-PairAssociativeContainer|, |stl-MultipleSortedAssociativeContainer|,
   |stl-set|, |stl-Map| |stl-multiset|, |stl-hash_set|, |stl-hash_map|,
   |stl-hash_multiset|, |stl-hash_multimap|

*stl-hash_set*

                    hash_set<Key, HashFcn, EqualKey, Alloc>

   Category: containers                                  Component type: type

  Description

   Hash_set is a |stl-HashedAssociativeContainer| that stores objects of type
   Key. Hash_set is a |stl-SimpleAssociativeContainer|, meaning that its
   value type, as well as its key type, is Key. It is also a
   |stl-UniqueAssociativeContainer|, meaning that no two elements compare
   equal using the |stl-BinaryPredicate| EqualKey.

   Hash_set is useful in applications where it is important to be able to
   search for an element quickly. If it is important for the elements to be
   in a particular order, however, then |stl-set| is more appropriate.

*stl-hash_set-example*

 struct eqstr
 {
   bool operator()(const char* s1, const char* s2) const
   {
     return strcmp(s1, s2) == 0;
   }
 };

 void lookup(const hash_set<const char*, hash<const char*>, eqstr>& Set,
             const char* word)
 {
   hash_set<const char*, hash<const char*>, eqstr>::const_iterator it
     = Set.find(word);
   cout << word << ": "
        << (it != Set.end() ? "present" : "not present")
        << endl;
 }

 int main()
 {
   hash_set<const char*, hash<const char*>, eqstr> Set;
   Set.insert("kiwi");
   Set.insert("plum");
   Set.insert("apple");
   Set.insert("mango");
   Set.insert("apricot");
   Set.insert("banana");

   lookup(Set, "mango");
   lookup(Set, "apple");
   lookup(Set, "durian");
 }

  Definition

   Defined in the header |stl-hash_set|, and in the backward-compatibility
   header |stl-hash_set|.h. This class is an SGI extension; it is not part of
   the C++ standard.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |             Description              |       Default       |
   |-----------+--------------------------------------+---------------------|
   | Key       | The hash_set's key type and value    |                     |
   |           | type. This is also defined as        |                     |
   |           | hash_set::key_type and               |                     |
   |           | hash_set::value_type                 |                     |
   |-----------+--------------------------------------+---------------------|
   | HashFcn   | The |stl-HashFunction| used by the   | |stl-hash|<Key>     |
   |           | hash_set. This is also defined as    |                     |
   |           | hash_set::hasher.                    |                     |
   |-----------+--------------------------------------+---------------------|
   | EqualKey  | The hash_set's key equality          | |stl-equal_to|<Key> |
   |           | function: a |stl-BinaryPredicate|    |                     |
   |           | that determines whether two keys are |                     |
   |           | equal. This is also defined as       |                     |
   |           | hash_set::key_equal.                 |                     |
   |-----------+--------------------------------------+---------------------|
   | Alloc     | The hash_set's allocator, used for   | |stl-Allocators|    |
   |           | all internal memory management.      |                     |
   +------------------------------------------------------------------------+

  Model of

   |stl-UniqueHashedAssociativeContainer|, |stl-SimpleAssociativeContainer|

  Type requirements

     * Key is |stl-Assignable|.
     * EqualKey is a |stl-BinaryPredicate| whose argument type is Key.
     * EqualKey is an equivalence relation.
     * Alloc is an |stl-Allocators|.

  Public base classes

   None.

  Members

+------------------------------------------------------------------------------------------------------------+
|                   Member                    |             Where defined             |     Description      |
|---------------------------------------------+---------------------------------------+----------------------|
|value_type                                   ||stl-Container|                        |The type of object, T,|
|                                             |                                       |stored in the         |
|                                             |                                       |hash_set.             |
|---------------------------------------------+---------------------------------------+----------------------|
|key_type                                     ||stl-AssociativeContainer|             |The key type          |
|                                             |                                       |associated with       |
|                                             |                                       |value_type.           |
|---------------------------------------------+---------------------------------------+----------------------|
|hasher                                       ||stl-HashedAssociativeContainer|       |The hash_set's        |
|                                             |                                       ||stl-HashFunction|.   |
|---------------------------------------------+---------------------------------------+----------------------|
|key_equal                                    ||stl-HashedAssociativeContainer|       ||stl-functors| that   |
|                                             |                                       |compares keys for     |
|                                             |                                       |equality.             |
|---------------------------------------------+---------------------------------------+----------------------|
|pointer                                      ||stl-Container|                        |Pointer to T.         |
|---------------------------------------------+---------------------------------------+----------------------|
|reference                                    ||stl-Container|                        |Reference to T        |
|---------------------------------------------+---------------------------------------+----------------------|
|const_reference                              ||stl-Container|                        |Const reference to T  |
|---------------------------------------------+---------------------------------------+----------------------|
|size_type                                    ||stl-Container|                        |An unsigned integral  |
|                                             |                                       |type.                 |
|---------------------------------------------+---------------------------------------+----------------------|
|difference_type                              ||stl-Container|                        |A signed integral     |
|                                             |                                       |type.                 |
|---------------------------------------------+---------------------------------------+----------------------|
|iterator                                     ||stl-Container|                        |Iterator used to      |
|                                             |                                       |iterate through a     |
|                                             |                                       |hash_set.             |
|---------------------------------------------+---------------------------------------+----------------------|
|const_iterator                               ||stl-Container|                        |Const iterator used to|
|                                             |                                       |iterate through a     |
|                                             |                                       |hash_set. (Iterator   |
|                                             |                                       |and const_iterator are|
|                                             |                                       |the same type.)       |
|---------------------------------------------+---------------------------------------+----------------------|
|iterator begin() const                       ||stl-Container|                        |Returns an iterator   |
|                                             |                                       |pointing to the       |
|                                             |                                       |beginning of the      |
|                                             |                                       |hash_set.             |
|---------------------------------------------+---------------------------------------+----------------------|
|iterator end() const                         ||stl-Container|                        |Returns an iterator   |
|                                             |                                       |pointing to the end of|
|                                             |                                       |the hash_set.         |
|---------------------------------------------+---------------------------------------+----------------------|
|size_type size() const                       ||stl-Container|                        |Returns the size of   |
|                                             |                                       |the hash_set.         |
|---------------------------------------------+---------------------------------------+----------------------|
|size_type max_size() const                   ||stl-Container|                        |Returns the largest   |
|                                             |                                       |possible size of the  |
|                                             |                                       |hash_set.             |
|---------------------------------------------+---------------------------------------+----------------------|
|bool empty() const                           ||stl-Container|                        |true if the hash_set's|
|                                             |                                       |size is 0.            |
|---------------------------------------------+---------------------------------------+----------------------|
|size_type bucket_count() const               ||stl-HashedAssociativeContainer|       |Returns the number of |
|                                             |                                       |buckets used by the   |
|                                             |                                       |hash_set.             |
|---------------------------------------------+---------------------------------------+----------------------|
|void resize(size_type n)                     ||stl-HashedAssociativeContainer|       |Increases the bucket  |
|                                             |                                       |count to at least n.  |
|---------------------------------------------+---------------------------------------+----------------------|
|hasher hash_funct() const                    ||stl-HashedAssociativeContainer|       |Returns the hasher    |
|                                             |                                       |object used by the    |
|                                             |                                       |hash_set.             |
|---------------------------------------------+---------------------------------------+----------------------|
|key_equal key_eq() const                     ||stl-HashedAssociativeContainer|       |Returns the key_equal |
|                                             |                                       |object used by the    |
|                                             |                                       |hash_set.             |
|---------------------------------------------+---------------------------------------+----------------------|
|hash_set()                                   ||stl-Container|                        |Creates an empty      |
|                                             |                                       |hash_set.             |
|---------------------------------------------+---------------------------------------+----------------------|
|hash_set(size_type n)                        ||stl-HashedAssociativeContainer|       |Creates an empty      |
|                                             |                                       |hash_set with at least|
|                                             |                                       |n buckets.            |
|---------------------------------------------+---------------------------------------+----------------------|
|hash_set(size_type n,                        ||stl-HashedAssociativeContainer|       |Creates an empty      |
|         const hasher& h)                    |                                       |hash_set with at least|
|                                             |                                       |n buckets, using h as |
|                                             |                                       |the hash function.    |
|---------------------------------------------+---------------------------------------+----------------------|
|hash_set(size_type n,                        ||stl-HashedAssociativeContainer|       |Creates an empty      |
|         const hasher& h,                    |                                       |hash_set with at least|
|         const key_equal& k)                 |                                       |n buckets, using h as |
|                                             |                                       |the hash function and |
|                                             |                                       |k as the key equal    |
|                                             |                                       |function.             |
|---------------------------------------------+---------------------------------------+----------------------|
|template <class |stl-InputIterator|>         ||stl-UniqueHashedAssociativeContainer| |Creates a hash_set    |
|hash_set(InputIterator f, InputIterator l)   |                                       |with a copy of a      |
|[4][1]                                       |                                       |range.                |
|---------------------------------------------+---------------------------------------+----------------------|
|template <class |stl-InputIterator|>         ||stl-UniqueHashedAssociativeContainer| |Creates a hash_set    |
|hash_set(InputIterator f, InputIterator l,   |                                       |with a copy of a range|
|         size_type n)                        |                                       |and a bucket count of |
|[5][1]                                       |                                       |at least n.           |
|---------------------------------------------+---------------------------------------+----------------------|
|template <class |stl-InputIterator|>         ||stl-UniqueHashedAssociativeContainer| |Creates a hash_set    |
|hash_set(InputIterator f, InputIterator l,   |                                       |with a copy of a range|
|         size_type n, const hasher& h)       |                                       |and a bucket count of |
|[6][1]                                       |                                       |at least n, using h as|
|                                             |                                       |the hash function.    |
|---------------------------------------------+---------------------------------------+----------------------|
|hash_set(InputIterator f, InputIterator l,   ||stl-UniqueHashedAssociativeContainer| |Creates a hash_set    |
|         size_type n, const hasher& h,       |                                       |with a copy of a range|
|         const key_equal& k)                 |                                       |and a bucket count of |
|[7][1]                                       |                                       |at least n, using h as|
|                                             |                                       |the hash function and |
|                                             |                                       |k as the key equal    |
|                                             |                                       |function.             |
|---------------------------------------------+---------------------------------------+----------------------|
|hash_set(const hash_set&)                    ||stl-Container|                        |The copy constructor. |
|---------------------------------------------+---------------------------------------+----------------------|
|hash_set& operator=(const hash_set&)         ||stl-Container|                        |The assignment        |
|                                             |                                       |operator              |
|---------------------------------------------+---------------------------------------+----------------------|
|void swap(hash_set&)                         ||stl-Container|                        |Swaps the contents of |
|                                             |                                       |two hash_sets.        |
|---------------------------------------------+---------------------------------------+----------------------|
|pair<iterator, bool>                         ||stl-UniqueAssociativeContainer|       |Inserts x into the    |
|insert(const value_type& x)                  |                                       |hash_set.             |
|---------------------------------------------+---------------------------------------+----------------------|
|template <class |stl-InputIterator|>         ||stl-UniqueAssociativeContainer|       |Inserts a range into  |
|void insert(InputIterator f, InputIterator l)|                                       |the hash_set.         |
|[8][1]                                       |                                       |                      |
|---------------------------------------------+---------------------------------------+----------------------|
|void erase(iterator pos)                     ||stl-AssociativeContainer|             |Erases the element    |
|                                             |                                       |pointed to by pos.    |
|---------------------------------------------+---------------------------------------+----------------------|
|size_type erase(const key_type& k)           ||stl-AssociativeContainer|             |Erases the element    |
|                                             |                                       |whose key is k.       |
|---------------------------------------------+---------------------------------------+----------------------|
|void erase(iterator first, iterator last)    ||stl-AssociativeContainer|             |Erases all elements in|
|                                             |                                       |a range.              |
|---------------------------------------------+---------------------------------------+----------------------|
|void clear()                                 ||stl-AssociativeContainer|             |Erases all of the     |
|                                             |                                       |elements.             |
|---------------------------------------------+---------------------------------------+----------------------|
|iterator find(const key_type& k) const       ||stl-AssociativeContainer|             |Finds an element whose|
|                                             |                                       |key is k.             |
|---------------------------------------------+---------------------------------------+----------------------|
|size_type count(const key_type& k) const     ||stl-UniqueAssociativeContainer|       |Counts the number of  |
|                                             |                                       |elements whose key is |
|                                             |                                       |k.                    |
|---------------------------------------------+---------------------------------------+----------------------|
|pair<iterator, iterator>                     ||stl-AssociativeContainer|             |Finds a range         |
|equal_range(const key_type& k) const         |                                       |containing all        |
|                                             |                                       |elements whose key is |
|                                             |                                       |k.                    |
|---------------------------------------------+---------------------------------------+----------------------|
|bool operator==(const hash_set&,             ||stl-HashedAssociativeContainer|       |Tests two hash_sets   |
|                const hash_set&)             |                                       |for equality. This is |
|                                             |                                       |a global function, not|
|                                             |                                       |a member function.    |
+------------------------------------------------------------------------------------------------------------+

  New members

   All of hash_set's members are defined in the
   |stl-UniqueHashedAssociativeContainer| and
   |stl-SimpleAssociativeContainer| requirements. Hash_set does not introduce
   any new members.

  Notes

   [1] This member function relies on member template functions, which at
   present (early 1998) are not supported by all compilers. If your compiler
   supports member templates, you can call this function with any type of
   |stl-InputIterator|. If your compiler does not yet support member
   templates, though, then the arguments must either be of type const
   value_type* or of type hash_set::const_iterator.

  See also

   |stl-AssociativeContainer|, |stl-HashedAssociativeContainer|,
   |stl-SimpleAssociativeContainer|, |stl-UniqueHashedAssociativeContainer|,
   |stl-set|, |stl-Map|, |stl-multiset|, |stl-Multimap|, |stl-hash_map|,
   |stl-hash_multiset|, |stl-hash_multimap|

*stl-hash_map*

                 hash_map<Key, Data, HashFcn, EqualKey, Alloc>

   Category: containers                                  Component type: type

  Description

   Hash_map is a |stl-HashedAssociativeContainer| that associates objects of
   type Key with objects of type Data. Hash_map is a
   |stl-PairAssociativeContainer|, meaning that its value type is
   |stl-pair|<const Key, Data>. It is also a
   |stl-UniqueAssociativeContainer|, meaning that no two elements have keys
   that compare equal using EqualKey.

   Looking up an element in a hash_map by its key is efficient, so hash_map
   is useful for "dictionaries" where the order of elements is irrelevant. If
   it is important for the elements to be in a particular order, however,
   then |stl-Map| is more appropriate.

*stl-hash_map-example*

 struct eqstr
 {
   bool operator()(const char* s1, const char* s2) const
   {
     return strcmp(s1, s2) == 0;
   }
 };

 int main()
 {
   hash_map<const char*, int, hash<const char*>, eqstr> months;

   months["january"] = 31;
   months["february"] = 28;
   months["march"] = 31;
   months["april"] = 30;
   months["may"] = 31;
   months["june"] = 30;
   months["july"] = 31;
   months["august"] = 31;
   months["september"] = 30;
   months["october"] = 31;
   months["november"] = 30;
   months["december"] = 31;

   cout << "september -> " << months["september"] << endl;
   cout << "april     -> " << months["april"] << endl;
   cout << "june      -> " << months["june"] << endl;
   cout << "november  -> " << months["november"] << endl;
 }

  Definition

   Defined in the header |stl-hash_map|, and in the backward-compatibility
   header |stl-hash_map|.h. This class is an SGI extension; it is not part of
   the C++ standard.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |             Description              |       Default       |
   |-----------+--------------------------------------+---------------------|
   | Key       | The hash_map's key type. This is     |                     |
   |           | also defined as hash_map::key_type.  |                     |
   |-----------+--------------------------------------+---------------------|
   | Data      | The hash_map's data type. This is    |                     |
   |           | also defined as hash_map::data_type. |                     |
   |-----------+--------------------------------------+---------------------|
   | HashFcn   | The |stl-HashFunction| used by the   | |stl-hash|<Key>     |
   |           | hash_map. This is also defined as    |                     |
   |           | hash_map::hasher.                    |                     |
   |-----------+--------------------------------------+---------------------|
   | EqualKey  | The hash_map key equality function:  | |stl-equal_to|<Key> |
   |           | a |stl-BinaryPredicate| that         |                     |
   |           | determines whether two keys are      |                     |
   |           | equal. This is also defined as       |                     |
   |           | hash_map::key_equal.                 |                     |
   |-----------+--------------------------------------+---------------------|
   | Alloc     | The hash_map's allocator, used for   | |stl-Allocators|    |
   |           | all internal memory management.      |                     |
   +------------------------------------------------------------------------+

  Model of

   |stl-UniqueHashedAssociativeContainer|, |stl-PairAssociativeContainer|

  Type requirements

     * Key is |stl-Assignable|.
     * EqualKey is a |stl-BinaryPredicate| whose argument type is Key.
     * EqualKey is an equivalence relation.
     * Alloc is an |stl-Allocators|.

  Public base classes

   None.

  Members

+------------------------------------------------------------------------------------------------------------+
|                   Member                    |             Where defined             |     Description      |
|---------------------------------------------+---------------------------------------+----------------------|
|key_type                                     ||stl-AssociativeContainer|             |The hash_map's key    |
|                                             |                                       |type, Key.            |
|---------------------------------------------+---------------------------------------+----------------------|
|data_type                                    ||stl-PairAssociativeContainer|         |The type of object    |
|                                             |                                       |associated with the   |
|                                             |                                       |keys.                 |
|---------------------------------------------+---------------------------------------+----------------------|
|value_type                                   ||stl-PairAssociativeContainer|         |The type of object,   |
|                                             |                                       |pair<const key_type,  |
|                                             |                                       |data_type>, stored in |
|                                             |                                       |the hash_map.         |
|---------------------------------------------+---------------------------------------+----------------------|
|hasher                                       ||stl-HashedAssociativeContainer|       |The hash_map's        |
|                                             |                                       ||stl-HashFunction|.   |
|---------------------------------------------+---------------------------------------+----------------------|
|key_equal                                    ||stl-HashedAssociativeContainer|       ||stl-functors| that   |
|                                             |                                       |compares keys for     |
|                                             |                                       |equality.             |
|---------------------------------------------+---------------------------------------+----------------------|
|pointer                                      ||stl-Container|                        |Pointer to T.         |
|---------------------------------------------+---------------------------------------+----------------------|
|reference                                    ||stl-Container|                        |Reference to T        |
|---------------------------------------------+---------------------------------------+----------------------|
|const_reference                              ||stl-Container|                        |Const reference to T  |
|---------------------------------------------+---------------------------------------+----------------------|
|size_type                                    ||stl-Container|                        |An unsigned integral  |
|                                             |                                       |type.                 |
|---------------------------------------------+---------------------------------------+----------------------|
|difference_type                              ||stl-Container|                        |A signed integral     |
|                                             |                                       |type.                 |
|---------------------------------------------+---------------------------------------+----------------------|
|iterator                                     ||stl-Container|                        |Iterator used to      |
|                                             |                                       |iterate through a     |
|                                             |                                       |hash_map. [4][1]      |
|---------------------------------------------+---------------------------------------+----------------------|
|const_iterator                               ||stl-Container|                        |Const iterator used to|
|                                             |                                       |iterate through a     |
|                                             |                                       |hash_map.             |
|---------------------------------------------+---------------------------------------+----------------------|
|iterator begin()                             ||stl-Container|                        |Returns an iterator   |
|                                             |                                       |pointing to the       |
|                                             |                                       |beginning of the      |
|                                             |                                       |hash_map.             |
|---------------------------------------------+---------------------------------------+----------------------|
|iterator end()                               ||stl-Container|                        |Returns an iterator   |
|                                             |                                       |pointing to the end of|
|                                             |                                       |the hash_map.         |
|---------------------------------------------+---------------------------------------+----------------------|
|const_iterator begin() const                 ||stl-Container|                        |Returns an            |
|                                             |                                       |const_iterator        |
|                                             |                                       |pointing to the       |
|                                             |                                       |beginning of the      |
|                                             |                                       |hash_map.             |
|---------------------------------------------+---------------------------------------+----------------------|
|const_iterator end() const                   ||stl-Container|                        |Returns an            |
|                                             |                                       |const_iterator        |
|                                             |                                       |pointing to the end of|
|                                             |                                       |the hash_map.         |
|---------------------------------------------+---------------------------------------+----------------------|
|size_type size() const                       ||stl-Container|                        |Returns the size of   |
|                                             |                                       |the hash_map.         |
|---------------------------------------------+---------------------------------------+----------------------|
|size_type max_size() const                   ||stl-Container|                        |Returns the largest   |
|                                             |                                       |possible size of the  |
|                                             |                                       |hash_map.             |
|---------------------------------------------+---------------------------------------+----------------------|
|bool empty() const                           ||stl-Container|                        |true if the hash_map's|
|                                             |                                       |size is 0.            |
|---------------------------------------------+---------------------------------------+----------------------|
|size_type bucket_count() const               ||stl-HashedAssociativeContainer|       |Returns the number of |
|                                             |                                       |buckets used by the   |
|                                             |                                       |hash_map.             |
|---------------------------------------------+---------------------------------------+----------------------|
|void resize(size_type n)                     ||stl-HashedAssociativeContainer|       |Increases the bucket  |
|                                             |                                       |count to at least n.  |
|---------------------------------------------+---------------------------------------+----------------------|
|hasher hash_funct() const                    ||stl-HashedAssociativeContainer|       |Returns the hasher    |
|                                             |                                       |object used by the    |
|                                             |                                       |hash_map.             |
|---------------------------------------------+---------------------------------------+----------------------|
|key_equal key_eq() const                     ||stl-HashedAssociativeContainer|       |Returns the key_equal |
|                                             |                                       |object used by the    |
|                                             |                                       |hash_map.             |
|---------------------------------------------+---------------------------------------+----------------------|
|hash_map()                                   ||stl-Container|                        |Creates an empty      |
|                                             |                                       |hash_map.             |
|---------------------------------------------+---------------------------------------+----------------------|
|hash_map(size_type n)                        ||stl-HashedAssociativeContainer|       |Creates an empty      |
|                                             |                                       |hash_map with at least|
|                                             |                                       |n buckets.            |
|---------------------------------------------+---------------------------------------+----------------------|
|hash_map(size_type n,                        ||stl-HashedAssociativeContainer|       |Creates an empty      |
|         const hasher& h)                    |                                       |hash_map with at least|
|                                             |                                       |n buckets, using h as |
|                                             |                                       |the hash function.    |
|---------------------------------------------+---------------------------------------+----------------------|
|hash_map(size_type n,                        ||stl-HashedAssociativeContainer|       |Creates an empty      |
|         const hasher& h,                    |                                       |hash_map with at least|
|         const key_equal& k)                 |                                       |n buckets, using h as |
|                                             |                                       |the hash function and |
|                                             |                                       |k as the key equal    |
|                                             |                                       |function.             |
|---------------------------------------------+---------------------------------------+----------------------|
|template <class |stl-InputIterator|>         ||stl-UniqueHashedAssociativeContainer| |Creates a hash_map    |
|hash_map(InputIterator f, InputIterator l)   |                                       |with a copy of a      |
|[5][2]                                       |                                       |range.                |
|---------------------------------------------+---------------------------------------+----------------------|
|template <class |stl-InputIterator|>         ||stl-UniqueHashedAssociativeContainer| |Creates a hash_map    |
|hash_map(InputIterator f, InputIterator l,   |                                       |with a copy of a range|
|         size_type n)                        |                                       |and a bucket count of |
|[6][2]                                       |                                       |at least n.           |
|---------------------------------------------+---------------------------------------+----------------------|
|template <class |stl-InputIterator|>         ||stl-UniqueHashedAssociativeContainer| |Creates a hash_map    |
|hash_map(InputIterator f, InputIterator l,   |                                       |with a copy of a range|
|         size_type n, const hasher& h)       |                                       |and a bucket count of |
|[7][2]                                       |                                       |at least n, using h as|
|                                             |                                       |the hash function.    |
|---------------------------------------------+---------------------------------------+----------------------|
|template <class |stl-InputIterator|>         ||stl-UniqueHashedAssociativeContainer| |Creates a hash_map    |
|hash_map(InputIterator f, InputIterator l,   |                                       |with a copy of a range|
|         size_type n, const hasher& h,       |                                       |and a bucket count of |
|         const key_equal& k)                 |                                       |at least n, using h as|
|[8][2]                                       |                                       |the hash function and |
|                                             |                                       |k as the key equal    |
|                                             |                                       |function.             |
|---------------------------------------------+---------------------------------------+----------------------|
|hash_map(const hash_map&)                    ||stl-Container|                        |The copy constructor. |
|---------------------------------------------+---------------------------------------+----------------------|
|hash_map& operator=(const hash_map&)         ||stl-Container|                        |The assignment        |
|                                             |                                       |operator              |
|---------------------------------------------+---------------------------------------+----------------------|
|void swap(hash_map&)                         ||stl-Container|                        |Swaps the contents of |
|                                             |                                       |two hash_maps.        |
|---------------------------------------------+---------------------------------------+----------------------|
|pair<iterator, bool>                         ||stl-UniqueAssociativeContainer|       |Inserts x into the    |
|insert(const value_type& x)                  |                                       |hash_map.             |
|---------------------------------------------+---------------------------------------+----------------------|
|template <class |stl-InputIterator|>         ||stl-UniqueAssociativeContainer|       |Inserts a range into  |
|void insert(InputIterator f, InputIterator l)|                                       |the hash_map.         |
|[9][2]                                       |                                       |                      |
|---------------------------------------------+---------------------------------------+----------------------|
|void erase(iterator pos)                     ||stl-AssociativeContainer|             |Erases the element    |
|                                             |                                       |pointed to by pos.    |
|---------------------------------------------+---------------------------------------+----------------------|
|size_type erase(const key_type& k)           ||stl-AssociativeContainer|             |Erases the element    |
|                                             |                                       |whose key is k.       |
|---------------------------------------------+---------------------------------------+----------------------|
|void erase(iterator first, iterator last)    ||stl-AssociativeContainer|             |Erases all elements in|
|                                             |                                       |a range.              |
|---------------------------------------------+---------------------------------------+----------------------|
|void clear()                                 ||stl-AssociativeContainer|             |Erases all of the     |
|                                             |                                       |elements.             |
|---------------------------------------------+---------------------------------------+----------------------|
|const_iterator find(const key_type& k) const ||stl-AssociativeContainer|             |Finds an element whose|
|                                             |                                       |key is k.             |
|---------------------------------------------+---------------------------------------+----------------------|
|iterator find(const key_type& k)             ||stl-AssociativeContainer|             |Finds an element whose|
|                                             |                                       |key is k.             |
|---------------------------------------------+---------------------------------------+----------------------|
|size_type count(const key_type& k) const     ||stl-UniqueAssociativeContainer|       |Counts the number of  |
|                                             |                                       |elements whose key is |
|                                             |                                       |k.                    |
|---------------------------------------------+---------------------------------------+----------------------|
|pair<const_iterator, const_iterator>         ||stl-AssociativeContainer|             |Finds a range         |
|equal_range(const key_type& k) const         |                                       |containing all        |
|                                             |                                       |elements whose key is |
|                                             |                                       |k.                    |
|---------------------------------------------+---------------------------------------+----------------------|
|pair<iterator, iterator>                     ||stl-AssociativeContainer|             |Finds a range         |
|equal_range(const key_type& k)               |                                       |containing all        |
|                                             |                                       |elements whose key is |
|                                             |                                       |k.                    |
|---------------------------------------------+---------------------------------------+----------------------|
|data_type&                                   |hash_map                               |See below.            |
|operator[](const key_type& k) [10][3]        |                                       |                      |
|---------------------------------------------+---------------------------------------+----------------------|
|bool operator==(const hash_map&,             ||stl-HashedAssociativeContainer|       |Tests two hash_maps   |
|                const hash_map&)             |                                       |for equality. This is |
|                                             |                                       |a global function, not|
|                                             |                                       |a member function.    |
+------------------------------------------------------------------------------------------------------------+

  New members

   These members are not defined in the
   |stl-UniqueHashedAssociativeContainer| and |stl-PairAssociativeContainer|
   requirements, but are specific to hash_map.

   +------------------------------------------------------------------------+
   |               Member                |           Description            |
   |-------------------------------------+----------------------------------|
   |data_type&                           | Returns a reference to the       |
   |operator[](const key_type& k) [11][3]| object that is associated with a |
   |                                     | particular key. If the hash_map  |
   |                                     | does not already contain such an |
   |                                     | object, operator[] inserts the   |
   |                                     | default object data_type().      |
   |                                     | [12][3]                          |
   +------------------------------------------------------------------------+

  Notes

   [1] Hash_map::iterator is not a mutable iterator, because
   hash_map::value_type is not |stl-Assignable|. That is, if i is of type
   hash_map::iterator and p is of type hash_map::value_type, then *i = p is
   not a valid expression. However, hash_map::iterator isn't a constant
   iterator either, because it can be used to modify the object that it
   points to. Using the same notation as above, (*i).second = p is a valid
   expression.

   [2] This member function relies on member template functions, which at
   present (early 1998) are not supported by all compilers. If your compiler
   supports member templates, you can call this function with any type of
   |stl-InputIterator|. If your compiler does not yet support member
   templates, though, then the arguments must either be of type const
   value_type* or of type hash_map::const_iterator.

   [3] Since operator[] might insert a new element into the hash_map, it
   can't possibly be a const member function. Note that the definition of
   operator[] is extremely simple: m[k] is equivalent to
   (*((m.insert(value_type(k, data_type()))).first)).second. Strictly
   speaking, this member function is unnecessary: it exists only for
   convenience.

  See also

   |stl-AssociativeContainer|, |stl-HashedAssociativeContainer|,
   |stl-PairAssociativeContainer|, |stl-UniqueHashedAssociativeContainer|,
   |stl-set|, |stl-Map| |stl-multiset|, |stl-Multimap|, |stl-hash_set|,
   |stl-hash_multiset|, |stl-hash_multimap|

*stl-hash_multiset*

                  hash_multiset<Key, HashFcn, EqualKey, Alloc>

   Category: containers                                  Component type: type

  Description

   Hash_multiset is a |stl-HashedAssociativeContainer| that stores objects of
   type Key. Hash_multiset is a |stl-SimpleAssociativeContainer|, meaning
   that its value type, as well as its key type, is Key. It is also a
   |stl-MultipleAssociativeContainer|, meaning that two or more elements may
   compare equal using the |stl-BinaryPredicate| EqualKey.

   Hash_multiset is useful in applications where it is important to be able
   to search for an element quickly. If it is important for the elements to
   be in a particular order, however, then |stl-multiset| is more
   appropriate.

*stl-hash_multiset-example*

 struct eqstr
 {
   bool operator()(const char* s1, const char* s2) const
   {
     return strcmp(s1, s2) == 0;
   }
 };

 void lookup(const hash_multiset<const char*, hash<const char*>, eqstr>& Set,
             const char* word)
 {
   int n_found = Set.count(word);
   cout << word << ": "
        << n_found << " "
        << (n_found == 1 ? "instance" : "instances")
        << endl;
 }

 int main()
 {
   hash_multiset<const char*, hash<const char*>, eqstr> Set;
   Set.insert("mango");
   Set.insert("kiwi");
   Set.insert("apple");
   Set.insert("kiwi");
   Set.insert("mango");
   Set.insert("mango");
   Set.insert("apricot");
   Set.insert("banana");
   Set.insert("mango");

   lookup(Set, "mango");
   lookup(Set, "apple");
   lookup(Set, "durian");
 }

  Definition

   Defined in the header |stl-hash_set|, and in the backward-compatibility
   header |stl-hash_set|.h. This class is an SGI extension; it is not part of
   the C++ standard.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |             Description              |       Default       |
   |-----------+--------------------------------------+---------------------|
   | Key       | The hash_multiset's key type and     |                     |
   |           | value type. This is also defined as  |                     |
   |           | hash_multiset::key_type and          |                     |
   |           | hash_multiset::value_type            |                     |
   |-----------+--------------------------------------+---------------------|
   | HashFcn   | The |stl-HashFunction| used by the   | |stl-hash|<Key>     |
   |           | hash_multiset. This is also defined  |                     |
   |           | as hash_multiset::hasher.            |                     |
   |-----------+--------------------------------------+---------------------|
   | EqualKey  | The hash_multiset's key equality     | |stl-equal_to|<Key> |
   |           | function: a |stl-BinaryPredicate|    |                     |
   |           | that determines whether two keys are |                     |
   |           | equal. This is also defined as       |                     |
   |           | hash_multiset::key_equal.            |                     |
   |-----------+--------------------------------------+---------------------|
   | Alloc     | The hash_multiset's allocator, used  | |stl-Allocators|    |
   |           | for all internal memory management.  |                     |
   +------------------------------------------------------------------------+

  Model of

   |stl-MultipleHashedAssociativeContainer|, |stl-SimpleAssociativeContainer|

  Type requirements

     * Key is |stl-Assignable|.
     * EqualKey is a |stl-BinaryPredicate| whose argument type is Key.
     * EqualKey is an equivalence relation.
     * Alloc is an |stl-Allocators|.

  Public base classes

   None.

  Members

+-------------------------------------------------------------------------------------------------------------+
|                   Member                   |              Where defined              |     Description      |
|--------------------------------------------+-----------------------------------------+----------------------|
|value_type                                  ||stl-Container|                          |The type of object, T,|
|                                            |                                         |stored in the         |
|                                            |                                         |hash_multiset.        |
|--------------------------------------------+-----------------------------------------+----------------------|
|key_type                                    ||stl-AssociativeContainer|               |The key type          |
|                                            |                                         |associated with       |
|                                            |                                         |value_type.           |
|--------------------------------------------+-----------------------------------------+----------------------|
|hasher                                      ||stl-HashedAssociativeContainer|         |The hash_multiset's   |
|                                            |                                         ||stl-HashFunction|.   |
|--------------------------------------------+-----------------------------------------+----------------------|
|key_equal                                   ||stl-HashedAssociativeContainer|         ||stl-functors| that   |
|                                            |                                         |compares keys for     |
|                                            |                                         |equality.             |
|--------------------------------------------+-----------------------------------------+----------------------|
|pointer                                     ||stl-Container|                          |Pointer to T.         |
|--------------------------------------------+-----------------------------------------+----------------------|
|reference                                   ||stl-Container|                          |Reference to T        |
|--------------------------------------------+-----------------------------------------+----------------------|
|const_reference                             ||stl-Container|                          |Const reference to T  |
|--------------------------------------------+-----------------------------------------+----------------------|
|size_type                                   ||stl-Container|                          |An unsigned integral  |
|                                            |                                         |type.                 |
|--------------------------------------------+-----------------------------------------+----------------------|
|difference_type                             ||stl-Container|                          |A signed integral     |
|                                            |                                         |type.                 |
|--------------------------------------------+-----------------------------------------+----------------------|
|iterator                                    ||stl-Container|                          |Iterator used to      |
|                                            |                                         |iterate through a     |
|                                            |                                         |hash_multiset.        |
|--------------------------------------------+-----------------------------------------+----------------------|
|const_iterator                              ||stl-Container|                          |Const iterator used to|
|                                            |                                         |iterate through a     |
|                                            |                                         |hash_multiset.        |
|                                            |                                         |(Iterator and         |
|                                            |                                         |const_iterator are the|
|                                            |                                         |same type.)           |
|--------------------------------------------+-----------------------------------------+----------------------|
|iterator begin() const                      ||stl-Container|                          |Returns an iterator   |
|                                            |                                         |pointing to the       |
|                                            |                                         |beginning of the      |
|                                            |                                         |hash_multiset.        |
|--------------------------------------------+-----------------------------------------+----------------------|
|iterator end() const                        ||stl-Container|                          |Returns an iterator   |
|                                            |                                         |pointing to the end of|
|                                            |                                         |the hash_multiset.    |
|--------------------------------------------+-----------------------------------------+----------------------|
|size_type size() const                      ||stl-Container|                          |Returns the size of   |
|                                            |                                         |the hash_multiset.    |
|--------------------------------------------+-----------------------------------------+----------------------|
|size_type max_size() const                  ||stl-Container|                          |Returns the largest   |
|                                            |                                         |possible size of the  |
|                                            |                                         |hash_multiset.        |
|--------------------------------------------+-----------------------------------------+----------------------|
|bool empty() const                          ||stl-Container|                          |true if the           |
|                                            |                                         |hash_multiset's size  |
|                                            |                                         |is 0.                 |
|--------------------------------------------+-----------------------------------------+----------------------|
|size_type bucket_count() const              ||stl-HashedAssociativeContainer|         |Returns the number of |
|                                            |                                         |buckets used by the   |
|                                            |                                         |hash_multiset.        |
|--------------------------------------------+-----------------------------------------+----------------------|
|void resize(size_type n)                    ||stl-HashedAssociativeContainer|         |Increases the bucket  |
|                                            |                                         |count to at least n.  |
|--------------------------------------------+-----------------------------------------+----------------------|
|hasher hash_funct() const                   ||stl-HashedAssociativeContainer|         |Returns the hasher    |
|                                            |                                         |object used by the    |
|                                            |                                         |hash_multiset.        |
|--------------------------------------------+-----------------------------------------+----------------------|
|key_equal key_eq() const                    ||stl-HashedAssociativeContainer|         |Returns the key_equal |
|                                            |                                         |object used by the    |
|                                            |                                         |hash_multiset.        |
|--------------------------------------------+-----------------------------------------+----------------------|
|hash_multiset()                             ||stl-Container|                          |Creates an empty      |
|                                            |                                         |hash_multiset.        |
|--------------------------------------------+-----------------------------------------+----------------------|
|hash_multiset(size_type n)                  ||stl-HashedAssociativeContainer|         |Creates an empty      |
|                                            |                                         |hash_multiset with at |
|                                            |                                         |least n buckets.      |
|--------------------------------------------+-----------------------------------------+----------------------|
|hash_multiset(size_type n,                  ||stl-HashedAssociativeContainer|         |Creates an empty      |
|              const hasher& h)              |                                         |hash_multiset with at |
|                                            |                                         |least n buckets, using|
|                                            |                                         |h as the hash         |
|                                            |                                         |function.             |
|--------------------------------------------+-----------------------------------------+----------------------|
|hash_multiset(size_type n,                  ||stl-HashedAssociativeContainer|         |Creates an empty      |
|              const hasher& h,              |                                         |hash_multiset with at |
|              const key_equal& k)           |                                         |least n buckets, using|
|                                            |                                         |h as the hash function|
|                                            |                                         |and k as the key equal|
|                                            |                                         |function.             |
|--------------------------------------------+-----------------------------------------+----------------------|
|template <class |stl-InputIterator|>        ||stl-MultipleHashedAssociativeContainer| |Creates a             |
|hash_multiset(InputIterator, InputIterator) |                                         |hash_multiset with a  |
|[4][1]                                      |                                         |copy of a range.      |
|--------------------------------------------+-----------------------------------------+----------------------|
|template <class |stl-InputIterator|>        ||stl-MultipleHashedAssociativeContainer| |Creates a             |
|hash_multiset(InputIterator, InputIterator, |                                         |hash_multiset with a  |
|              size_type n)                  |                                         |copy of a range and a |
|[5][1]                                      |                                         |bucket count of at    |
|                                            |                                         |least n.              |
|--------------------------------------------+-----------------------------------------+----------------------|
|template <class |stl-InputIterator|>        ||stl-MultipleHashedAssociativeContainer| |Creates a             |
|hash_multiset(InputIterator, InputIterator, |                                         |hash_multiset with a  |
|              size_type n, const hasher& h) |                                         |copy of a range and a |
|[6][1]                                      |                                         |bucket count of at    |
|                                            |                                         |least n, using h as   |
|                                            |                                         |the hash function.    |
|--------------------------------------------+-----------------------------------------+----------------------|
|template <class |stl-InputIterator|>        ||stl-MultipleHashedAssociativeContainer| |Creates a             |
|hash_multiset(InputIterator, InputIterator, |                                         |hash_multiset with a  |
|              size_type n, const hasher& h, |                                         |copy of a range and a |
|              const key_equal& k)           |                                         |bucket count of at    |
|[7][1]                                      |                                         |least n, using h as   |
|                                            |                                         |the hash function and |
|                                            |                                         |k as the key equal    |
|                                            |                                         |function.             |
|--------------------------------------------+-----------------------------------------+----------------------|
|hash_multiset(const hash_multiset&)         ||stl-Container|                          |The copy constructor. |
|--------------------------------------------+-----------------------------------------+----------------------|
|hash_multiset& operator=(const              ||stl-Container|                          |The assignment        |
|hash_multiset&)                             |                                         |operator              |
|--------------------------------------------+-----------------------------------------+----------------------|
|void swap(hash_multiset&)                   ||stl-Container|                          |Swaps the contents of |
|                                            |                                         |two hash_multisets.   |
|--------------------------------------------+-----------------------------------------+----------------------|
|iterator insert(const value_type& x)        ||stl-MultipleAssociativeContainer|       |Inserts x into the    |
|                                            |                                         |hash_multiset.        |
|--------------------------------------------+-----------------------------------------+----------------------|
|template <class |stl-InputIterator|>        ||stl-MultipleAssociativeContainer|       |Inserts a range into  |
|void insert(InputIterator, InputIterator)   |                                         |the hash_multiset.    |
|[8][1]                                      |                                         |                      |
|--------------------------------------------+-----------------------------------------+----------------------|
|void erase(iterator pos)                    ||stl-AssociativeContainer|               |Erases the element    |
|                                            |                                         |pointed to by pos.    |
|--------------------------------------------+-----------------------------------------+----------------------|
|size_type erase(const key_type& k)          ||stl-AssociativeContainer|               |Erases the element    |
|                                            |                                         |whose key is k.       |
|--------------------------------------------+-----------------------------------------+----------------------|
|void erase(iterator first, iterator last)   ||stl-AssociativeContainer|               |Erases all elements in|
|                                            |                                         |a range.              |
|--------------------------------------------+-----------------------------------------+----------------------|
|void clear()                                ||stl-AssociativeContainer|               |Erases all of the     |
|                                            |                                         |elements.             |
|--------------------------------------------+-----------------------------------------+----------------------|
|iterator find(const key_type& k) const      ||stl-AssociativeContainer|               |Finds an element whose|
|                                            |                                         |key is k.             |
|--------------------------------------------+-----------------------------------------+----------------------|
|size_type count(const key_type& k) const    ||stl-AssociativeContainer|               |Counts the number of  |
|                                            |                                         |elements whose key is |
|                                            |                                         |k.                    |
|--------------------------------------------+-----------------------------------------+----------------------|
|pair<iterator, iterator>                    ||stl-AssociativeContainer|               |Finds a range         |
|equal_range(const key_type& k) const        |                                         |containing all        |
|                                            |                                         |elements whose key is |
|                                            |                                         |k.                    |
|--------------------------------------------+-----------------------------------------+----------------------|
|bool operator==(const hash_multiset&,       ||stl-HashedAssociativeContainer|         |Tests two             |
|                const hash_multiset&)       |                                         |hash_multisets for    |
|                                            |                                         |equality. This is a   |
|                                            |                                         |global function, not a|
|                                            |                                         |member function.      |
+-------------------------------------------------------------------------------------------------------------+

  New members

   All of hash_multiset's members are defined in the
   |stl-MultipleHashedAssociativeContainer| and
   |stl-SimpleAssociativeContainer| requirements. Hash_multiset does not
   introduce any new members.

  Notes

   [1] This member function relies on member template functions, which at
   present (early 1998) are not supported by all compilers. If your compiler
   supports member templates, you can call this function with any type of
   |stl-InputIterator|. If your compiler does not yet support member
   templates, though, then the arguments must either be of type const
   value_type* or of type hash_multiset::const_iterator.

  See also

   |stl-AssociativeContainer|, |stl-HashedAssociativeContainer|,
   |stl-SimpleAssociativeContainer|,
   |stl-MultipleHashedAssociativeContainer|, |stl-set|, |stl-Map|,
   |stl-multiset|, |stl-Multimap|, |stl-hash_set|, |stl-hash_map|,
   |stl-hash_multimap|

*stl-hash_multimap*

               hash_multimap<Key, Data, HashFcn, EqualKey, Alloc>

   Category: containers                                  Component type: type

  Description

   Hash_multimap is a |stl-HashedAssociativeContainer| that associates
   objects of type Key with objects of type Data. Hash_multimap is a
   |stl-PairAssociativeContainer|, meaning that its value type is
   |stl-pair|<const Key, Data>. It is also a
   |stl-MultipleAssociativeContainer|, meaning that there is no limit on the
   number of elements whose keys may compare equal using EqualKey.

   Looking up an element in a hash_multimap by its key is efficient, so
   hash_multimap is useful for "dictionaries" where the order of elements is
   irrelevant. If it is important for the elements to be in a particular
   order, however, then |stl-Multimap| is more appropriate.

*stl-hash_multimap-example*

 struct eqstr
 {
   bool operator()(const char* s1, const char* s2) const
   {
     return strcmp(s1, s2) == 0;
   }
 };

 typedef hash_multimap<const char*, int, hash<const char*>, eqstr> map_type;

 void lookup(const map_type& Map, const char* str)
 {
   cout << str << ": ";
   pair<map_type::const_iterator, map_type::const_iterator> p =
     Map.equal_range(str);
   for (map_type::const_iterator i = p.first; i != p.second; ++i)
     cout << (*i).second << " ";
   cout << endl;
 }

 int main()
 {
   map_type M;
   M.insert(map_type::value_type("H", 1));
   M.insert(map_type::value_type("H", 2));
   M.insert(map_type::value_type("C", 12));
   M.insert(map_type::value_type("C", 13));
   M.insert(map_type::value_type("O", 16));
   M.insert(map_type::value_type("O", 17));
   M.insert(map_type::value_type("O", 18));
   M.insert(map_type::value_type("I", 127));

   lookup(M, "I");
   lookup(M, "O");
   lookup(M, "Rn");
 }

  Definition

   Defined in the header |stl-hash_map|, and in the backward-compatibility
   header |stl-hash_map|.h. This class is an SGI extension; it is not part of
   the C++ standard.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |             Description              |       Default       |
   |-----------+--------------------------------------+---------------------|
   | Key       | The hash_multimap's key type. This   |                     |
   |           | is also defined as                   |                     |
   |           | hash_multimap::key_type.             |                     |
   |-----------+--------------------------------------+---------------------|
   | Data      | The hash_multimap's data type. This  |                     |
   |           | is also defined as                   |                     |
   |           | hash_multimap::data_type.            |                     |
   |-----------+--------------------------------------+---------------------|
   | HashFcn   | The |stl-HashFunction| used by the   | |stl-hash|<Key>     |
   |           | hash_multimap. This is also defined  |                     |
   |           | as hash_multimap::hasher.            |                     |
   |-----------+--------------------------------------+---------------------|
   | EqualKey  | The hash_multimap's key equality     | |stl-equal_to|<Key> |
   |           | function: a |stl-BinaryPredicate|    |                     |
   |           | that determines whether two keys are |                     |
   |           | equal. This is also defined as       |                     |
   |           | hash_multimap::key_equal.            |                     |
   |-----------+--------------------------------------+---------------------|
   | Alloc     | The hash_set's allocator, used for   | |stl-Allocators|    |
   |           | all internal memory management.      |                     |
   +------------------------------------------------------------------------+

  Model of

   |stl-MultipleHashedAssociativeContainer|, |stl-PairAssociativeContainer|

  Type requirements

     * Key is |stl-Assignable|.
     * EqualKey is a |stl-BinaryPredicate| whose argument type is Key.
     * EqualKey is an equivalence relation.
     * Alloc is an |stl-Allocators|.

  Public base classes

   None.

  Members

+-------------------------------------------------------------------------------------------------------------+
|                   Member                   |              Where defined              |     Description      |
|--------------------------------------------+-----------------------------------------+----------------------|
|key_type                                    ||stl-AssociativeContainer|               |The hash_multimap's   |
|                                            |                                         |key type, Key.        |
|--------------------------------------------+-----------------------------------------+----------------------|
|data_type                                   ||stl-PairAssociativeContainer|           |The type of object    |
|                                            |                                         |associated with the   |
|                                            |                                         |keys.                 |
|--------------------------------------------+-----------------------------------------+----------------------|
|value_type                                  ||stl-PairAssociativeContainer|           |The type of object,   |
|                                            |                                         |pair<const key_type,  |
|                                            |                                         |data_type>, stored in |
|                                            |                                         |the hash_multimap.    |
|--------------------------------------------+-----------------------------------------+----------------------|
|hasher                                      ||stl-HashedAssociativeContainer|         |The hash_multimap's   |
|                                            |                                         ||stl-HashFunction|.   |
|--------------------------------------------+-----------------------------------------+----------------------|
|key_equal                                   ||stl-HashedAssociativeContainer|         ||stl-functors| that   |
|                                            |                                         |compares keys for     |
|                                            |                                         |equality.             |
|--------------------------------------------+-----------------------------------------+----------------------|
|pointer                                     ||stl-Container|                          |Pointer to T.         |
|--------------------------------------------+-----------------------------------------+----------------------|
|reference                                   ||stl-Container|                          |Reference to T        |
|--------------------------------------------+-----------------------------------------+----------------------|
|const_reference                             ||stl-Container|                          |Const reference to T  |
|--------------------------------------------+-----------------------------------------+----------------------|
|size_type                                   ||stl-Container|                          |An unsigned integral  |
|                                            |                                         |type.                 |
|--------------------------------------------+-----------------------------------------+----------------------|
|difference_type                             ||stl-Container|                          |A signed integral     |
|                                            |                                         |type.                 |
|--------------------------------------------+-----------------------------------------+----------------------|
|iterator                                    ||stl-Container|                          |Iterator used to      |
|                                            |                                         |iterate through a     |
|                                            |                                         |hash_multimap. [4][1] |
|--------------------------------------------+-----------------------------------------+----------------------|
|const_iterator                              ||stl-Container|                          |Const iterator used to|
|                                            |                                         |iterate through a     |
|                                            |                                         |hash_multimap.        |
|--------------------------------------------+-----------------------------------------+----------------------|
|iterator begin()                            ||stl-Container|                          |Returns an iterator   |
|                                            |                                         |pointing to the       |
|                                            |                                         |beginning of the      |
|                                            |                                         |hash_multimap.        |
|--------------------------------------------+-----------------------------------------+----------------------|
|iterator end()                              ||stl-Container|                          |Returns an iterator   |
|                                            |                                         |pointing to the end of|
|                                            |                                         |the hash_multimap.    |
|--------------------------------------------+-----------------------------------------+----------------------|
|const_iterator begin() const                ||stl-Container|                          |Returns an            |
|                                            |                                         |const_iterator        |
|                                            |                                         |pointing to the       |
|                                            |                                         |beginning of the      |
|                                            |                                         |hash_multimap.        |
|--------------------------------------------+-----------------------------------------+----------------------|
|const_iterator end() const                  ||stl-Container|                          |Returns an            |
|                                            |                                         |const_iterator        |
|                                            |                                         |pointing to the end of|
|                                            |                                         |the hash_multimap.    |
|--------------------------------------------+-----------------------------------------+----------------------|
|size_type size() const                      ||stl-Container|                          |Returns the size of   |
|                                            |                                         |the hash_multimap.    |
|--------------------------------------------+-----------------------------------------+----------------------|
|size_type max_size() const                  ||stl-Container|                          |Returns the largest   |
|                                            |                                         |possible size of the  |
|                                            |                                         |hash_multimap.        |
|--------------------------------------------+-----------------------------------------+----------------------|
|bool empty() const                          ||stl-Container|                          |true if the           |
|                                            |                                         |hash_multimap's size  |
|                                            |                                         |is 0.                 |
|--------------------------------------------+-----------------------------------------+----------------------|
|size_type bucket_count() const              ||stl-HashedAssociativeContainer|         |Returns the number of |
|                                            |                                         |buckets used by the   |
|                                            |                                         |hash_multimap.        |
|--------------------------------------------+-----------------------------------------+----------------------|
|void resize(size_type n)                    ||stl-HashedAssociativeContainer|         |Increases the bucket  |
|                                            |                                         |count to at least n.  |
|--------------------------------------------+-----------------------------------------+----------------------|
|hasher hash_funct() const                   ||stl-HashedAssociativeContainer|         |Returns the hasher    |
|                                            |                                         |object used by the    |
|                                            |                                         |hash_multimap.        |
|--------------------------------------------+-----------------------------------------+----------------------|
|key_equal key_eq() const                    ||stl-HashedAssociativeContainer|         |Returns the key_equal |
|                                            |                                         |object used by the    |
|                                            |                                         |hash_multimap.        |
|--------------------------------------------+-----------------------------------------+----------------------|
|hash_multimap()                             ||stl-Container|                          |Creates an empty      |
|                                            |                                         |hash_multimap.        |
|--------------------------------------------+-----------------------------------------+----------------------|
|hash_multimap(size_type n)                  ||stl-HashedAssociativeContainer|         |Creates an empty      |
|                                            |                                         |hash_multimap with at |
|                                            |                                         |least n buckets.      |
|--------------------------------------------+-----------------------------------------+----------------------|
|hash_multimap(size_type n,                  ||stl-HashedAssociativeContainer|         |Creates an empty      |
|              const hasher& h)              |                                         |hash_multimap with at |
|                                            |                                         |least n buckets, using|
|                                            |                                         |h as the hash         |
|                                            |                                         |function.             |
|--------------------------------------------+-----------------------------------------+----------------------|
|hash_multimap(size_type n,                  ||stl-HashedAssociativeContainer|         |Creates an empty      |
|              const hasher& h,              |                                         |hash_multimap with at |
|              const key_equal& k)           |                                         |least n buckets, using|
|                                            |                                         |h as the hash function|
|                                            |                                         |and k as the key equal|
|                                            |                                         |function.             |
|--------------------------------------------+-----------------------------------------+----------------------|
|template <class |stl-InputIterator|>        ||stl-MultipleHashedAssociativeContainer| |Creates a             |
|hash_multimap(InputIterator, InputIterator) |                                         |hash_multimap with a  |
|[5][2]                                      |                                         |copy of a range.      |
|--------------------------------------------+-----------------------------------------+----------------------|
|template <class |stl-InputIterator|>        ||stl-MultipleHashedAssociativeContainer| |Creates a             |
|hash_multimap(InputIterator, InputIterator, |                                         |hash_multimap with a  |
|              size_type n)                  |                                         |copy of a range and a |
|[6][2]                                      |                                         |bucket count of at    |
|                                            |                                         |least n.              |
|--------------------------------------------+-----------------------------------------+----------------------|
|template <class |stl-InputIterator|>        ||stl-MultipleHashedAssociativeContainer| |Creates a             |
|hash_multimap(InputIterator, InputIterator, |                                         |hash_multimap with a  |
|              size_type n, const hasher& h) |                                         |copy of a range and a |
|[7][2]                                      |                                         |bucket count of at    |
|                                            |                                         |least n, using h as   |
|                                            |                                         |the hash function.    |
|--------------------------------------------+-----------------------------------------+----------------------|
|template <class |stl-InputIterator|>        ||stl-MultipleHashedAssociativeContainer| |Creates a             |
|hash_multimap(InputIterator, InputIterator, |                                         |hash_multimap with a  |
|              size_type n, const hasher& h, |                                         |copy of a range and a |
|              const key_equal& k)           |                                         |bucket count of at    |
|[8][2]                                      |                                         |least n, using h as   |
|                                            |                                         |the hash function and |
|                                            |                                         |k as the key equal    |
|                                            |                                         |function.             |
|--------------------------------------------+-----------------------------------------+----------------------|
|hash_multimap(const hash_multimap&)         ||stl-Container|                          |The copy constructor. |
|--------------------------------------------+-----------------------------------------+----------------------|
|hash_multimap& operator=(const              ||stl-Container|                          |The assignment        |
|hash_multimap&)                             |                                         |operator              |
|--------------------------------------------+-----------------------------------------+----------------------|
|void swap(hash_multimap&)                   ||stl-Container|                          |Swaps the contents of |
|                                            |                                         |two hash_multimaps.   |
|--------------------------------------------+-----------------------------------------+----------------------|
|iterator insert(const value_type& x)        ||stl-MultipleAssociativeContainer|       |Inserts x into the    |
|                                            |                                         |hash_multimap.        |
|--------------------------------------------+-----------------------------------------+----------------------|
|template <class |stl-InputIterator|>        ||stl-MultipleAssociativeContainer|       |Inserts a range into  |
|void insert(InputIterator, InputIterator)   |                                         |the hash_multimap.    |
|[9][2]                                      |                                         |                      |
|--------------------------------------------+-----------------------------------------+----------------------|
|void erase(iterator pos)                    ||stl-AssociativeContainer|               |Erases the element    |
|                                            |                                         |pointed to by pos.    |
|--------------------------------------------+-----------------------------------------+----------------------|
|size_type erase(const key_type& k)          ||stl-AssociativeContainer|               |Erases the element    |
|                                            |                                         |whose key is k.       |
|--------------------------------------------+-----------------------------------------+----------------------|
|void erase(iterator first, iterator last)   ||stl-AssociativeContainer|               |Erases all elements in|
|                                            |                                         |a range.              |
|--------------------------------------------+-----------------------------------------+----------------------|
|void clear()                                ||stl-AssociativeContainer|               |Erases all of the     |
|                                            |                                         |elements.             |
|--------------------------------------------+-----------------------------------------+----------------------|
|const_iterator find(const key_type& k) const||stl-AssociativeContainer|               |Finds an element whose|
|                                            |                                         |key is k.             |
|--------------------------------------------+-----------------------------------------+----------------------|
|iterator find(const key_type& k)            ||stl-AssociativeContainer|               |Finds an element whose|
|                                            |                                         |key is k.             |
|--------------------------------------------+-----------------------------------------+----------------------|
|size_type count(const key_type& k) const    ||stl-AssociativeContainer|               |Counts the number of  |
|                                            |                                         |elements whose key is |
|                                            |                                         |k.                    |
|--------------------------------------------+-----------------------------------------+----------------------|
|pair<const_iterator, const_iterator>        ||stl-AssociativeContainer|               |Finds a range         |
|equal_range(const key_type& k) const        |                                         |containing all        |
|                                            |                                         |elements whose key is |
|                                            |                                         |k.                    |
|--------------------------------------------+-----------------------------------------+----------------------|
|pair<iterator, iterator>                    ||stl-AssociativeContainer|               |Finds a range         |
|equal_range(const key_type& k)              |                                         |containing all        |
|                                            |                                         |elements whose key is |
|                                            |                                         |k.                    |
|--------------------------------------------+-----------------------------------------+----------------------|
|bool operator==(const hash_multimap&,       ||stl-HashedAssociativeContainer|         |Tests two             |
|                const hash_multimap&)       |                                         |hash_multimaps for    |
|                                            |                                         |equality. This is a   |
|                                            |                                         |global function, not a|
|                                            |                                         |member function.      |
+-------------------------------------------------------------------------------------------------------------+

  New members

   All of hash_multimap's members are defined in the
   |stl-MultipleHashedAssociativeContainer| and
   |stl-PairAssociativeContainer| requirements. Hash_multimap does not
   introduce any new members.

  Notes

   [1] Hash_multimap::iterator is not a mutable iterator, because
   hash_multimap::value_type is not |stl-Assignable|. That is, if i is of
   type hash_multimap::iterator and p is of type hash_multimap::value_type,
   then *i = p is not a valid expression. However, hash_multimap::iterator
   isn't a constant iterator either, because it can be used to modify the
   object that it points to. Using the same notation as above, (*i).second =
   p is a valid expression.

   [2] This member function relies on member template functions, which at
   present (early 1998) are not supported by all compilers. If your compiler
   supports member templates, you can call this function with any type of
   |stl-InputIterator|. If your compiler does not yet support member
   templates, though, then the arguments must either be of type const
   value_type* or of type hash_multimap::const_iterator.

  See also

   |stl-AssociativeContainer|, |stl-HashedAssociativeContainer|,
   |stl-PairAssociativeContainer|, |stl-MultipleHashedAssociativeContainer|,
   |stl-set|, |stl-Map|, |stl-multiset|, |stl-Multimap|, |stl-hash_set|,
   |stl-hash_map|, |stl-hash_multiset|

*stl-hash*

                                    hash<T>

   Categories: containers, functors                      Component type: type

  Description

   The function object hash<T> is a |stl-HashFunction|; it is used as the
   default hash function by all of the [2]Hashed Associative Containers that
   are included in the STL.

   The hash<T> template is only defined for template arguments of type char*,
   const char*, |stl-Rope|, |stl-Rope|, and the built-in integral types.
   [3][1] If you need a Hash Function with a different argument type, you
   must either provide your own template specialization or else use a
   different Hash Function.

*stl-hash-example*

 int main()
 {
   hash<const char*> H;
   cout << "foo -> " << H("foo") << endl;
   cout << "bar -> " << H("bar") << endl;
 }

  Definition

   Defined in the headers |stl-hash_map| and |stl-hash_set|, and in the
   backward-compatibility headers |stl-hash_map|.h and |stl-hash_set|.h. This class
   is an SGI extension; it is not part of the C++ standard.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | T         | The argument type. That is, the type of object   |         |
   |           | that is being hashed.                            |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-HashFunction|

  Type requirements

   T must be a type for which a specialization of hash has been defined. The
   STL defines the following specializations:

     * char*
     * const char*
     * |stl-Rope|
     * |stl-Rope|
     * char
     * signed char
     * unsigned char
     * short
     * unsigned short
     * int
     * unsigned int
     * long
     * unsigned long

  Public base classes

   None.

  Members

   +------------------------------------------------------------------------+
   |           Member            |   Where defined    |     Description     |
   |-----------------------------+--------------------+---------------------|
   | size_t operator()(const T&  | |stl-HashFunction| | Returns x's hash    |
   | x)                          |                    | value.              |
   +------------------------------------------------------------------------+

  New members

   All of hash's members are defined in the |stl-HashFunction| requirements.
   Hash does not introduce any new members.

  Notes

   [1] Technically, what this means is that the actual template hash<T> is an
   empty class; the member function operator() is defined only in the various
   specializations.

  See also

   |stl-HashedAssociativeContainer|, |stl-HashFunction|


        ________________________________________________________________________
                                    String package
*stl-character_traits*

                                Character Traits

   Category: utilities                                Component type: concept

  Description

   Several library components, including |stl-basic_string|, need to perform
   operations on characters. A Character Traits class is similar to a
   |stl-functors|: it encapsulates some information about a particular
   character type, and some operations on that type.

   Note that every member of a Character Traits class is static. There is
   never any need to create a Character Traits object, and, in fact, there is
   no guarantee that creating such objects is possible.

  Refinement of

   Character Traits is not a refinement of any other concept.

  Associated types

   +------------------------------------------------------------------------+
   | Value type    | X::char_type  | The character type described by this   |
   |               |               | Character Traits type.                 |
   |---------------+---------------+----------------------------------------|
   | Int type      | X::int_type   | A type that is capable of representing |
   |               |               | every valid value of type char_type,   |
   |               |               | and, additionally an end-of-file       |
   |               |               | value. For char, for example, the int  |
   |               |               | type may be int, and for wchar_t it    |
   |               |               | may be wint_t.                         |
   |---------------+---------------+----------------------------------------|
   | Position type | X::pos_type   | A type that can represent the position |
   |               |               | of a character of type char_type       |
   |               |               | within a file. This type is usually    |
   |               |               | streampos.                             |
   |---------------+---------------+----------------------------------------|
   | Offset type   | X::off_type   | An integer type that can represent the |
   |               |               | difference between two pos_type        |
   |               |               | values. This type is usually           |
   |               |               | streamoff.                             |
   |---------------+---------------+----------------------------------------|
   | State type    | X::state_type | A type that can represent a state in a |
   |               |               | multibyte encoding scheme. This type,  |
   |               |               | if used at all, is usually mbstate_t.  |
   +------------------------------------------------------------------------+

  Notation

   X         A type that is a model of Character Traits.
   c, c1, c2 A value of X's value type, X::char_type.
   e, e1, e2 A value of X's int type, X::int_type.
   n         A value of type size_t.
   p, p1, p2 A non-null pointer of type const X::char_type*.
   s         A non-null pointer of type X::char_type*.

  Valid Expressions

   +------------------------------------------------------------------------+
   |     Name     |     Expression      |       Type       |  Return type   |
   |              |                     |   requirements   |                |
   |--------------+---------------------+------------------+----------------|
   | Character    | X::assign(c1, c2)   | c1 is a          | void           |
   | assignment   |                     | modifiable       |                |
   |              |                     | lvalue.          |                |
   |--------------+---------------------+------------------+----------------|
   | Character    | X::eq(c1, c2)       |                  | bool           |
   | equality     |                     |                  |                |
   |--------------+---------------------+------------------+----------------|
   | Character    | X::lt(c1, c2)       |                  | bool           |
   | comparison   |                     |                  |                |
   |--------------+---------------------+------------------+----------------|
   | Range        | X::compare(p1, p2,  |                  | int            |
   | comparison   | n)                  |                  |                |
   |--------------+---------------------+------------------+----------------|
   | Length       | X::length(p)        |                  | size_t         |
   |--------------+---------------------+------------------+----------------|
   | Find         | X::find(p, n, c)    |                  | const          |
   |              |                     |                  | X::char_type*  |
   |--------------+---------------------+------------------+----------------|
   | Move         | X::move(s, p, n)    |                  | X::char_type*  |
   |--------------+---------------------+------------------+----------------|
   | Copy         | X::copy(s, p, n)    |                  | X::char_type*  |
   |--------------+---------------------+------------------+----------------|
   | Range        | X::assign(s, n, c)  |                  | X::char_type*  |
   | assignment   |                     |                  |                |
   |--------------+---------------------+------------------+----------------|
   | EOF value    | X::eof()            |                  | X::int_type    |
   |--------------+---------------------+------------------+----------------|
   | Not EOF      | X::not_eof(e)       |                  | X::int_type    |
   |--------------+---------------------+------------------+----------------|
   | Convert to   | X::to_char_type(e)  |                  | X::char_type   |
   | value type   |                     |                  |                |
   |--------------+---------------------+------------------+----------------|
   | Convert to   | X::to_int_type(c)   |                  | X::int_type    |
   | int type     |                     |                  |                |
   |--------------+---------------------+------------------+----------------|
   | Equal int    | X::eq_int_type(e1,  |                  | bool           |
   | type values  | e2)                 |                  |                |
   +------------------------------------------------------------------------+

  Expression semantics

+-------------------------------------------------------------------------------------------------------------+
|    Name    |    Expression     | Precondition |        Semantics         |          Postcondition           |
|------------+-------------------+--------------+--------------------------+----------------------------------|
|Character   |X::assign(c1, c2)  |              |Performs the assignment c1|X::eq(c1, c2) is true.            |
|assignment  |                   |              |= c2                      |                                  |
|------------+-------------------+--------------+--------------------------+----------------------------------|
|Character   |X::eq(c1, c2)      |              |Returns true if and only  |                                  |
|equality    |                   |              |if c1 and c2 are equal.   |                                  |
|------------+-------------------+--------------+--------------------------+----------------------------------|
|Character   |X::lt(c1, c2)      |              |Returns true if and only  |                                  |
|comparison  |                   |              |if c1 is less than c2.    |                                  |
|            |                   |              |Note that for any two     |                                  |
|            |                   |              |value values c1 and c2,   |                                  |
|            |                   |              |exactly one of X::lt(c1,  |                                  |
|            |                   |              |c2), X::lt(c2, c1), and   |                                  |
|            |                   |              |X::eq(c1, c2) should be   |                                  |
|            |                   |              |true.                     |                                  |
|------------+-------------------+--------------+--------------------------+----------------------------------|
|Range       |X::compare(p1, p2, |[p1, p1+n) and|Generalization of strncmp.|                                  |
|comparison  |n)                 |[p2, p2+n) are|Returns 0 if every element|                                  |
|            |                   |valid ranges. |in [p1, p1+n) is equal to |                                  |
|            |                   |              |the corresponding element |                                  |
|            |                   |              |in [p2, p2+n), a negative |                                  |
|            |                   |              |value if there exists an  |                                  |
|            |                   |              |element in [p1, p1+n) less|                                  |
|            |                   |              |than the corresponding    |                                  |
|            |                   |              |element in [p2, p2+n) and |                                  |
|            |                   |              |all previous elements are |                                  |
|            |                   |              |equal, and a positive     |                                  |
|            |                   |              |value if there exists an  |                                  |
|            |                   |              |element in [p1, p1+n)     |                                  |
|            |                   |              |greater than the          |                                  |
|            |                   |              |corresponding element in  |                                  |
|            |                   |              |[p2, p2+n) and all        |                                  |
|            |                   |              |previous elements are     |                                  |
|            |                   |              |equal.                    |                                  |
|------------+-------------------+--------------+--------------------------+----------------------------------|
|Length      |X::length(p)       |              |Generalization of strlen. |                                  |
|            |                   |              |Returns the smallest      |                                  |
|            |                   |              |non-negative number n such|                                  |
|            |                   |              |that X::eq(p+n,           |                                  |
|            |                   |              |X::char_type()) is true.  |                                  |
|            |                   |              |Behavior is undefined if  |                                  |
|            |                   |              |no such n exists.         |                                  |
|------------+-------------------+--------------+--------------------------+----------------------------------|
|Find        |X::find(p, n, c)   |[p, p+n) is a |Generalization of strchr. |                                  |
|            |                   |valid range.  |Returns the first pointer |                                  |
|            |                   |              |q in [p, p+n) such that   |                                  |
|            |                   |              |X::eq(*q, c) is true.     |                                  |
|            |                   |              |Returns a null pointer if |                                  |
|            |                   |              |no such pointer exists.   |                                  |
|            |                   |              |(Note that this method for|                                  |
|            |                   |              |indicating a failed search|                                  |
|            |                   |              |differs from that is      |                                  |
|            |                   |              ||stl-find|.)              |                                  |
|------------+-------------------+--------------+--------------------------+----------------------------------|
|Move        |X::move(s, p, n)   |[p, p+n) and  |Generalization of memmove.|                                  |
|            |                   |[s, s+n) are  |Copies values from the    |                                  |
|            |                   |valid ranges  |range [p, p+n) to the     |                                  |
|            |                   |(possibly     |range [s, s+n), and       |                                  |
|            |                   |overlapping). |returns s.                |                                  |
|------------+-------------------+--------------+--------------------------+----------------------------------|
|Copy        |X::copy(s, p, n)   |[p, p+n) and  |Generalization of memcpy. |                                  |
|            |                   |[s, s+n) are  |Copies values from the    |                                  |
|            |                   |valid ranges  |range [p, p+n) to the     |                                  |
|            |                   |which do not  |range [s, s+n), and       |                                  |
|            |                   |overlap.      |returns s.                |                                  |
|------------+-------------------+--------------+--------------------------+----------------------------------|
|Range       |X::assign(s, n, c) |[s, s+n) is a |Generalization of memset. |                                  |
|assignment  |                   |valid range.  |Assigns the value c to    |                                  |
|            |                   |              |each pointer in the range |                                  |
|            |                   |              |[s, s+n), and returns s.  |                                  |
|------------+-------------------+--------------+--------------------------+----------------------------------|
|EOF value   |X::eof()           |              |Returns a value that can  |X::eof() is distinct from every   |
|            |                   |              |represent EOF.            |valid value of type X::char_type. |
|            |                   |              |                          |That is, there exists no value c  |
|            |                   |              |                          |such that                         |
|            |                   |              |                          |X::eq_int_type(X::to_int_type(c), |
|            |                   |              |                          |X::eof()) is true.                |
|------------+-------------------+--------------+--------------------------+----------------------------------|
|Not EOF     |X::not_eof(e)      |              |Returns e if e represents |                                  |
|            |                   |              |a valid char_type value,  |                                  |
|            |                   |              |and some non-EOF value if |                                  |
|            |                   |              |e is X::eof().            |                                  |
|------------+-------------------+--------------+--------------------------+----------------------------------|
|Convert to  |X::to_char_type(e) |              |Converts e to X's int     |                                  |
|value type  |                   |              |type. If e is a           |                                  |
|            |                   |              |representation of some    |                                  |
|            |                   |              |char_type value then it   |                                  |
|            |                   |              |returns that value; if e  |                                  |
|            |                   |              |is X::eof() then the      |                                  |
|            |                   |              |return value is           |                                  |
|            |                   |              |unspecified.              |                                  |
|------------+-------------------+--------------+--------------------------+----------------------------------|
|Convert to  |X::to_int_type(c)  |              |Converts c to X's int     |X::to_char_type(X::to_int_type(c))|
|int type    |                   |              |type.                     |is a null operation.              |
|------------+-------------------+--------------+--------------------------+----------------------------------|
|Equal int   |X::eq_int_type(e1, |              |Compares two int type     |                                  |
|type values |e2)                |              |values. If there exist    |                                  |
|            |                   |              |values of type            |                                  |
|            |                   |              |X::char_type such that e1 |                                  |
|            |                   |              |is X::to_int_type(c1)) and|                                  |
|            |                   |              |e2 is X::to_int_type(c2)),|                                  |
|            |                   |              |then X::eq_int_type(e1,   |                                  |
|            |                   |              |e2) is the same as        |                                  |
|            |                   |              |X::eq(c1, c2). Otherwise, |                                  |
|            |                   |              |eq_int_type returns true  |                                  |
|            |                   |              |if e1 and e2 are both EOF |                                  |
|            |                   |              |and false if one of e1 and|                                  |
|            |                   |              |e2 is EOF and the other is|                                  |
|            |                   |              |not.                      |                                  |
+-------------------------------------------------------------------------------------------------------------+

  Complexity guarantees

   length, find, move, copy, and the range version of assign are linear in n.

   All other operations are constant time.

  Models

     * |stl-char_traits|<char>
     * |stl-char_traits|<wchar_t>

  See also

   |stl-basic_string|

*stl-char_traits*

                                  char_traits

   Category: utilities                                   Component type: type

  Description

   The char_traits class is the default |stl-character_traits| class used by
   the library; it is the only predefined |stl-character_traits| class.

*stl-char_traits-example*

   The char_traits class is of no use by itself. It is used as a template
   parameter of other classes, such as the |stl-basic_string| template.

  Definition

   Defined in the standard header |stl-string|.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | charT     | char_traits's value type, i.e.                   |         |
   |           | char_traits<>::char_type.                        |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-character_traits|

  Type requirements

   charT is either char or wchar_t.

   (All of char_traits's member functions are defined for arbitrary types,
   but some of char_traits's members must be explicitly specialized if
   char_traits is to be useful for other types than char and wchar_t.

  Public base classes

   None.

  Members

   All of char_traits's members are static. There is never any reason to
   create an object of type char_traits.

   +------------------------------------------------------------------------+
   |        Member         |      Where defined      |     Description      |
   |-----------------------+-------------------------+----------------------|
   | char_type             | |stl-character_traits|  | char_traits's value  |
   |                       |                         | type: charT.         |
   |-----------------------+-------------------------+----------------------|
   | int_type              | |stl-character_traits|  | char_traits's int    |
   |                       |                         | type.                |
   |-----------------------+-------------------------+----------------------|
   | pos_type              | |stl-character_traits|  | char_traits's        |
   |                       |                         | position type.       |
   |-----------------------+-------------------------+----------------------|
   | off_type              | |stl-character_traits|  | char_traits's offset |
   |                       |                         | type                 |
   |-----------------------+-------------------------+----------------------|
   | state_type            | |stl-character_traits|  | char_traits's state  |
   |                       |                         | type.                |
   |-----------------------+-------------------------+----------------------|
   | static void           | |stl-character_traits|  | Assigns c2 to c1.    |
   | assign(char_type& c1, |                         |                      |
   | const char_type& c2)  |                         |                      |
   |-----------------------+-------------------------+----------------------|
   | static bool eq(const  | |stl-character_traits|  | Character equality.  |
   | char_type& c1, const  |                         |                      |
   | char_type& c2)        |                         |                      |
   |-----------------------+-------------------------+----------------------|
   | static bool lt(const  | |stl-character_traits|  | Returns true if c1   |
   | char_type& c1, const  |                         | is less than c2.     |
   | char_type& c2)        |                         |                      |
   |-----------------------+-------------------------+----------------------|
   | static int            | |stl-character_traits|  | Three-way            |
   | compare(const         |                         | lexicographical      |
   | char_type* p1, const  |                         | comparison, much     |
   | char_type* p2, size_t |                         | like strncmp.        |
   | n)                    |                         |                      |
   |-----------------------+-------------------------+----------------------|
   | Length                | static size_t           | Returns length of a  |
   |                       | length(const char* p)   | null-terminated      |
   |                       |                         | array of characters. |
   |-----------------------+-------------------------+----------------------|
   | static const          | |stl-character_traits|  | Finds c in [p, p+n), |
   | char_type* find(const |                         | returning 0 if not   |
   | char_type* p, size_t  |                         | found.               |
   | n, const char_type&   |                         |                      |
   | c)                    |                         |                      |
   |-----------------------+-------------------------+----------------------|
   | static char_type*     | |stl-character_traits|  | Copies characters    |
   | move(char_type* s,    |                         | from [p, p+n) to the |
   | const char_type* p,   |                         | (possibly            |
   | size_t n)             |                         | overlapping) range   |
   |                       |                         | [s, s+n).            |
   |-----------------------+-------------------------+----------------------|
   | static char_type*     | |stl-character_traits|  | Copies characters    |
   | copy(char_type* s,    |                         | from [p, p+n) to the |
   | const char_type* p,   |                         | (non-overlapping)    |
   | size_t n)             |                         | range [s, s+n).      |
   |-----------------------+-------------------------+----------------------|
   | static char_type*     | |stl-character_traits|  | Assigns the value c  |
   | assign(char_type* s,  |                         | to every element in  |
   | size_t n, char_type   |                         | the range [s, s+n).  |
   | c)                    |                         |                      |
   |-----------------------+-------------------------+----------------------|
   | static int_type eof() | |stl-character_traits|  | Returns the value    |
   |                       |                         | used as an EOF       |
   |                       |                         | indicator.           |
   |-----------------------+-------------------------+----------------------|
   | static int_type       | |stl-character_traits|  | Returns a value that |
   | not_eof(const         |                         | is not equal to      |
   | int_type& c)          |                         | eof(). Returns c     |
   |                       |                         | unless c is equal to |
   |                       |                         | eof().               |
   |-----------------------+-------------------------+----------------------|
   | static char_type      | |stl-character_traits|  | Returns the          |
   | to_char_type(const    |                         | char_type value      |
   | int_type& c)          |                         | corresponding to c,  |
   |                       |                         | if such a value      |
   |                       |                         | exists.              |
   |-----------------------+-------------------------+----------------------|
   | static int_type       | |stl-character_traits|  | Returns a int_type   |
   | to_int_type(const     |                         | representation of c. |
   | char_type& c)         |                         |                      |
   |-----------------------+-------------------------+----------------------|
   | static bool           | |stl-character_traits|  | Tests whether two    |
   | eq_int_type(cosnt     |                         | int_type values are  |
   | int_type& c1, const   |                         | equal. If the values |
   | int_type& c1)         |                         | can also be          |
   |                       |                         | represented as       |
   |                       |                         | char_type, then eq   |
   |                       |                         | and eq_int_type must |
   |                       |                         | be consistent with   |
   |                       |                         | each other.          |
   +------------------------------------------------------------------------+

  New members

   None. All of char_traits's members are defined in the
   |stl-character_traits| requirements.

  See also

   |stl-character_traits|, |stl-basic_string|

*stl-basic_string*
*stl-string*
*stl-wstring*

                       basic_string<charT, traits, Alloc>

   Category: containers                                  Component type: type

  Description

   The basic_string class represents a |stl-Sequence| of characters. It
   contains all the usual operations of a |stl-Sequence|, and, additionally,
   it contains standard string operations such as search and concatenation.

   The basic_string class is parameterized by character type, and by that
   type's |stl-character_traits|. Most of the time, however, there is no need
   to use the basic_string template directly. The types string and wstring
   are typedefs for, respectively, basic_string<char> and
   basic_string<wchar_t>.

   Some of basic_string's member functions use an unusual method of
   specifying positions and ranges. In addition to the conventional method
   using iterators, many of basic_string's member functions use a single
   value pos of type size_type to represent a position (in which case the
   position is begin() + pos, and many of basic_string's member functions use
   two values, pos and n, to represent a range. In that case pos is the
   beginning of the range and n is its size. That is, the range is [begin() +
   pos, begin() + pos + n).

   Note that the C++ standard does not specify the complexity of basic_string
   operations. In this implementation, basic_string has performance
   characteristics very similar to those of |stl-Vector|: access to a single
   character is O(1), while copy and concatenation are O(N). By contrast,
   |stl-Rope| has very different performance characteristics: most |stl-Rope|
   operations have logarithmic complexity.

   Note also that, according to the C++ standard, basic_string has very
   unusual iterator invalidation semantics. Iterators may be invalidated by
   swap, reserve, insert, and erase (and by functions that are equivalent to
   insert and/or erase, such as clear, resize, append, and replace).
   Additionally, however, the first call to any non-const member function,
   including the non-const version of begin() or operator[], may invalidate
   iterators. (The intent of these iterator invalidation rules is to give
   implementors greater freedom in implementation techniques.) In this
   implementation, begin(), end(), rbegin(), rend(), operator[], c_str(), and
   data() do not invalidate iterators. In this implementation, iterators are
   only invalidated by member functions that explicitly change the string's
   contents.

*stl-basic_string-example*
*stl-string-example*
*stl-wstring-example*

 int main() {
   string s(10u, ' ');           // Create a string of ten blanks.

   const char* A = "this is a test";
   s += A;
   cout << "s = " << (s + '\n');
   cout << "As a null-terminated sequence: " << s.c_str() << endl;
   cout << "The sixteenth character is " << s[15] << endl;

   reverse(s.begin(), s.end());
   s.push_back('\n');
   cout << s;
 }

  Definition

   Defined in the standard header |stl-string|.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |              Description              |      Default       |
   |-----------+---------------------------------------+--------------------|
   | charT     | The string's value type: the type of  |                    |
   |           | character it contains.                |                    |
   |-----------+---------------------------------------+--------------------|
   | traits    | The |stl-character_traits| type,      | char_traits<charT> |
   |           | which encapsulates basic character    |                    |
   |           | operations.                           |                    |
   |-----------+---------------------------------------+--------------------|
   | Alloc     | The string's allocator, used for      | alloc              |
   |           | internal memory management.           |                    |
   +------------------------------------------------------------------------+

  Model of

   |stl-RandomAccessContainer|, |stl-Sequence|.

  Type requirements

   In addition to the type requirements imposed by
   |stl-RandomAccessContainer| and |stl-Sequence|:

     * charT is a POD ("plain ol' data") type.
     * traits is a |stl-character_traits| type whose value type is charT

  Public base classes

   None.

  Members

+-------------------------------------------------------------------------------------------------------------------------+
|                           Member                            |        Where defined        |         Description         |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|value_type                                                   ||stl-Container|              |The type of object, CharT,   |
|                                                             |                             |stored in the string.        |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|pointer                                                      ||stl-Container|              |Pointer to CharT.            |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|reference                                                    ||stl-Container|              |Reference to CharT           |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|const_reference                                              ||stl-Container|              |Const reference to CharT     |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type                                                    ||stl-Container|              |An unsigned integral type.   |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|difference_type                                              ||stl-Container|              |A signed integral type.      |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|static const size_type npos                                  |basic_string                 |The largest possible value of|
|                                                             |                             |type size_type. That is,     |
|                                                             |                             |size_type(-1).               |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator                                                     ||stl-Container|              |Iterator used to iterate     |
|                                                             |                             |through a string. A          |
|                                                             |                             |basic_string supplies        |
|                                                             |                             ||stl-RandomAccessIterator|.  |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|const_iterator                                               ||stl-Container|              |Const iterator used to       |
|                                                             |                             |iterate through a string.    |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|reverse_iterator                                             ||stl-ReversibleContainer|    |Iterator used to iterate     |
|                                                             |                             |backwards through a string.  |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|const_reverse_iterator                                       ||stl-ReversibleContainer|    |Const iterator used to       |
|                                                             |                             |iterate backwards through a  |
|                                                             |                             |string.                      |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator begin()                                             ||stl-Container|              |Returns an iterator pointing |
|                                                             |                             |to the beginning of the      |
|                                                             |                             |string.                      |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator end()                                               ||stl-Container|              |Returns an iterator pointing |
|                                                             |                             |to the end of the string.    |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|const_iterator begin() const                                 ||stl-Container|              |Returns a const_iterator     |
|                                                             |                             |pointing to the beginning of |
|                                                             |                             |the string.                  |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|const_iterator end() const                                   ||stl-Container|              |Returns a const_iterator     |
|                                                             |                             |pointing to the end of the   |
|                                                             |                             |string.                      |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|reverse_iterator rbegin()                                    ||stl-ReversibleContainer|    |Returns a reverse_iterator   |
|                                                             |                             |pointing to the beginning of |
|                                                             |                             |the reversed string.         |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|reverse_iterator rend()                                      ||stl-ReversibleContainer|    |Returns a reverse_iterator   |
|                                                             |                             |pointing to the end of the   |
|                                                             |                             |reversed string.             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|const_reverse_iterator rbegin() const                        ||stl-ReversibleContainer|    |Returns a                    |
|                                                             |                             |const_reverse_iterator       |
|                                                             |                             |pointing to the beginning of |
|                                                             |                             |the reversed string.         |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|const_reverse_iterator rend() const                          ||stl-ReversibleContainer|    |Returns a                    |
|                                                             |                             |const_reverse_iterator       |
|                                                             |                             |pointing to the end of the   |
|                                                             |                             |reversed string.             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type size() const                                       ||stl-Container|              |Returns the size of the      |
|                                                             |                             |string.                      |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type length() const                                     |basic_string                 |Synonym for size().          |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type max_size() const                                   ||stl-Container|              |Returns the largest possible |
|                                                             |                             |size of the string.          |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type capacity() const                                   |basic_string                 |See below.                   |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|bool empty() const                                           ||stl-Container|              |true if the string's size is |
|                                                             |                             |0.                           |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|reference operator[](size_type n)                            ||stl-RandomAccessContainer|  |Returns the n'th character.  |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|const_reference operator[](size_type n) const                ||stl-RandomAccessContainer|  |Returns the n'th character.  |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|const charT* c_str() const                                   |basic_string                 |Returns a pointer to a       |
|                                                             |                             |null-terminated array of     |
|                                                             |                             |characters representing the  |
|                                                             |                             |string's contents.           |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|const charT* data() const                                    |basic_string                 |Returns a pointer to an array|
|                                                             |                             |of characters (not           |
|                                                             |                             |necessarily null-terminated) |
|                                                             |                             |representing the string's    |
|                                                             |                             |contents.                    |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string()                                               ||stl-Container|              |Creates an empty string.     |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string(const basic_string& s,                          ||stl-Container|, basic_string|Generalization of the copy   |
|             size_type pos = 0, size_type n = npos)          |                             |constructor.                 |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string(const charT*)                                   |basic_string                 |Construct a string from a    |
|                                                             |                             |null-terminated character    |
|                                                             |                             |array.                       |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string(const charT* s, size_type n)                    |basic_string                 |Construct a string from a    |
|                                                             |                             |character array and a length.|
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string(size_type n, charT c)                           ||stl-Sequence|               |Create a string with n copies|
|                                                             |                             |of c.                        |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class InputIterator>                               ||stl-Sequence|               |Create a string from a range.|
|basic_string(InputIterator first, InputIterator last)        |                             |                             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|~basic_string()                                              ||stl-Container|              |The destructor.              |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& operator=(const basic_string&)                 ||stl-Container|              |The assignment operator      |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& operator=(const charT* s)                      |basic_string                 |Assign a null-terminated     |
|                                                             |                             |character array to a string. |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& operator=(charT c)                             |basic_string                 |Assign a single character to |
|                                                             |                             |a string.                    |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|void reserve(size_t)                                         |basic_string                 |See below.                   |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|void swap(basic_string&)                                     ||stl-Container|              |Swaps the contents of two    |
|                                                             |                             |strings.                     |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator insert(iterator pos,                                ||stl-Sequence|               |Inserts x before pos.        |
|                const T& x)                                  |                             |                             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class |stl-InputIterator|>                         ||stl-Sequence|               |Inserts the range [first,    |
|void insert(iterator pos,                                    |                             |last) before pos.            |
|            InputIterator f, InputIterator l)                |                             |                             |
|[3][1]                                                       |                             |                             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|void insert(iterator pos,                                    ||stl-Sequence|               |Inserts n copies of x before |
|            size_type n, const T& x)                         |                             |pos.                         |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& insert(size_type pos, const basic_string& s)   |basic_string                 |Inserts s before pos.        |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& insert(size_type pos,                          |basic_string                 |Inserts a substring of s     |
|                     const basic_string& s,                  |                             |before pos.                  |
|                     size_type pos1, size_type n)            |                             |                             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& insert(size_type pos, const charT* s)          |basic_string                 |Inserts s before pos.        |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& insert(size_type pos, const charT* s, size_type|basic_string                 |Inserts the first n          |
|n)                                                           |                             |characters of s before pos.  |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& insert(size_type pos, size_type n, charT c)    |basic_string                 |Inserts n copies of c before |
|                                                             |                             |pos.                         |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& append(const basic_string& s)                  |basic_string                 |Append s to *this.           |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& append(const basic_string& s,                  |basic_string                 |Append a substring of s to   |
|                     size_type pos, size_type n)             |                             |*this.                       |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& append(const charT* s)                         |basic_string                 |Append s to *this.           |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& append(const charT* s, size_type n)            |basic_string                 |Append the first n characters|
|                                                             |                             |of s to *this.               |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& append(size_type n, charT c)                   |basic_string                 |Append n copies of c to      |
|                                                             |                             |*this.                       |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class InputIterator>                               |basic_string                 |Append a range to *this.     |
|basic_string& append(InputIterator first, InputIterator last)|                             |                             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|void push_back(charT c)                                      |basic_string                 |Append a single character to |
|                                                             |                             |*this.                       |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& operator+=(const basic_string& s)              |basic_string                 |Equivalent to append(s).     |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& operator+=(const charT* s)                     |basic_string                 |Equivalent to append(s)      |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& operator+=(charT c)                            |basic_string                 |Equivalent to push_back(c)   |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator erase(iterator p)                                   ||stl-Sequence|               |Erases the character at      |
|                                                             |                             |position p                   |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator erase(iterator first, iterator last)                ||stl-Sequence|               |Erases the range [first,     |
|                                                             |                             |last)                        |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& erase(size_type pos = 0, size_type n = npos)   |basic_string                 |Erases a range.              |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|void clear()                                                 ||stl-Sequence|               |Erases the entire container. |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|void resize(size_type n, charT c = charT())                  ||stl-Sequence|               |Appends characters, or erases|
|                                                             |                             |characters from the end, as  |
|                                                             |                             |necessary to make the        |
|                                                             |                             |string's length exactly n    |
|                                                             |                             |characters.                  |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& assign(const basic_string&)                    |basic_string                 |Synonym for operator=        |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|                                                             |basic_string                 |Assigns a substring of s to  |
|basic_string& assign(const basic_string& s,                  |                             |*this                        |
|                     size_type pos, size_type n)             |                             |                             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& assign(const charT* s, size_type n)            |basic_string                 |Assigns the first n          |
|                                                             |                             |characters of s to *this.    |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& assign(const charT* s)                         |basic_string                 |Assigns a null-terminated    |
|                                                             |                             |array of characters to *this.|
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& assign(size_type n, charT c)                   ||stl-Sequence|               |Erases the existing          |
|                                                             |                             |characters and replaces them |
|                                                             |                             |by n copies of c.            |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class InputIterator>                               ||stl-Sequence|               |Erases the existing          |
|basic_string& assign(InputIterator first, InputIterator last)|                             |characters and replaces them |
|                                                             |                             |by [first, last)             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& replace(size_type pos, size_type n,            |basic_string                 |Replaces a substring of *this|
|                      const basic_string& s)                 |                             |with the string s.           |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& replace(size_type pos, size_type n,            |basic_string                 |Replaces a substring of *this|
|                      const basic_string& s,                 |                             |with a substring of s.       |
|                      size_type pos1, size_type n1)          |                             |                             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& replace(size_type pos, size_type n,            |basic_string                 |Replaces a substring of *this|
|                      const charT* s, size_type n1)          |                             |with the first n1 characters |
|                                                             |                             |of s.                        |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& replace(size_type pos, size_type n,            |basic_string                 |Replaces a substring of *this|
|                      const charT* s)                        |                             |with a null-terminated       |
|                                                             |                             |character array.             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& replace(size_type pos, size_type n,            |basic_string                 |Replaces a substring of *this|
|                      size_type n1, charT c)                 |                             |with n1 copies of c.         |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& replace(iterator first, iterator last,         |basic_string                 |Replaces a substring of *this|
|                      const basic_string& s)                 |                             |with the string s.           |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& replace(iterator first, iterator last,         |basic_string                 |Replaces a substring of *this|
|                      const charT* s, size_type n)           |                             |with the first n characters  |
|                                                             |                             |of s.                        |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& replace(iterator first, iterator last,         |basic_string                 |Replaces a substring of *this|
|                      const charT* s)                        |                             |with a null-terminated       |
|                                                             |                             |character array.             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string& replace(iterator first, iterator last,         |basic_string                 |Replaces a substring of *this|
|                      size_type n, charT c)                  |                             |with n copies of c.          |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class InputIterator>                               |basic_string                 |Replaces a substring of *this|
|basic_string& replace(iterator first, iterator last,         |                             |with the range [f, l)        |
|                      InputIterator f, InputIterator l)      |                             |                             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type copy(charT* buf, size_type n, size_type pos = 0)   |basic_string                 |Copies a substring of *this  |
|const                                                        |                             |to a buffer.                 |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find(const basic_string& s, size_type pos = 0)     |basic_string                 |Searches for s as a substring|
|const                                                        |                             |of *this, beginning at       |
|                                                             |                             |character pos of *this.      |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find(const charT* s, size_type pos, size_type n)   |basic_string                 |Searches for the first n     |
|const                                                        |                             |characters of s as a         |
|                                                             |                             |substring of *this, beginning|
|                                                             |                             |at character pos of *this.   |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find(const charT* s, size_type pos = 0) const      |basic_string                 |Searches for a               |
|                                                             |                             |null-terminated character    |
|                                                             |                             |array as a substring of      |
|                                                             |                             |*this, beginning at character|
|                                                             |                             |pos of *this.                |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find(charT c, size_type pos = 0) const             |basic_string                 |Searches for the character c,|
|                                                             |                             |beginning at character       |
|                                                             |                             |position pos.                |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type rfind(const basic_string& s, size_type pos = npos) |basic_string                 |Searches backward for s as a |
|const                                                        |                             |substring of *this, beginning|
|                                                             |                             |at character position        |
|                                                             |                             |min(pos, size())             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type rfind(const charT* s, size_type pos, size_type n)  |basic_string                 |Searches backward for the    |
|const                                                        |                             |first n characters of s as a |
|                                                             |                             |substring of *this, beginning|
|                                                             |                             |at character position        |
|                                                             |                             |min(pos, size())             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type rfind(const charT* s, size_type pos = npos) const  |basic_string                 |Searches backward for a      |
|                                                             |                             |null-terminated character    |
|                                                             |                             |array as a substring of      |
|                                                             |                             |*this, beginning at character|
|                                                             |                             |min(pos, size())             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type rfind(charT c, size_type pos = npos) const         |basic_string                 |Searches backward for the    |
|                                                             |                             |character c, beginning at    |
|                                                             |                             |character position min(pos,  |
|                                                             |                             |size().                      |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find_first_of(const basic_string& s, size_type pos |basic_string                 |Searches within *this,       |
|= 0) const                                                   |                             |beginning at pos, for the    |
|                                                             |                             |first character that is equal|
|                                                             |                             |to any character within s.   |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find_first_of(const charT* s, size_type pos,       |basic_string                 |Searches within *this,       |
|size_type n) const                                           |                             |beginning at pos, for the    |
|                                                             |                             |first character that is equal|
|                                                             |                             |to any character within the  |
|                                                             |                             |first n characters of s.     |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find_first_of(const charT* s, size_type pos = 0)   |basic_string                 |Searches within *this,       |
|const                                                        |                             |beginning at pos, for the    |
|                                                             |                             |first character that is equal|
|                                                             |                             |to any character within s.   |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find_first_of(charT c, size_type pos = 0) const    |basic_string                 |Searches within *this,       |
|                                                             |                             |beginning at pos, for the    |
|                                                             |                             |first character that is equal|
|                                                             |                             |to c.                        |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find_first_not_of(const basic_string& s, size_type |basic_string                 |Searches within *this,       |
|pos = 0) const                                               |                             |beginning at pos, for the    |
|                                                             |                             |first character that is not  |
|                                                             |                             |equal to any character within|
|                                                             |                             |s.                           |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find_first_not_of(const charT* s, size_type pos,   |basic_string                 |Searches within *this,       |
|size_type n) const                                           |                             |beginning at pos, for the    |
|                                                             |                             |first character that is not  |
|                                                             |                             |equal to any character within|
|                                                             |                             |the first n characters of s. |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find_first_not_of(const charT* s, size_type pos =  |basic_string                 |Searches within *this,       |
|0) const                                                     |                             |beginning at pos, for the    |
|                                                             |                             |first character that is not  |
|                                                             |                             |equal to any character within|
|                                                             |                             |s.                           |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find_first_not_of(charT c, size_type pos = 0) const|basic_string                 |Searches within *this,       |
|                                                             |                             |beginning at pos, for the    |
|                                                             |                             |first character that is not  |
|                                                             |                             |equal to c.                  |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find_last_of(const basic_string& s, size_type pos =|basic_string                 |Searches backward within     |
|npos) const                                                  |                             |*this, beginning at min(pos, |
|                                                             |                             |size()), for the first       |
|                                                             |                             |character that is equal to   |
|                                                             |                             |any character within s.      |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find_last_of(const charT* s, size_type pos,        |basic_string                 |Searches backward within     |
|size_type n) const                                           |                             |*this, beginning at min(pos, |
|                                                             |                             |size()), for the first       |
|                                                             |                             |character that is equal to   |
|                                                             |                             |any character within the     |
|                                                             |                             |first n characters of s.     |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find_last_of(const charT* s, size_type pos = npos) |basic_string                 |Searches backward *this,     |
|const                                                        |                             |beginning at min(pos,        |
|                                                             |                             |size()), for the first       |
|                                                             |                             |character that is equal to   |
|                                                             |                             |any character within s.      |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find_last_of(charT c, size_type pos = npos) const  |basic_string                 |Searches backward *this,     |
|                                                             |                             |beginning at min(pos,        |
|                                                             |                             |size()), for the first       |
|                                                             |                             |character that is equal to c.|
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find_last_not_of(const basic_string& s, size_type  |basic_string                 |Searches backward within     |
|pos = npos) const                                            |                             |*this, beginning at min(pos, |
|                                                             |                             |size()), for the first       |
|                                                             |                             |character that is not equal  |
|                                                             |                             |to any character within s.   |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find_last_not_of(const charT* s, size_type pos,    |basic_string                 |Searches backward within     |
|size_type n) const                                           |                             |*this, beginning at min(pos, |
|                                                             |                             |size()), for the first       |
|                                                             |                             |character that is not equal  |
|                                                             |                             |to any character within the  |
|                                                             |                             |first n characters of s.     |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find_last_not_of(const charT* s, size_type pos =   |basic_string                 |Searches backward *this,     |
|npos) const                                                  |                             |beginning at min(pos,        |
|                                                             |                             |size()), for the first       |
|                                                             |                             |character that is not equal  |
|                                                             |                             |to any character within s.   |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type find_last_not_of(charT c, size_type pos = npos)    |basic_string                 |Searches backward *this,     |
|const                                                        |                             |beginning at min(pos,        |
|                                                             |                             |size()), for the first       |
|                                                             |                             |character that is not equal  |
|                                                             |                             |to c.                        |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|basic_string substr(size_type pos = 0, size_type n = npos)   |basic_string                 |Returns a substring of *this.|
|const                                                        |                             |                             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|int compare(const basic_string& s) const                     |basic_string                 |Three-way lexicographical    |
|                                                             |                             |comparison of s and *this.   |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|int compare(size_type pos, size_type n, const basic_string&  |basic_string                 |Three-way lexicographical    |
|s) const                                                     |                             |comparison of s and a        |
|                                                             |                             |substring of *this.          |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|int compare(size_type pos, size_type n, const basic_string&  |basic_string                 |Three-way lexicographical    |
|s, size_type pos1, size_type n1) const                       |                             |comparison of a substring of |
|                                                             |                             |s and a substring of *this.  |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|int compare(const charT* s) const                            |basic_string                 |Three-way lexicographical    |
|                                                             |                             |comparison of s and *this.   |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|int compare(size_type pos, size_type n, const charT* s,      |basic_string                 |Three-way lexicographical    |
|size_type len = npos) const                                  |                             |comparison of the first      |
|                                                             |                             |min(len, traits::length(s)   |
|                                                             |                             |characters of s and a        |
|                                                             |                             |substring of *this.          |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class charT, class traits, class Alloc>            |basic_string                 |String concatenation. A      |
|basic_string<charT, traits, Alloc>                           |                             |global function, not a member|
|operator+(const basic_string<charT, traits, Alloc>& s1,      |                             |function.                    |
|          const basic_string<charT, traits, Alloc>& s2)      |                             |                             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class charT, class traits, class Alloc>            |basic_string                 |String concatenation. A      |
|basic_string<charT, traits, Alloc>                           |                             |global function, not a member|
|operator+(const charT* s1,                                   |                             |function.                    |
|          const basic_string<charT, traits, Alloc>& s2)      |                             |                             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class charT, class traits, class Alloc>            |basic_string                 |String concatenation. A      |
|basic_string<charT, traits, Alloc>                           |                             |global function, not a member|
|operator+(const basic_string<charT, traits, Alloc>& s1,      |                             |function.                    |
|          const charT* s2)                                   |                             |                             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class charT, class traits, class Alloc>            |basic_string                 |String concatenation. A      |
|basic_string<charT, traits, Alloc>                           |                             |global function, not a member|
|operator+(charT c,                                           |                             |function.                    |
|          const basic_string<charT, traits, Alloc>& s2)      |                             |                             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class charT, class traits, class Alloc>            |basic_string                 |String concatenation. A      |
|basic_string<charT, traits, Alloc>                           |                             |global function, not a member|
|operator+(const basic_string<charT, traits, Alloc>& s1,      |                             |function.                    |
|          charT c)                                           |                             |                             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class charT, class traits, class Alloc>            ||stl-Container|              |String equality. A global    |
|bool operator==(const basic_string<charT, traits, Alloc>& s1,|                             |function, not a member       |
|                const basic_string<charT, traits, Alloc>& s2)|                             |function.                    |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class charT, class traits, class Alloc>            |basic_string                 |String equality. A global    |
|bool operator==(const charT* s1,                             |                             |function, not a member       |
|                const basic_string<charT, traits, Alloc>& s2)|                             |function.                    |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class charT, class traits, class Alloc>            |basic_string                 |String equality. A global    |
|bool operator==(const basic_string<charT, traits, Alloc>& s1,|                             |function, not a member       |
|                const charT* s2)                             |                             |function.                    |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class charT, class traits, class Alloc>            ||stl-Container|              |String inequality. A global  |
|bool operator!=(const basic_string<charT, traits, Alloc>& s1,|                             |function, not a member       |
|                const basic_string<charT, traits, Alloc>& s2)|                             |function.                    |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class charT, class traits, class Alloc>            |basic_string                 |String inequality. A global  |
|bool operator!=(const charT* s1,                             |                             |function, not a member       |
|                const basic_string<charT, traits, Alloc>& s2)|                             |function.                    |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class charT, class traits, class Alloc>            |basic_string                 |String inequality. A global  |
|bool operator!=(const basic_string<charT, traits, Alloc>& s1,|                             |function, not a member       |
|                const charT* s2)                             |                             |function.                    |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class charT, class traits, class Alloc>            ||stl-Container|              |String comparison. A global  |
|bool operator<(const basic_string<charT, traits, Alloc>& s1, |                             |function, not a member       |
|               const basic_string<charT, traits, Alloc>& s2) |                             |function.                    |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class charT, class traits, class Alloc>            |basic_string                 |String comparison. A global  |
|bool operator<(const charT* s1,                              |                             |function, not a member       |
|               const basic_string<charT, traits, Alloc>& s2) |                             |function.                    |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class charT, class traits, class Alloc>            |basic_string                 |String comparison. A global  |
|bool operator<(const basic_string<charT, traits, Alloc>& s1, |                             |function, not a member       |
|               const charT* s2)                              |                             |function.                    |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class charT, class traits, class Alloc>            ||stl-Container|              |Swaps the contents of two    |
|void swap(basic_string<charT, traits, Alloc>& s1,            |                             |strings.                     |
|          basic_string<charT, traits, Alloc>& s2)            |                             |                             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class charT, class traits, class Alloc>            |basic_string                 |Reads s from the input stream|
|basic_istream<charT, traits>&                                |                             |is                           |
|operator>>(basic_istream<charT, traits>& is,                 |                             |                             |
|           basic_string<charT, traits, Alloc>& s)            |                             |                             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class charT, class traits, class Alloc>            |basic_string                 |Writes s to the output stream|
|basic_ostream<charT, traits>&                                |                             |os                           |
|operator<<(basic_istream<charT, traits>& os,                 |                             |                             |
|           const basic_string<charT, traits, Alloc>& s)      |                             |                             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class charT, class traits, class Alloc>            |basic_string                 |Reads a string from the input|
|basic_istream<charT, traits>&                                |                             |stream is, stopping when it  |
|getline(basic_istream<charT, traits>& is,                    |                             |reaches delim                |
|        basic_string<charT, traits, Alloc>& s,               |                             |                             |
|        charT delim)                                         |                             |                             |
|-------------------------------------------------------------+-----------------------------+-----------------------------|
|template <class charT, class traits, class Alloc>            |basic_string                 |Reads a single line from the |
|basic_istream<charT, traits>&                                |                             |input stream is              |
|getline(basic_istream<charT, traits>& is,                    |                             |                             |
|        basic_string<charT, traits, Alloc>& s)               |                             |                             |
+-------------------------------------------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-RandomAccessContainer| and
   |stl-Sequence|: requirements, but are specific to basic_string.

+---------------------------------------------------------------------------------------------------------+
|                                  Member                                  |         Description          |
|--------------------------------------------------------------------------+------------------------------|
|static const size_type npos                                               |The largest possible value of |
|                                                                          |type size_type. That is,      |
|                                                                          |size_type(-1).                |
|--------------------------------------------------------------------------+------------------------------|
|size_type length() const                                                  |Equivalent to size().         |
|--------------------------------------------------------------------------+------------------------------|
|size_type capacity() const                                                |Number of elements for which  |
|                                                                          |memory has been allocated.    |
|                                                                          |That is, the size to which the|
|                                                                          |string can grow before memory |
|                                                                          |must be reallocated.          |
|                                                                          |capacity() is always greater  |
|                                                                          |than or equal to size().      |
|--------------------------------------------------------------------------+------------------------------|
|const charT* c_str() const                                                |Returns a pointer to a        |
|                                                                          |null-terminated array of      |
|                                                                          |characters representing the   |
|                                                                          |string's contents. For any    |
|                                                                          |string s it is guaranteed that|
|                                                                          |the first s.size() characters |
|                                                                          |in the array pointed to by    |
|                                                                          |s.c_str() are equal to the    |
|                                                                          |character in s, and that      |
|                                                                          |s.c_str()[s.size()] is a null |
|                                                                          |character. Note, however, that|
|                                                                          |it not necessarily the first  |
|                                                                          |null character. Characters    |
|                                                                          |within a string are permitted |
|                                                                          |to be null.                   |
|--------------------------------------------------------------------------+------------------------------|
|const charT* data() const                                                 |Returns a pointer to an array |
|                                                                          |of characters, not necessarily|
|                                                                          |null-terminated, representing |
|                                                                          |the string's contents. data() |
|                                                                          |is permitted, but not         |
|                                                                          |required, to be identical to  |
|                                                                          |c_str(). The first size()     |
|                                                                          |characters of that array are  |
|                                                                          |guaranteed to be identical to |
|                                                                          |the characters in *this. The  |
|                                                                          |return value of data() is     |
|                                                                          |never a null pointer, even if |
|                                                                          |size() is zero.               |
|--------------------------------------------------------------------------+------------------------------|
|basic_string(const basic_string& s, size_type pos = 0, size_type n = npos)|Constructs a string from a    |
|                                                                          |substring of s. The substring |
|                                                                          |begins at character position  |
|                                                                          |pos and terminates at         |
|                                                                          |character position pos + n or |
|                                                                          |at the end of s, whichever    |
|                                                                          |comes first. This constructor |
|                                                                          |throws out_of_range if pos >  |
|                                                                          |s.size(). Note that when pos  |
|                                                                          |and n have their default      |
|                                                                          |values, this is just a copy   |
|                                                                          |constructor.                  |
|--------------------------------------------------------------------------+------------------------------|
|basic_string(const charT* s)                                              |Equivalent to basic_string(s, |
|                                                                          |s + traits::length(s)).       |
|--------------------------------------------------------------------------+------------------------------|
|basic_string(const charT* s, size_type n)                                 |Equivalent to basic_string(s, |
|                                                                          |s + n).                       |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& operator=(const charT* s)                                   |Equivalent to                 |
|                                                                          |operator=(basic_string(s)).   |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& operator=(charT c)                                          |Assigns to *this a string     |
|                                                                          |whose size is 1 and whose     |
|                                                                          |contents is the single        |
|                                                                          |character c.                  |
|--------------------------------------------------------------------------+------------------------------|
|void reserve(size_t n)                                                    |Requests that the string's    |
|                                                                          |capacity be changed; the      |
|                                                                          |postcondition for this member |
|                                                                          |function is that, after it is |
|                                                                          |called, capacity() >= n. You  |
|                                                                          |may request that a string     |
|                                                                          |decrease its capacity by      |
|                                                                          |calling reserve() with an     |
|                                                                          |argument less than the current|
|                                                                          |capacity. (If you call        |
|                                                                          |reserve() with an argument    |
|                                                                          |less than the string's size,  |
|                                                                          |however, the capacity will    |
|                                                                          |only be reduced to size(). A  |
|                                                                          |string's size can never be    |
|                                                                          |greater than its capacity.)   |
|                                                                          |reserve() throws length_error |
|                                                                          |if n > max_size().            |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& insert(size_type pos, const basic_string& s)                |If pos > size(), throws       |
|                                                                          |out_of_range. Otherwise,      |
|                                                                          |equivalent to insert(begin() +|
|                                                                          |pos, s.begin(), s.end()).     |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& insert(size_type pos,                                       |If pos > size() or pos1 >     |
|                     const basic_string& s,                               |s.size(), throws out_of_range.|
|                     size_type pos1, size_type n)                         |Otherwise, equivalent to      |
|                                                                          |insert(begin() + pos,         |
|                                                                          |s.begin() + pos1, s.begin() + |
|                                                                          |pos1 + min(n, s.size() -      |
|                                                                          |pos1)).                       |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& insert(size_type pos, const charT* s)                       |If pos > size(), throws       |
|                                                                          |out_of_range. Otherwise,      |
|                                                                          |equivalent to insert(begin() +|
|                                                                          |pos, s, s + traits::length(s))|
|--------------------------------------------------------------------------+------------------------------|
|basic_string& insert(size_type pos, const charT* s, size_type n)          |If pos > size(), throws       |
|                                                                          |out_of_range. Otherwise,      |
|                                                                          |equivalent to insert(begin() +|
|                                                                          |pos, s, s + n).               |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& insert(size_type pos, size_type n, charT c)                 |If pos > size(), throws       |
|                                                                          |out_of_range. Otherwise,      |
|                                                                          |equivalent to insert(begin() +|
|                                                                          |pos, n, c).                   |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& append(const basic_string& s)                               |Equivalent to insert(end(),   |
|                                                                          |s.begin(), s.end()).          |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& append(const basic_string& s,                               |If pos > s.size(), throws     |
|                     size_type pos, size_type n)                          |out_of_range. Otherwise,      |
|                                                                          |equivalent to insert(end(),   |
|                                                                          |s.begin() + pos, s.begin() +  |
|                                                                          |pos + min(n, s.size() - pos)).|
|--------------------------------------------------------------------------+------------------------------|
|basic_string& append(const charT* s)                                      |Equivalent to insert(end(), s,|
|                                                                          |s + traits::length(s)).       |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& append(const charT* s, size_type n)                         |Equivalent to insert(end(), s,|
|                                                                          |s + n).                       |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& append(size_type n, charT c)                                |Equivalent to insert(end(), n,|
|                                                                          |c).                           |
|--------------------------------------------------------------------------+------------------------------|
|template <class InputIterator>                                            |Equivalent to insert(end(),   |
|basic_string& append(InputIterator first, InputIterator last)             |first, last).                 |
|--------------------------------------------------------------------------+------------------------------|
|void push_back(charT c)                                                   |Equivalent to insert(end(), c)|
|--------------------------------------------------------------------------+------------------------------|
|basic_string& operator+=(const basic_string& s)                           |Equivalent to append(s).      |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& operator+=(const charT* s)                                  |Equivalent to append(s)       |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& operator+=(charT c)                                         |Equivalent to push_back(c)    |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& erase(size_type pos = 0, size_type n = npos)                |If pos > size(), throws       |
|                                                                          |out_of_range. Otherwise,      |
|                                                                          |equivalent to erase(begin() + |
|                                                                          |pos, begin() + pos + min(n,   |
|                                                                          |size() - pos)).               |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& assign(const basic_string& s)                               |Synonym for operator=         |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& assign(const basic_string& s,                               |Equivalent to (but probably   |
|                     size_type pos, size_type n)                          |faster than) clear() followed |
|                                                                          |by insert(0, s, pos, n).      |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& assign(const charT* s, size_type n)                         |Equivalent to (but probably   |
|                                                                          |faster than) clear() followed |
|                                                                          |by insert(0, s, n).           |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& assign(const charT* s)                                      |Equivalent to (but probably   |
|                                                                          |faster than) clear() followed |
|                                                                          |by insert(0, s).              |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& replace(size_type pos, size_type n,                         |Equivalent to erase(pos, n)   |
|                      const basic_string& s)                              |followed by insert(pos, s).   |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& replace(size_type pos, size_type n,                         |Equivalent to erase(pos, n)   |
|                      const basic_string& s, size_type pos1, size_type n1)|followed by insert(pos, s,    |
|                                                                          |pos1, n1).                    |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& replace(size_type pos, size_type n,                         |Equivalent to erase(pos, n)   |
|                      const charT* s, size_type n1)                       |followed by insert(pos, s,    |
|                                                                          |n1).                          |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& replace(size_type pos, size_type n,                         |Equivalent to erase(pos, n)   |
|                      const charT* s)                                     |followed by insert(pos, s).   |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& replace(size_type pos, size_type n,                         |Equivalent to erase(pos, n)   |
|                      size_type n1, charT c)                              |followed by insert(pos, n1,   |
|                                                                          |c).                           |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& replace(iterator first, iterator last,                      |Equivalent to                 |
|                      const basic_string& s)                              |insert(erase(first, last),    |
|                                                                          |s.begin(), s.end()).          |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& replace(iterator first, iterator last,                      |Equivalent to                 |
|                      const charT* s, size_type n)                        |insert(erase(first, last), s, |
|                                                                          |s + n).                       |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& replace(iterator first, iterator last,                      |Equivalent to                 |
|                      const charT* s)                                     |insert(erase(first, last), s, |
|                                                                          |s + traits::length(s)).       |
|--------------------------------------------------------------------------+------------------------------|
|basic_string& replace(iterator first, iterator last,                      |Equivalent to                 |
|                      size_type n, charT c)                               |insert(erase(first, last), n, |
|                                                                          |c).                           |
|--------------------------------------------------------------------------+------------------------------|
|template <class InputIterator>                                            |Equivalent to                 |
|basic_string& replace(iterator first, iterator last,                      |insert(erase(first, last), f, |
|                      InputIterator f, InputIterator l)                   |l).                           |
|--------------------------------------------------------------------------+------------------------------|
|size_type copy(charT* buf, size_type n, size_type pos = 0) const          |Copies at most n characters   |
|                                                                          |from *this to a character     |
|                                                                          |array. Throws out_of_range if |
|                                                                          |pos > size(). Otherwise,      |
|                                                                          |equivalent to                 |
|                                                                          ||stl-copy|(begin() + pos,     |
|                                                                          |begin() + pos + min(n,        |
|                                                                          |size()), buf). Note that this |
|                                                                          |member function does nothing  |
|                                                                          |other than copy characters    |
|                                                                          |from *this to buf; in         |
|                                                                          |particular, it does not       |
|                                                                          |terminate buf with a null     |
|                                                                          |character.                    |
|--------------------------------------------------------------------------+------------------------------|
|size_type find(const basic_string& s, size_type pos = 0) const            |Searches for s as a substring |
|                                                                          |of *this, beginning at        |
|                                                                          |character position pos. It is |
|                                                                          |almost the same as            |
|                                                                          ||stl-search|, except that     |
|                                                                          ||stl-search| tests elements   |
|                                                                          |for equality using operator== |
|                                                                          |or a user-provided function   |
|                                                                          |object, while this member     |
|                                                                          |function uses traits::eq.     |
|                                                                          |Returns the lowest character  |
|                                                                          |position N such that pos <= N |
|                                                                          |and pos + s.size() <= size()  |
|                                                                          |and such that, for every i    |
|                                                                          |less than s.size(), (*this)[N |
|                                                                          |+ i] compares equal to s[i].  |
|                                                                          |Returns npos if no such       |
|                                                                          |position N exists. Note that  |
|                                                                          |it is legal to call this      |
|                                                                          |member function with arguments|
|                                                                          |such that s.size() > size() - |
|                                                                          |pos, but such a search will   |
|                                                                          |always fail.                  |
|--------------------------------------------------------------------------+------------------------------|
|size_type find(const charT* s, size_type pos, size_type n) const          |Searches for the first n      |
|                                                                          |characters of s as a substring|
|                                                                          |of *this, beginning at        |
|                                                                          |character pos of *this. This  |
|                                                                          |is equivalent to              |
|                                                                          |find(basic_string(s, n), pos).|
|--------------------------------------------------------------------------+------------------------------|
|size_type find(const charT* s, size_type pos = 0) const                   |Searches for a null-terminated|
|                                                                          |character array as a substring|
|                                                                          |of *this, beginning at        |
|                                                                          |character pos of *this. This  |
|                                                                          |is equivalent to              |
|                                                                          |find(basic_string(s), pos).   |
|--------------------------------------------------------------------------+------------------------------|
|size_type find(charT c, size_type pos = 0) const                          |Searches for the character c, |
|                                                                          |beginning at character        |
|                                                                          |position pos. That is, returns|
|                                                                          |the first character position N|
|                                                                          |greater than or equal to pos, |
|                                                                          |and less than size(), such    |
|                                                                          |that (*this)[N] compares equal|
|                                                                          |to c. Returns npos if no such |
|                                                                          |character position N exists.  |
|--------------------------------------------------------------------------+------------------------------|
|size_type rfind(const basic_string& s, size_type pos = npos) const        |Searches backward for s as a  |
|                                                                          |substring of *this. It is     |
|                                                                          |almost the same as            |
|                                                                          ||stl-find_end|, except that   |
|                                                                          ||stl-find_end| tests elements |
|                                                                          |for equality using operator== |
|                                                                          |or a user-provided function   |
|                                                                          |object, while this member     |
|                                                                          |function uses traits::eq. This|
|                                                                          |member function returns the   |
|                                                                          |largest character position N  |
|                                                                          |such that N <= pos and N +    |
|                                                                          |s.size() <= size(), and such  |
|                                                                          |that, for every i less than   |
|                                                                          |s.size(), (*this)[N + i]      |
|                                                                          |compares equal to s[i].       |
|                                                                          |Returns npos if no such       |
|                                                                          |position N exists. Note that  |
|                                                                          |it is legal to call this      |
|                                                                          |member function with arguments|
|                                                                          |such that s.size() > size(),  |
|                                                                          |but such a search will always |
|                                                                          |fail.                         |
|--------------------------------------------------------------------------+------------------------------|
|size_type rfind(const charT* s, size_type pos, size_type n) const         |Searches backward for the     |
|                                                                          |first n characters of s as a  |
|                                                                          |substring of *this. Equivalent|
|                                                                          |to rfind(basic_string(s, n),  |
|                                                                          |pos).                         |
|--------------------------------------------------------------------------+------------------------------|
|size_type rfind(const charT* s, size_type pos = npos) const               |Searches backward for a       |
|                                                                          |null-terminated character     |
|                                                                          |array as a substring of *this.|
|                                                                          |Equivalent to                 |
|                                                                          |rfind(basic_string(s), pos).  |
|--------------------------------------------------------------------------+------------------------------|
|size_type rfind(charT c, size_type pos = npos) const                      |Searches backward for the     |
|                                                                          |character c. That is, returns |
|                                                                          |the largest character position|
|                                                                          |N such that N <= pos and N <  |
|                                                                          |size(), and such that         |
|                                                                          |(*this)[N] compares equal to  |
|                                                                          |c. Returns npos if no such    |
|                                                                          |character position exists.    |
|--------------------------------------------------------------------------+------------------------------|
|size_type find_first_of(const basic_string& s, size_type pos = 0) const   |Searches within *this,        |
|                                                                          |beginning at pos, for the     |
|                                                                          |first character that is equal |
|                                                                          |to any character within s.    |
|                                                                          |This is similar to the        |
|                                                                          |standard algorithm            |
|                                                                          ||stl-find_first_of|, but      |
|                                                                          |differs because               |
|                                                                          ||stl-find_first_of| compares  |
|                                                                          |characters using operator== or|
|                                                                          |a user-provided function      |
|                                                                          |object, while this member     |
|                                                                          |function uses traits::eq.     |
|                                                                          |Returns the smallest character|
|                                                                          |position N such that pos <= N |
|                                                                          |< size(), and such that       |
|                                                                          |(*this)[N] compares equal to  |
|                                                                          |some character within s.      |
|                                                                          |Returns npos if no such       |
|                                                                          |character position exists.    |
|--------------------------------------------------------------------------+------------------------------|
|size_type find_first_of(const charT* s, size_type pos, size_type n) const |Searches within *this,        |
|                                                                          |beginning at pos, for the     |
|                                                                          |first character that is equal |
|                                                                          |to any character within the   |
|                                                                          |range [s, s+n). That is,      |
|                                                                          |returns the smallest character|
|                                                                          |position N such that pos <= N |
|                                                                          |< size(), and such that       |
|                                                                          |(*this)[N] compares equal to  |
|                                                                          |some character in [s, s+n).   |
|                                                                          |Returns npos if no such       |
|                                                                          |character position exists.    |
|--------------------------------------------------------------------------+------------------------------|
|size_type find_first_of(const charT* s, size_type pos = 0) const          |Equivalent to find_first_of(s,|
|                                                                          |pos, traits::length(s)).      |
|--------------------------------------------------------------------------+------------------------------|
|size_type find_first_of(charT c, size_type pos = 0) const                 |Equivalent to find(c, pos).   |
|--------------------------------------------------------------------------+------------------------------|
|size_type find_first_not_of(const basic_string& s, size_type pos = 0)     |Searches within *this,        |
|const                                                                     |beginning at pos, for the     |
|                                                                          |first character that is not   |
|                                                                          |equal to any character within |
|                                                                          |s. Returns the smallest       |
|                                                                          |character position N such that|
|                                                                          |pos <= N < size(), and such   |
|                                                                          |that (*this)[N] does not      |
|                                                                          |compare equal to any character|
|                                                                          |within s. Returns npos if no  |
|                                                                          |such character position       |
|                                                                          |exists.                       |
|--------------------------------------------------------------------------+------------------------------|
|size_type find_first_not_of(const charT* s, size_type pos, size_type n)   |Searches within *this,        |
|const                                                                     |beginning at pos, for the     |
|                                                                          |first character that is not   |
|                                                                          |equal to any character within |
|                                                                          |the range [s, s+n). That is,  |
|                                                                          |returns the smallest character|
|                                                                          |position N such that pos <= N |
|                                                                          |< size(), and such that       |
|                                                                          |(*this)[N] does not compare   |
|                                                                          |equal to any character in [s, |
|                                                                          |s+n). Returns npos if no such |
|                                                                          |character position exists.    |
|--------------------------------------------------------------------------+------------------------------|
|size_type find_first_not_of(const charT* s, size_type pos = 0) const      |Equivalent to                 |
|                                                                          |find_first_not_of(s, pos,     |
|                                                                          |traits::length(s)).           |
|--------------------------------------------------------------------------+------------------------------|
|size_type find_first_not_of(charT c, size_type pos = 0) const             |Returns the smallest character|
|                                                                          |position N such that pos <= N |
|                                                                          |< size(), and such that       |
|                                                                          |(*this)[N] does not compare   |
|                                                                          |equal to c. Returns npos if no|
|                                                                          |such character position       |
|                                                                          |exists.                       |
|--------------------------------------------------------------------------+------------------------------|
|size_type find_last_of(const basic_string& s, size_type pos = npos) const |Searches backward within *this|
|                                                                          |for the first character that  |
|                                                                          |is equal to any character     |
|                                                                          |within s. That is, returns the|
|                                                                          |largest character position N  |
|                                                                          |such that N <= pos and N <    |
|                                                                          |size(), and such that         |
|                                                                          |(*this)[N] compares equal to  |
|                                                                          |some character within s.      |
|                                                                          |Returns npos if no such       |
|                                                                          |character position exists.    |
|--------------------------------------------------------------------------+------------------------------|
|size_type find_last_of(const charT* s, size_type pos, size_type n) const  |Searches backward within *this|
|                                                                          |for the first character that  |
|                                                                          |is equal to any character     |
|                                                                          |within the range [s, s+n).    |
|                                                                          |That is, returns the largest  |
|                                                                          |character position N such that|
|                                                                          |N <= pos and N < size(), and  |
|                                                                          |such that (*this)[N] compares |
|                                                                          |equal to some character within|
|                                                                          |[s, s+n). Returns npos if no  |
|                                                                          |such character position       |
|                                                                          |exists.                       |
|--------------------------------------------------------------------------+------------------------------|
|size_type find_last_of(const charT* s, size_type pos = npos) const        |Equivalent to find_last_of(s, |
|                                                                          |pos, traits::length(s)).      |
|--------------------------------------------------------------------------+------------------------------|
|size_type find_last_of(charT c, size_type pos = npos) const               |Equivalent to rfind(c, pos).  |
|--------------------------------------------------------------------------+------------------------------|
|size_type find_last_not_of(const basic_string& s, size_type pos = npos)   |Searches backward within *this|
|const                                                                     |for the first character that  |
|                                                                          |is not equal to any character |
|                                                                          |within s. That is, returns the|
|                                                                          |largest character position N  |
|                                                                          |such that N <= pos and N <    |
|                                                                          |size(), and such that         |
|                                                                          |(*this)[N] does not compare   |
|                                                                          |equal to any character within |
|                                                                          |s. Returns npos if no such    |
|                                                                          |character position exists.    |
|--------------------------------------------------------------------------+------------------------------|
|size_type find_last_not_of(const charT* s, size_type pos, size_type n)    |Searches backward within *this|
|const                                                                     |for the first character that  |
|                                                                          |is not equal to any character |
|                                                                          |within [s, s+n). That is,     |
|                                                                          |returns the largest character |
|                                                                          |position N such that N <= pos |
|                                                                          |and N < size(), and such that |
|                                                                          |(*this)[N] does not compare   |
|                                                                          |equal to any character within |
|                                                                          |[s, s+n). Returns npos if no  |
|                                                                          |such character position       |
|                                                                          |exists.                       |
|--------------------------------------------------------------------------+------------------------------|
|size_type find_last_not_of(const charT* s, size_type pos = npos) const    |Equivalent to find_last_of(s, |
|                                                                          |pos, traits::length(s)).      |
|--------------------------------------------------------------------------+------------------------------|
|size_type find_last_not_of(charT c, size_type pos = npos) const           |Searches backward *this for   |
|                                                                          |the first character that is   |
|                                                                          |not equal to c. That is,      |
|                                                                          |returns the largest character |
|                                                                          |position N such that N <= pos |
|                                                                          |and N < size(), and such that |
|                                                                          |(*this)[N] does not compare   |
|                                                                          |equal to c.                   |
|--------------------------------------------------------------------------+------------------------------|
|basic_string substr(size_type pos = 0, size_type n = npos) const          |Equivalent to                 |
|                                                                          |basic_string(*this, pos, n).  |
|--------------------------------------------------------------------------+------------------------------|
|int compare(const basic_string& s) const                                  |Three-way lexicographical     |
|                                                                          |comparison of s and *this,    |
|                                                                          |much like strcmp. If          |
|                                                                          |traits::compare(data,         |
|                                                                          |s.data(), min(size(),         |
|                                                                          |s.size())) is nonzero, then it|
|                                                                          |returns that nonzero value.   |
|                                                                          |Otherwise returns a negative  |
|                                                                          |number if size() < s.size(), a|
|                                                                          |positive number if size() >   |
|                                                                          |s.size(), and zero if the two |
|                                                                          |are equal.                    |
|--------------------------------------------------------------------------+------------------------------|
|int compare(size_type pos, size_type n, const basic_string& s) const      |Three-way lexicographical     |
|                                                                          |comparison of s and a         |
|                                                                          |substring of *this. Equivalent|
|                                                                          |to basic_string(*this, pos,   |
|                                                                          |n).compare(s).                |
|--------------------------------------------------------------------------+------------------------------|
|int compare(size_type pos, size_type n, const basic_string& s, size_type  |Three-way lexicographical     |
|pos1, size_type n1) const                                                 |comparison of a substring of s|
|                                                                          |and a substring of *this.     |
|                                                                          |Equivalent to                 |
|                                                                          |basic_string(*this, pos,      |
|                                                                          |n).compare(basic_string(s,    |
|                                                                          |pos1, n1)).                   |
|--------------------------------------------------------------------------+------------------------------|
|int compare(const charT* s) const                                         |Three-way lexicographical     |
|                                                                          |comparison of s and *this.    |
|                                                                          |Equivalent to                 |
|                                                                          |compare(basic_string(s)).     |
|--------------------------------------------------------------------------+------------------------------|
|int compare(size_type pos, size_type n, const charT* s, size_type len =   |Three-way lexicographical     |
|npos) const                                                               |comparison of the first       |
|                                                                          |min(len, traits::length(s)    |
|                                                                          |characters of s and a         |
|                                                                          |substring of *this. Equivalent|
|                                                                          |to basic_string(*this, pos,   |
|                                                                          |n).compare(basic_string(s,    |
|                                                                          |min(len, traits::length(s)))).|
|--------------------------------------------------------------------------+------------------------------|
|template <class charT, class traits, class Alloc>                         |String concatenation.         |
|basic_string<charT, traits, Alloc>                                        |Equivalent to creating a      |
|operator+(const basic_string<charT, traits, Alloc>& s1,                   |temporary copy of s, appending|
|          const basic_string<charT, traits, Alloc>& s2)                   |s2, and then returning the    |
|                                                                          |temporary copy.               |
|--------------------------------------------------------------------------+------------------------------|
|template <class charT, class traits, class Alloc>                         |String concatenation.         |
|basic_string<charT, traits, Alloc>                                        |Equivalent to creating a      |
|operator+(const charT* s1,                                                |temporary basic_string object |
|          const basic_string<charT, traits, Alloc>& s2)                   |from s1, appending s2, and    |
|                                                                          |then returning the temporary  |
|                                                                          |object.                       |
|--------------------------------------------------------------------------+------------------------------|
|template <class charT, class traits, class Alloc>                         |String concatenation.         |
|basic_string<charT, traits, Alloc>                                        |Equivalent to creating a      |
|operator+(const basic_string<charT, traits, Alloc>& s1,                   |temporary copy of s, appending|
|          const charT* s2)                                                |s2, and then returning the    |
|                                                                          |temporary copy.               |
|--------------------------------------------------------------------------+------------------------------|
|template <class charT, class traits, class Alloc>                         |String concatenation.         |
|basic_string<charT, traits, Alloc>                                        |Equivalent to creating a      |
|operator+(charT c,                                                        |temporary object with the     |
|          const basic_string<charT, traits, Alloc>& s2)                   |constructor basic_string(1,   |
|                                                                          |c), appending s2, and then    |
|                                                                          |returning the temporary       |
|                                                                          |object.                       |
|--------------------------------------------------------------------------+------------------------------|
|template <class charT, class traits, class Alloc>                         |String concatenation.         |
|basic_string<charT, traits, Alloc>                                        |Equivalent to creating a      |
|operator+(const basic_string<charT, traits, Alloc>& s1,                   |temporary object, appending c |
|          charT c)                                                        |with push_back, and then      |
|                                                                          |returning the temporary       |
|                                                                          |object.                       |
|--------------------------------------------------------------------------+------------------------------|
|template <class charT, class traits, class Alloc>                         |String equality. Equivalent to|
|bool operator==(const charT* s1,                                          |basic_string(s1).compare(s2)  |
|                const basic_string<charT, traits, Alloc>& s2)             |== 0.                         |
|--------------------------------------------------------------------------+------------------------------|
|template <class charT, class traits, class Alloc>                         |String equality. Equivalent to|
|bool operator==(const basic_string<charT, traits, Alloc>& s1,             |basic_string(s1).compare(s2)  |
|                const charT* s2)                                          |== 0.                         |
|--------------------------------------------------------------------------+------------------------------|
|template <class charT, class traits, class Alloc>                         |String inequality. Equivalent |
|bool operator!=(const charT* s1,                                          |to                            |
|                const basic_string<charT, traits, Alloc>& s2)             |basic_string(s1).compare(s2)  |
|                                                                          |== 0.                         |
|--------------------------------------------------------------------------+------------------------------|
|template <class charT, class traits, class Alloc>                         |String inequality. Equivalent |
|bool operator!=(const basic_string<charT, traits, Alloc>& s1,             |to !(s1 == s2).               |
|                const charT* s2)                                          |                              |
|--------------------------------------------------------------------------+------------------------------|
|template <class charT, class traits, class Alloc>                         |String comparison. Equivalent |
|bool operator<(const charT* s1,                                           |to !(s1 == s2).               |
|               const basic_string<charT, traits, Alloc>& s2)              |                              |
|--------------------------------------------------------------------------+------------------------------|
|template <class charT, class traits, class Alloc>                         |String comparison. Equivalent |
|bool operator<(const basic_string<charT, traits, Alloc>& s1,              |to !(s1 == s2).               |
|               const charT* s2)                                           |                              |
|--------------------------------------------------------------------------+------------------------------|
|template <class charT, class traits, class Alloc>                         |Reads s from the input stream |
|basic_istream<charT, traits>&                                             |is. Specifically, it skips    |
|operator>>(basic_istream<charT, traits>& is,                              |whitespace, and then replaces |
|           basic_string<charT, traits, Alloc>& s)                         |the contents of s with        |
|                                                                          |characters read from the input|
|                                                                          |stream. It continues reading  |
|                                                                          |characters until it encounters|
|                                                                          |a whitespace character (in    |
|                                                                          |which case that character is  |
|                                                                          |not extracted), or until      |
|                                                                          |end-of-file, or, if is.width()|
|                                                                          |is nonzero, until it has read |
|                                                                          |is.width() characters. This   |
|                                                                          |member function resets        |
|                                                                          |is.width() to zero.           |
|--------------------------------------------------------------------------+------------------------------|
|template <class charT, class traits, class Alloc>                         |Writes s to the output stream |
|basic_ostream<charT, traits>&                                             |is. It writes max(s.size(),   |
|operator>>(basic_istream<charT, traits>& is,                              |is.width()) characters,       |
|           const basic_string<charT, traits, Alloc>& s)                   |padding as necessary. This    |
|                                                                          |member function resets        |
|                                                                          |is.width() to zero.           |
|--------------------------------------------------------------------------+------------------------------|
|template <class charT, class traits, class Alloc>                         |Replaces the contents of s    |
|basic_istream<charT, traits>&                                             |with characters read from the |
|getline(basic_istream<charT, traits>& is,                                 |input stream. It continues    |
|        basic_string<charT, traits, Alloc>& s,                            |reading characters until it   |
|        charT delim)                                                      |encounters the character delim|
|                                                                          |(in which case that character |
|                                                                          |is extracted but not stored in|
|                                                                          |s), or until end of file. Note|
|                                                                          |that getline, unlike          |
|                                                                          |operator>>, does not skip     |
|                                                                          |whitespace. As the name       |
|                                                                          |suggests, it is most commonly |
|                                                                          |used to read an entire line of|
|                                                                          |text precisely as the line    |
|                                                                          |appears in an input file.     |
|--------------------------------------------------------------------------+------------------------------|
|template <class charT, class traits, class Alloc>                         |Equivalent to getline(is, s,  |
|basic_istream<charT, traits>&                                             |is.widen('\n\)).              |
|getline(basic_istream<charT, traits>& is,                                 |                              |
|        basic_string<charT, traits, Alloc>& s)                            |                              |
+---------------------------------------------------------------------------------------------------------+

  See also

   |stl-Rope|, |stl-Vector|, |stl-character_traits|


        ________________________________________________________________________
                                      |stl-rope|
*stl-Rope*

                                 rope<T, Alloc>

   Category: containers                                  Component type: type

  Description

   Ropes are a scalable string implementation: they are designed for
   efficient operation that involve the string as a whole. Operations such as
   assignment, concatenation, and substring take time that is nearly
   independent of the length of the string. Unlike C strings, ropes are a
   reasonable representation for very long strings such as edit buffers or
   mail messages. [2][1]

   Though ropes can be treated as |stl-Container|s of characters, and are
   almost |stl-Sequence|s, this is rarely the most efficient way to
   accomplish a task. Replacing an individual character in a rope is slow:
   each character replacement essentially consists of two substring
   operations followed by two concatenation operations. Ropes primarily
   target a more functional programming style.

   They differ from |stl-Vector|<char> or reference-counted string
   implementations in the following ways.

   Advantages:

     * Much faster concatenation and substring operations involving long
       strings. Inserting a character in the middle of a 10 megabyte rope
       should take on the order of 10s of microseconds, even if a copy of the
       original is kept, e.g. as part of an edit history. In contrast, this
       would take on the order of a second for conventional "flat" string
       representation. The time required for concatenation can be viewed as
       constant for most applications. It is perfectly reasonable to use a
       rope as the representation of a file inside a text editor.
     * Potentially much better space performance. Minor modifications of a
       rope can share memory with the original. Ropes are allocated in small
       chunks, significantly reducing memory fragmentation problems
       introduced by large blocks.
     * Assignment is simply a (possibly reference counted) pointer
       assignment. Unlike reference-counted copy-on-write implementations,
       this remains largely true even if one of the copies is subsequently
       slightly modified. It is very inexpensive to checkpoint old versions
       of a string, e.g. in an edit history.
     * It is possible to view a function producing characters as a rope. Thus
       a piece of a rope may be a 100MByte file, which is read only when that
       section of the string is examined. Concatenating a string to the end
       of such a file does not involve reading the file. (Currently the
       implementation of this facility is incomplete.)

   Disadvantages:

     * Single character replacements in a rope are expensive. A character
       update requires time roughly logarithmic in the length of the string.
       It is implemented as two substring operations followed by two
       concatenations.
     * A rope can be examined a character at a time through a const_iterator
       in amortized constant time, as for |stl-Vector|<char>. However this is
       slower than for |stl-Vector|<char> by a significant constant factor
       (roughly a factor of 5 or 10 if little processing is done on each
       character and the string is long). Nonconst iterators involve
       additional checking, and are hence a bit slower still. (We expect that
       eventually some common algorithms will be specialized so that this
       cost is not encountered. Currently only output, conversion to a C
       string, and the single-character find member function are treated in
       this way.)
     * Iterators are on the order of a dozen words in size. This means that
       copying them, though not tremendously expensive, is not a trivial
       operation. Avoid postincrementing iterators; use preincrement whenever
       possible. (The interface also provides primitives for indexing into a
       string using integer character positions. Passing positions around is
       clearly much cheaper, but this makes the indexing operation expensive,
       again roughly logarithmic in the length of the rope.)

   Experience with previous implementations for other programming languages
   suggests that ropes are a good choice as the normal or default
   representation of strings in a program. It will occasionally be necessary
   to use some type of character array, such as |stl-Vector|<char>, in places
   that are particularly sensitive to the performance of traversals or
   in-place updates. But the use of ropes minimizes the number of cases in
   which program running times become intolerable due to unexpectedly long
   string inputs.

   A rope is almost, but not quite, a |stl-Sequence|. It supports random
   access const_iterators. Forward or backward traversals take constant time
   per operation. Nonconstant iterators are also provided. However,
   assignment through a nonconst iterator is an expensive operation
   (basically logarithmic time, but with a large constant). It should be
   avoided in frequently executed code.

   In order to discourage accidental use of expensive operations, the begin
   and end member functions on ropes return const_iterator. If non-const
   iterators are desired, the member functions mutable_begin and mutable_end
   should be used.

   Any modification of a rope invalidates const iterators referring to the
   rope. Mutable iterators refer to the same position in the same rope after
   an update. (This may be surprising if the iterators refers to a position
   after an insertion point.) They remain valid unless the iterator refers to
   a position that is more than one past the end of the resulting rope.

  Definition

   Defined in the header |stl-rope|, and in the backward-compatibility header
   |stl-rope|.h. The rope class, and the |stl-rope| header, are SGI extensions;
   they are not part of the C++ standard.

*stl-Rope-example*

 crope r(1000000, 'x');          // crope is rope<char>. wrope is rope<wchar_t>
                                 // Builds a rope containing a million 'x's.
                                 // Takes much less than a MB, since the
                                 // different pieces are shared.
 crope r2 = r + "abc" + r;       // concatenation; takes on the order of 100s
                                 // of machine instructions; fast
 crope r3 = r2.substr(1000000, 3);       // yields "abc"; fast.
 crope r4 = r2.substr(1000000, 1000000); // also fast.
 reverse(r2.mutable_begin(), r2.mutable_end());
                                 // correct, but slow; may take a
                                 // minute or more.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |               Description               |     Default      |
   |-----------+-----------------------------------------+------------------|
   | T         | The rope's value type: usually char or  |                  |
   |           | wchar_t. [6][2]                         |                  |
   |-----------+-----------------------------------------+------------------|
   | Alloc     | The rope's allocator, used for all      | |stl-Allocators| |
   |           | internal memory management.             |                  |
   +------------------------------------------------------------------------+

  Model of

   |stl-RandomAccessContainer|. Almost, but not quite, a model of
   |stl-FrontInsertionSequence| and |stl-BackInsertionSequence|.

  Type requirements

   None, except for those imposed by the requirements of
   |stl-RandomAccessContainer|.

  Public base classes

   None.

  Members

+-----------------------------------------------------------------------------------------------------------------------------+
|                             Member                              |        Where defined        |         Description         |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|value_type                                                       ||stl-Container|              |The rope's value type T,     |
|                                                                 |                             |usually char or wchar_t.     |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|difference_type                                                  ||stl-Container|              |A signed integral type.      |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type                                                        ||stl-Container|              |An unsigned integral type.   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|reference                                                        ||stl-Container|              |Reference to a rope element. |
|                                                                 |                             |[7][3]                       |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|const_reference                                                  ||stl-Container|              |Const reference to T. [8][3] |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|pointer                                                          ||stl-Container|              |Pointer to T. [9][3]         |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|const_pointer                                                    ||stl-Container|              |Const pointer to T. [10][3]  |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|const_reverse_iterator                                           ||stl-ReversibleContainer|    |Const iterator used to       |
|                                                                 |                             |iterate backwards through a  |
|                                                                 |                             |rope.                        |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|reverse_iterator                                                 ||stl-ReversibleContainer|    |Mutable iterator used to     |
|                                                                 |                             |iterate backwards through a  |
|                                                                 |                             |rope.                        |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator                                                         ||stl-Container|              |Mutable                      |
|                                                                 |                             ||stl-RandomAccessIterator|   |
|                                                                 |                             |used to iterate through a    |
|                                                                 |                             |rope.                        |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|const_iterator                                                   ||stl-Container|              |Const                        |
|                                                                 |                             ||stl-RandomAccessIterator|   |
|                                                                 |                             |used to iterate through a    |
|                                                                 |                             |rope.                        |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope(const charT* s)                                             |rope.                        |Constructs a rope from a C   |
|                                                                 |                             |string.                      |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope(const charT* s, size_t n)                                   |rope.                        |Constructs a rope from a (not|
|                                                                 |                             |necessarily null-terminated) |
|                                                                 |                             |array of charT.              |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope(const const_iterator& f, const const_iterator& l)           ||stl-Sequence|               |Creates a rope with a copy of|
|                                                                 |                             |a range.                     |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope(const iterator& f, const iterator& l)                       ||stl-Sequence|               |Creates a rope with a copy of|
|                                                                 |                             |a range.                     |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope(const charT* f, const charT* l)                             ||stl-Sequence|               |Creates a rope with a copy of|
|                                                                 |                             |a range.                     |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope(charT c)                                                    |rope.                        |Single-character constructor.|
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope()                                                           ||stl-Container|              |Default constructor.         |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope(|stl-char_producer|<charT>*, size_t, bool)                  |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope(const rope& x)                                              ||stl-Container|              |The copy constructor.        |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|~rope()                                                          ||stl-Container|              |The destructor.              |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope& operator=(const rope&x)                                    ||stl-Container|              |The assignment operator.     |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void swap(rope& x)                                               ||stl-Container|              |Swaps the contents of two    |
|                                                                 |                             |ropes.                       |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type size() const                                           ||stl-Container|              |Returns the size of the rope.|
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type length() const                                         |rope                         |Same as size                 |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type max_size() const                                       ||stl-Container|              |Size of longest rope         |
|                                                                 |                             |guaranteed to be             |
|                                                                 |                             |representable.               |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|bool empty() const                                               ||stl-Container|              |Equivalent to size() == 0.   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|const_iterator begin() const                                     ||stl-Container|              |Returns an const_iterator    |
|                                                                 |                             |pointing to the beginning of |
|                                                                 |                             |the rope.                    |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|const_iterator end() const                                       ||stl-Container|              |Returns an const_iterator    |
|                                                                 |                             |pointing to the end of the   |
|                                                                 |                             |rope.                        |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator mutable_begin()                                         |rope                         |Returns an iterator pointing |
|                                                                 |                             |to the beginning of the rope.|
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator mutable_end()                                           |rope                         |Returns an iterator pointing |
|                                                                 |                             |to the end of the rope.      |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|const_reverse_iterator rbegin() const                            ||stl-ReversibleContainer|    |Returns a                    |
|                                                                 |                             |const_reverse_iterator       |
|                                                                 |                             |pointing to the beginning of |
|                                                                 |                             |the reversed rope            |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|const_reverse_iterator rend() const                              ||stl-ReversibleContainer|    |Returns a                    |
|                                                                 |                             |const_reverse_iterator       |
|                                                                 |                             |pointing to the end of the   |
|                                                                 |                             |reversed rope                |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator mutable_rbegin()                                        |rope                         |Returns a reverse_iterator   |
|                                                                 |                             |pointing to the beginning of |
|                                                                 |                             |the reversed rope.           |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator mutable_rend()                                          |rope                         |Returns a reverse_iterator   |
|                                                                 |                             |pointing to the end of the   |
|                                                                 |                             |reversed rope.               |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|charT operator[](size_type n) const                              ||stl-RandomAccessContainer|  |Returns the n'th element.    |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|charT at(size_type pos) const                                    ||stl-RandomAccessContainer|  |Returns the n'th element.    |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|reference mutable_reference_at(size_type n)                      |rope                         |Returns a reference to the   |
|                                                                 |                             |nth element.                 |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|int compare(const rope&) const                                   |rope.                        |Three-way comparison. See    |
|                                                                 |                             |below.                       |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|charT front() const                                              ||stl-Sequence|               |Returns the first element.   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|charT back() const                                               ||stl-BackInsertionSequence|  |Returns the last element.    |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void push_front()                                                ||stl-FrontInsertionSequence| |Inserts a new element at the |
|                                                                 |                             |front.                       |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void push_back(charT)                                            ||stl-BackInsertionSequence|  |Inserts a new element at the |
|                                                                 |                             |end.                         |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void pop_front()                                                 ||stl-FrontInsertionSequence| |Removes the first element.   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void pop_back()                                                  ||stl-BackInsertionSequence|  |Removes the last element.    |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator insert(const iterator& p, const rope& x)                |rope                         |Inserts the contents of x    |
|                                                                 |                             |before p.                    |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator insert(const iterator& p, charT c)                      ||stl-Sequence|               |Inserts c before p.          |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator insert(const iterator& p)                               ||stl-Sequence|               |Inserts charT() before p.    |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator insert(const iterator& p, size_t n, charT c)            ||stl-Sequence|               |Inserts n copies of c before |
|                                                                 |                             |p.                           |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator insert(const iterator& p, const charT* s)               |rope                         |Inserts a C string before p. |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator insert(const iterator& p, const charT* s, size_t n)     |rope                         |Inserts a (not necessarily   |
|                                                                 |                             |null-terminated) array of    |
|                                                                 |                             |charT before p.              |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator insert(const iterator& p, const charT* f, const char* l)||stl-Sequence|               |Inserts the range [f, l)     |
|                                                                 |                             |before p.                    |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator insert(const iterator& p,                               ||stl-Sequence|               |Inserts the range [f, l)     |
|                const const_iterator& f, const const_iterator& l)|                             |before p.                    |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|iterator insert(const iterator& p,                               ||stl-Sequence|               |Inserts the range [f, l)     |
|                const iterator& f, const iterator& l)            |                             |before p.                    |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void insert(size_t i, const rope& x)                             |rope                         |Inserts the contents of x    |
|                                                                 |                             |before the ith element.      |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void insert(size_t i, charT c)                                   |rope                         |Inserts the character c      |
|                                                                 |                             |before the ith element.      |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void insert(size_t i)                                            |rope                         |Inserts the character charT()|
|                                                                 |                             |before the ith element.      |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void insert(size_t i, size_t n, charT c)                         |rope                         |Inserts n copies of c before |
|                                                                 |                             |the ith element.             |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void insert(size_t i, const charT* s)                            |rope                         |Inserts a C string before the|
|                                                                 |                             |ith element.                 |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void insert(size_t i, const charT* s, size_t n)                  |rope                         |Inserts a (not necessarily   |
|                                                                 |                             |null-terminated) array of    |
|                                                                 |                             |charT before the ith element.|
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void insert(size_t i, const charT* f, const charT* l)            |rope                         |Inserts the range [f, l)     |
|                                                                 |                             |before the ith element.      |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void insert(size_t i,                                            |rope                         |Inserts the range [f, l)     |
|            const const_iterator& f, const const_iterator& l)    |                             |before the ith element.      |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void insert(size_t i,                                            |rope                         |Inserts the range [f, l)     |
|            const iterator& f, const iterator& l)                |                             |before the ith element.      |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void erase(const iterator& p)                                    ||stl-Sequence|               |Erases the element pointed to|
|                                                                 |                             |by p.                        |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void erase(const iterator& f, const iterator& l)                 ||stl-Sequence|               |Erases the range [f, l).     |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void erase(size_t i, size_t n)                                   |rope                         |Erases n elements, starting  |
|                                                                 |                             |with the ith element.        |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|append(const charT* s)                                           |rope                         |Appends a C string.          |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|append(const charT* s, size_t)                                   |rope                         |Appends a (not necessarily   |
|                                                                 |                             |null-terminated) array of    |
|                                                                 |                             |charT.                       |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|append(const charT* f, const charT* l)                           |rope                         |Appends a range.             |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|append(charT c)                                                  |rope                         |Appends the character c.     |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|append()                                                         |rope                         |Appends the character        |
|                                                                 |                             |charT().                     |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|append(size_t n, charT c)                                        |rope                         |Appends n copies of c.       |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|append(const rope& x)                                            |rope                         |Appends the rope x.          |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(const iterator& f, const iterator& l, const rope&)  |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(const iterator& f, const iterator& l, charT)        |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(const iterator& f, const iterator& l, const charT*  |rope                         |See below.                   |
|s)                                                               |                             |                             |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(const iterator& f, const iterator& l,               |rope                         |See below.                   |
|             const charT* s, size_t n)                           |                             |                             |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(const iterator& f1, const iterator& l1,             |rope                         |See below.                   |
|             const charT* f2, const charT* l2)                   |                             |                             |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(const iterator& f1, const iterator& l1,             |rope                         |See below.                   |
|             const const_iterator& f2, const const_iterator& l2) |                             |                             |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(const iterator& f1, const iterator& l1,             |rope                         |See below.                   |
|             const iterator& f2, const iterator& l2)             |                             |                             |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(const iterator& p, const rope& x)                   |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(const iterator& p, charT c)                         |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(const iterator& p, const charT* s)                  |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(const iterator& p, const charT* s, size_t n)        |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(const iterator& p,                                  |rope                         |See below.                   |
|             const charT* f, const charT* l)                     |                             |                             |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(const iterator& p,                                  |rope                         |See below.                   |
|             const_iterator f, const_iterator l)                 |                             |                             |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(const iterator& p,                                  |rope                         |See below.                   |
|             iterator f, iterator l)                             |                             |                             |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(size_t i, size_t n, const rope& x)                  |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(size_t i, size_t n, const charT* s, size_t n)       |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(size_t i, size_t n, charT c)                        |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(size_t i, size_t n, const charT* s)                 |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(size_t i, size_t n,                                 |rope                         |See below.                   |
|             const charT* f, const charT* l)                     |                             |                             |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(size_t i, size_t n,                                 |rope                         |See below.                   |
|             const const_iterator& f,                            |                             |                             |
|             const const_iterator& l)                            |                             |                             |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(size_t i, size_t n,                                 |rope                         |See below.                   |
|             const iterator& f,                                  |                             |                             |
|             const iterator& l)                                  |                             |                             |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(size_t i, charT c)                                  |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(size_t i, const rope& x)                            |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(size_t i, const charT* s)                           |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(size_t i, const charT* s, size_t n)                 |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(size_t i, const charT* f, const charT* l)           |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(size_t i,                                           |rope                         |See below.                   |
|             const const_iterator& f, const const_iterator& l)   |                             |                             |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void replace(size_t i,                                           |rope                         |See below.                   |
|             const iterator& f, const iterator& l)               |                             |                             |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope substr(iterator f) const                                    |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope substr(const_iterator f) const                              |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope substr(iterator f, iterator l) const                        |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope substr(const_iterator f, const_iterator l) const            |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope substr(size_t i, size_t n = 1) const                        |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void copy(charT* buf) const                                      |rope                         |Copies a rope into an array  |
|                                                                 |                             |of charT.                    |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|size_type copy(size_type pos, size_type n,                       |rope                         |Copies a rope into an array  |
|               charT* buf)                                       |                             |of charT.                    |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|const charT* c_str() const                                       |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|void delete_c_str()                                              |rope                         |See below.                   |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope operator+(const rope& L, const rope&R)                      |rope                         |Concatenates L and R. This is|
|                                                                 |                             |a global function, not a     |
|                                                                 |                             |member function.             |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope& operator+=(rope& L, const rope& R)                         |rope                         |Appends R to L. This is a    |
|                                                                 |                             |global function, not a member|
|                                                                 |                             |function.                    |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope operator+(const rope& L, const charT* s)                    |rope                         |Concatenates L and s. This is|
|                                                                 |                             |a global function, not a     |
|                                                                 |                             |member function.             |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope& operator+=(rope& L, const charT* s)                        |rope                         |Appends s to L. This is a    |
|                                                                 |                             |global function, not a member|
|                                                                 |                             |function.                    |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope operator+(const rope& L, charT c)                           |rope                         |Concatenates L and c. This is|
|                                                                 |                             |a global function, not a     |
|                                                                 |                             |member function.             |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|rope& operator+=(rope& L, charT c)                               |rope                         |Appends c to L. This is a    |
|                                                                 |                             |global function, not a member|
|                                                                 |                             |function.                    |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|bool operator<(const rope&, const rope&)                         ||stl-ForwardContainer|       |Lexicographical comparison.  |
|                                                                 |                             |This is a global function,   |
|                                                                 |                             |not a member function.       |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|bool operator==(const rope&, const rope*)                        ||stl-ForwardContainer|       |Tests two ropes for equality.|
|                                                                 |                             |This is a global function,   |
|                                                                 |                             |not a member function.       |
|-----------------------------------------------------------------+-----------------------------+-----------------------------|
|ostream& operator<<(ostream& os, rope x)                         |rope                         |Outputs x to the stream os.  |
|                                                                 |                             |This is a global function,   |
|                                                                 |                             |not a member function.       |
+-----------------------------------------------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-RandomAccessContainer|
   requirements, but are specific to rope:

+------------------------------------------------------------------------------------+
|                            Function                            |    Description    |
|----------------------------------------------------------------+-------------------|
|rope(const charT* s)                                            |Constructs a rope  |
|                                                                |from a C string.   |
|                                                                |The rope consists  |
|                                                                |of the sequence of |
|                                                                |characters starting|
|                                                                |with *s up to, but |
|                                                                |not including, the |
|                                                                |first null         |
|                                                                |character.         |
|----------------------------------------------------------------+-------------------|
|rope(const charT* s, size_t n)                                  |Constructs a rope  |
|                                                                |from an array of   |
|                                                                |charT. The rope    |
|                                                                |consists of the    |
|                                                                |characters in the  |
|                                                                |range [s, s + n).  |
|                                                                |Note that this     |
|                                                                |range is permitted |
|                                                                |to contain embedded|
|                                                                |null characters.   |
|----------------------------------------------------------------+-------------------|
|rope(charT c)                                                   |Constructs a rope  |
|                                                                |consisting of the  |
|                                                                |single character c.|
|----------------------------------------------------------------+-------------------|
|rope(|stl-char_producer|<charT>* cp, size_t n, bool destroy)    |Constructs a rope  |
|                                                                |of size n, whose   |
|                                                                |characters are     |
|                                                                |computed as needed |
|                                                                |by cp. The object  |
|                                                                |*cp must be valid  |
|                                                                |as long as any     |
|                                                                |reference to the   |
|                                                                |resulting rope, or |
|                                                                |a rope derived from|
|                                                                |it, may be used. If|
|                                                                |destroy is true,   |
|                                                                |then delete cp will|
|                                                                |be executed        |
|                                                                |automatically once |
|                                                                |cp is no longer    |
|                                                                |needed. Typically  |
|                                                                |destroy will be    |
|                                                                |true unless cp is a|
|                                                                |pointer to         |
|                                                                |statically         |
|                                                                |allocated storage. |
|                                                                |It is rarely safe  |
|                                                                |to allocate *cp on |
|                                                                |the stack.         |
|----------------------------------------------------------------+-------------------|
|size_type length() const                                        |Synonym for size   |
|----------------------------------------------------------------+-------------------|
|iterator mutable_begin()                                        |Returns an iterator|
|                                                                |pointing to the    |
|                                                                |beginning of the   |
|                                                                |rope. This member  |
|                                                                |function exists    |
|                                                                |because mutable    |
|                                                                |rope iterators are |
|                                                                |much more expensive|
|                                                                |than constant rope |
|                                                                |iterators.         |
|----------------------------------------------------------------+-------------------|
|iterator mutable_end()                                          |Returns an iterator|
|                                                                |pointing to the end|
|                                                                |of the rope. This  |
|                                                                |member function    |
|                                                                |exists because     |
|                                                                |mutable rope       |
|                                                                |iterators are much |
|                                                                |more expensive than|
|                                                                |constant rope      |
|                                                                |iterators.         |
|----------------------------------------------------------------+-------------------|
|iterator mutable_rbegin()                                       |Returns a          |
|                                                                |reverse_iterator   |
|                                                                |pointing to the    |
|                                                                |beginning of the   |
|                                                                |reversed rope. This|
|                                                                |member function    |
|                                                                |exists because     |
|                                                                |mutable rope       |
|                                                                |iterators are much |
|                                                                |more expensive than|
|                                                                |constant rope      |
|                                                                |iterators.         |
|----------------------------------------------------------------+-------------------|
|iterator mutable_rend()                                         |Returns a          |
|                                                                |reverse_iterator   |
|                                                                |pointing to the end|
|                                                                |of the reversed    |
|                                                                |rope. This member  |
|                                                                |function exists    |
|                                                                |because mutable    |
|                                                                |rope iterators are |
|                                                                |much more expensive|
|                                                                |than constant rope |
|                                                                |iterators.         |
|----------------------------------------------------------------+-------------------|
|reference mutable_reference_at(size_type n)                     |Returns a reference|
|                                                                |to the nth element.|
|                                                                |This member        |
|                                                                |function exists    |
|                                                                |because mutable    |
|                                                                |references to rope |
|                                                                |elements have      |
|                                                                |fairly high        |
|                                                                |overhead.          |
|----------------------------------------------------------------+-------------------|
|int compare(const rope& x)                                      |Three-way          |
|                                                                |comparison, much   |
|                                                                |like the function  |
|                                                                |strcmp from the    |
|                                                                |standard C library.|
|                                                                |Returns a negative |
|                                                                |number if *this is |
|                                                                |lexicographically  |
|                                                                |less than x, a     |
|                                                                |positive number if |
|                                                                |*this is           |
|                                                                |lexicographically  |
|                                                                |greater than x, and|
|                                                                |zero if neither    |
|                                                                |rope is            |
|                                                                |lexicographically  |
|                                                                |less than the      |
|                                                                |other.             |
|----------------------------------------------------------------+-------------------|
|iterator insert(const iterator& p, const rope& x)               |Inserts the        |
|                                                                |contents of the    |
|                                                                |rope x immediately |
|                                                                |before the position|
|                                                                |p.                 |
|----------------------------------------------------------------+-------------------|
|iterator insert(const iterator& p, const charT* s)              |Inserts a C string |
|                                                                |immediately before |
|                                                                |the position p. The|
|                                                                |elements that are  |
|                                                                |inserted are the   |
|                                                                |sequence of        |
|                                                                |characters starting|
|                                                                |with *s and up to, |
|                                                                |but not including, |
|                                                                |the first null     |
|                                                                |character.         |
|----------------------------------------------------------------+-------------------|
|iterator insert(const iterator& p, const charT* s, size_t n)    |Inserts an array of|
|                                                                |charT. The elements|
|                                                                |that are inserted  |
|                                                                |are the range [s, s|
|                                                                |+ n). Note that    |
|                                                                |this range is      |
|                                                                |permitted to       |
|                                                                |contain embedded   |
|                                                                |null characters.   |
|----------------------------------------------------------------+-------------------|
|void insert(size_t i, const rope& x)                            |Inserts the        |
|                                                                |contents of the    |
|                                                                |rope x immediately |
|                                                                |before the ith     |
|                                                                |element.           |
|----------------------------------------------------------------+-------------------|
|void insert(size_t i, size_t n, charT c)                        |Inserts n copies of|
|                                                                |c immediately      |
|                                                                |before the ith     |
|                                                                |element.           |
|----------------------------------------------------------------+-------------------|
|void insert(size_t i, const charT* s)                           |Inserts a C string |
|                                                                |immediately before |
|                                                                |the ith element.   |
|                                                                |The elements that  |
|                                                                |are inserted are   |
|                                                                |the sequence of    |
|                                                                |characters starting|
|                                                                |with *s and up to, |
|                                                                |but not including, |
|                                                                |the first null     |
|                                                                |character.         |
|----------------------------------------------------------------+-------------------|
|void insert(size_t i, const charT* s, size_t n)                 |Inserts an array of|
|                                                                |charT immediately  |
|                                                                |before the ith     |
|                                                                |element. The       |
|                                                                |elements that are  |
|                                                                |inserted are the   |
|                                                                |range [s, s + n).  |
|                                                                |Note that this     |
|                                                                |range is permitted |
|                                                                |to contain embedded|
|                                                                |null characters.   |
|----------------------------------------------------------------+-------------------|
|void insert(size_t i, charT c)                                  |Inserts the        |
|                                                                |character c        |
|                                                                |immediately before |
|                                                                |the ith element.   |
|----------------------------------------------------------------+-------------------|
|void insert(size_t i)                                           |Inserts the        |
|                                                                |character charT()  |
|                                                                |immediately before |
|                                                                |the ith element.   |
|----------------------------------------------------------------+-------------------|
|void insert(size_t i, const charT* f, const charT* l)           |Inserts the range  |
|                                                                |[f, l) immediately |
|                                                                |before the ith     |
|                                                                |element.           |
|----------------------------------------------------------------+-------------------|
|void insert(size_t i,                                           |Inserts the range  |
|            const const_iterator& f, const const_iterator& l)   |[f, l) immediately |
|                                                                |before the ith     |
|                                                                |element.           |
|----------------------------------------------------------------+-------------------|
|void insert(size_t i,                                           |Inserts the range  |
|            const iterator& f, const iterator& l)               |[f, l) immediately |
|                                                                |before the ith     |
|                                                                |element.           |
|----------------------------------------------------------------+-------------------|
|void erase(size_t i, size_t n)                                  |Erases n elements, |
|                                                                |starting with the  |
|                                                                |ith element.       |
|----------------------------------------------------------------+-------------------|
|append(const charT* s)                                          |Adds a C string to |
|                                                                |the end of the     |
|                                                                |rope. The elements |
|                                                                |that are inserted  |
|                                                                |are the sequence of|
|                                                                |characters starting|
|                                                                |with *s and up to, |
|                                                                |but not including, |
|                                                                |the first null     |
|                                                                |character.         |
|----------------------------------------------------------------+-------------------|
|append(const charT* s, size_ nt)                                |Adds an array of   |
|                                                                |charT to the end of|
|                                                                |the rope. The      |
|                                                                |elements that are  |
|                                                                |inserted are the   |
|                                                                |range [s, s + n).  |
|                                                                |Note that this     |
|                                                                |range is permitted |
|                                                                |to contain embedded|
|                                                                |null characters.   |
|----------------------------------------------------------------+-------------------|
|append(const charT* f, const charT* l)                          |Adds the elements  |
|                                                                |in the range [f, l)|
|                                                                |to the end of the  |
|                                                                |rope.              |
|----------------------------------------------------------------+-------------------|
|append(charT c)                                                 |Adds the character |
|                                                                |c to the end of the|
|                                                                |rope.              |
|----------------------------------------------------------------+-------------------|
|append()                                                        |Adds the character |
|                                                                |charT() to the end |
|                                                                |of the rope.       |
|----------------------------------------------------------------+-------------------|
|append(const rope& x)                                           |Adds the contents  |
|                                                                |of the rope x to   |
|                                                                |the end of *this.  |
|----------------------------------------------------------------+-------------------|
|append(size_t n, charT c)                                       |Adds n copies of c |
|                                                                |to the end of      |
|                                                                |*this.             |
|----------------------------------------------------------------+-------------------|
|void replace(const iterator& f, const iterator& l, const rope&  |Replaces the       |
|x)                                                              |elements in the    |
|                                                                |range [f, l) with  |
|                                                                |the elements in x. |
|----------------------------------------------------------------+-------------------|
|void replace(const iterator& f, const iterator& l, charT c)     |Replaces the       |
|                                                                |elements in the    |
|                                                                |range [f, l) with  |
|                                                                |the single         |
|                                                                |character c.       |
|----------------------------------------------------------------+-------------------|
|void replace(const iterator& f, const iterator& l, const charT* |Replaces the       |
|s)                                                              |elements in the    |
|                                                                |range [f, l) with a|
|                                                                |C string: the      |
|                                                                |sequence of        |
|                                                                |characters         |
|                                                                |beginning with *s  |
|                                                                |and up to, but not |
|                                                                |including, the     |
|                                                                |first null         |
|                                                                |character.         |
|----------------------------------------------------------------+-------------------|
|void replace(const iterator& f, const iterator& l,              |Replaces the       |
|             const charT* s, size_t n)                          |elements in the    |
|                                                                |range [f, l) with  |
|                                                                |the elements in the|
|                                                                |range [s, s + n).  |
|----------------------------------------------------------------+-------------------|
|void replace(const iterator& f1, const iterator& l1,            |Replaces the       |
|             const charT* f2, const charT* l2)                  |elements in the    |
|                                                                |range [f1, l1) with|
|                                                                |the elements in the|
|                                                                |range [f2, l2).    |
|----------------------------------------------------------------+-------------------|
|void replace(const iterator& f1, const iterator& l1,            |Replaces the       |
|             const const_iterator& f2, const const_iterator& l2)|elements in the    |
|                                                                |range [f1, l1) with|
|                                                                |the elements in the|
|                                                                |range [f2, l2).    |
|----------------------------------------------------------------+-------------------|
|void replace(const iterator& f1, const iterator& l1,            |Replaces the       |
|             const iterator& f2, const iterator& l2)            |elements in the    |
|                                                                |range [f1, l1) with|
|                                                                |the elements in the|
|                                                                |range [f2, l2).    |
|----------------------------------------------------------------+-------------------|
|void replace(const iterator& p, const rope& x)                  |Replaces the       |
|                                                                |element pointed to |
|                                                                |by p with the      |
|                                                                |elements in x.     |
|----------------------------------------------------------------+-------------------|
|void replace(const iterator& p, charT c)                        |Replaces the       |
|                                                                |element pointed to |
|                                                                |by p with the      |
|                                                                |single character c.|
|----------------------------------------------------------------+-------------------|
|void replace(const iterator& p, const charT* s)                 |Replaces the       |
|                                                                |element pointed to |
|                                                                |by p with a C      |
|                                                                |string: the        |
|                                                                |sequence of        |
|                                                                |characters         |
|                                                                |beginning with *s  |
|                                                                |and up to, but not |
|                                                                |including, the     |
|                                                                |first null         |
|                                                                |character.         |
|----------------------------------------------------------------+-------------------|
|void replace(const iterator& p, const charT* s, size_t n)       |Replaces the       |
|                                                                |element pointed to |
|                                                                |by p with the      |
|                                                                |elements in the    |
|                                                                |range [s, s + n).  |
|----------------------------------------------------------------+-------------------|
|void replace(const iterator& p,                                 |Replaces the       |
|             const charT* f, const charT* l)                    |element pointed to |
|                                                                |by p with the      |
|                                                                |elements in the    |
|                                                                |range [f, l).      |
|----------------------------------------------------------------+-------------------|
|void replace(const iterator& p,                                 |Replaces the       |
|             const_iterator f, const_iterator l)                |element pointed to |
|                                                                |by p with the      |
|                                                                |elements in the    |
|                                                                |range [f, l).      |
|----------------------------------------------------------------+-------------------|
|void replace(const iterator& p,                                 |Replaces the       |
|             iterator f, iterator l)                            |element pointed to |
|                                                                |by p with the      |
|                                                                |elements in the    |
|                                                                |range [f, l).      |
|----------------------------------------------------------------+-------------------|
|void replace(size_t i, size_t n, const rope& x)                 |Replaces the n     |
|                                                                |elements beginning |
|                                                                |with the ith       |
|                                                                |element with the   |
|                                                                |elements in x.     |
|----------------------------------------------------------------+-------------------|
|void replace(size_t i, size_t n, charT c)                       |Replaces the n     |
|                                                                |elements beginning |
|                                                                |with the ith       |
|                                                                |element with the   |
|                                                                |single character c.|
|----------------------------------------------------------------+-------------------|
|void replace(size_t i, size_t n, const charT* s)                |Replaces the n     |
|                                                                |elements beginning |
|                                                                |with the ith       |
|                                                                |element with an    |
|                                                                |array of charT: the|
|                                                                |sequence of        |
|                                                                |characters         |
|                                                                |beginning with *s  |
|                                                                |and up to, but not |
|                                                                |including, the     |
|                                                                |first null         |
|                                                                |character.         |
|----------------------------------------------------------------+-------------------|
|void replace(size_t i, size_t n1, const charT* s, size_t n2)    |Replaces the n1    |
|                                                                |elements beginning |
|                                                                |with the ith       |
|                                                                |element with the   |
|                                                                |elements in the    |
|                                                                |range [s, s + n2). |
|----------------------------------------------------------------+-------------------|
|void replace(size_t i, size_t n,                                |Replaces the n     |
|             const charT* f, const charT* l)                    |elements beginning |
|                                                                |with the ith       |
|                                                                |element with the   |
|                                                                |characters in the  |
|                                                                |range [f, l).      |
|----------------------------------------------------------------+-------------------|
|void replace(size_t i, size_t n,                                |Replaces the n     |
|             const const_iterator& f,                           |elements beginning |
|             const const_iterator& l)                           |with the ith       |
|                                                                |element with the   |
|                                                                |characters in the  |
|                                                                |range [f, l).      |
|----------------------------------------------------------------+-------------------|
|void replace(size_t i, size_t n,                                |Replaces the n     |
|             const iterator& f,                                 |elements beginning |
|             const iterator& l)                                 |with the ith       |
|                                                                |element with the   |
|                                                                |characters in the  |
|                                                                |range [f, l).      |
|----------------------------------------------------------------+-------------------|
|void replace(size_t i, charT c)                                 |Replaces the ith   |
|                                                                |element with the   |
|                                                                |character c.       |
|----------------------------------------------------------------+-------------------|
|void replace(size_t i, const rope& x)                           |Replaces the ith   |
|                                                                |element with       |
|                                                                |elements from the  |
|                                                                |rope x.            |
|----------------------------------------------------------------+-------------------|
|void replace(size_t i, const charT* s)                          |Replaces the ith   |
|                                                                |element with a C   |
|                                                                |string: the        |
|                                                                |sequence of        |
|                                                                |characters         |
|                                                                |beginning with *s  |
|                                                                |and up to, but not |
|                                                                |including, the     |
|                                                                |first null         |
|                                                                |character.         |
|----------------------------------------------------------------+-------------------|
|void replace(size_t i, const charT* s, size_t n)                |Replaces the ith   |
|                                                                |element with the   |
|                                                                |elements in the    |
|                                                                |range [s, s + n).  |
|----------------------------------------------------------------+-------------------|
|void replace(size_t i, const charT* f, const charT* l)          |Replaces the ith   |
|                                                                |element with the   |
|                                                                |range [f, l).      |
|----------------------------------------------------------------+-------------------|
|void replace(size_t i,                                          |Replaces the ith   |
|             const const_iterator& f, const const_iterator& l)  |element with the   |
|                                                                |range [f, l).      |
|----------------------------------------------------------------+-------------------|
|void replace(size_t i,                                          |Replaces the ith   |
|             const iterator& f, const iterator& l)              |element with the   |
|                                                                |range [f, l).      |
|----------------------------------------------------------------+-------------------|
|rope substr(iterator f) const                                   |Returns a new rope |
|                                                                |with a single      |
|                                                                |element, *f.       |
|                                                                |[11][4]            |
|----------------------------------------------------------------+-------------------|
|rope substr(const_iterator f) const                             |Returns a new rope |
|                                                                |with a single      |
|                                                                |element, *f.       |
|                                                                |[12][4]            |
|----------------------------------------------------------------+-------------------|
|rope substr(iterator f, iterator l) const                       |Returns a new rope |
|                                                                |that consists of   |
|                                                                |the range [f, l).  |
|                                                                |[13][4]            |
|----------------------------------------------------------------+-------------------|
|rope substr(const_iterator f, const_iterator l) const           |Returns a new rope |
|                                                                |that consists of   |
|                                                                |the range [f, l).  |
|                                                                |[14][4]            |
|----------------------------------------------------------------+-------------------|
|rope substr(size_t i, size_t n = 1) const                       |Returns a new rope |
|                                                                |whose elements are |
|                                                                |the n characters   |
|                                                                |starting at the    |
|                                                                |position i.        |
|                                                                |[15][4].           |
|----------------------------------------------------------------+-------------------|
|void copy(charT* buf) const                                     |Copies the         |
|                                                                |characters in a    |
|                                                                |rope into buf.     |
|----------------------------------------------------------------+-------------------|
|size_type copy(size_type pos, size_type n,                      |Copies n           |
|               charT* buf)                                      |characters,        |
|                                                                |starting at        |
|                                                                |position pos in the|
|                                                                |rope, into buf. If |
|                                                                |the rope contains  |
|                                                                |fewer than pos + n |
|                                                                |characters, then   |
|                                                                |instead it only    |
|                                                                |copies size() - pos|
|                                                                |characters.        |
|----------------------------------------------------------------+-------------------|
|const charT* c_str() const                                      |Returns a pointer  |
|                                                                |to a               |
|                                                                |null-terminated    |
|                                                                |sequence of        |
|                                                                |characters that    |
|                                                                |contains all of the|
|                                                                |characters in a    |
|                                                                |rope. [16][5]      |
|                                                                |[17][6] The        |
|                                                                |resulting sequence |
|                                                                |of characters is   |
|                                                                |valid at least as  |
|                                                                |long as the rope   |
|                                                                |remains valid and  |
|                                                                |unchanged. Note    |
|                                                                |that the first     |
|                                                                |invocation of this |
|                                                                |operation on long  |
|                                                                |strings is slow: it|
|                                                                |is linear in the   |
|                                                                |length of the rope.|
|----------------------------------------------------------------+-------------------|
|void delete_c_str()                                             |Reclaims the       |
|                                                                |internal storage   |
|                                                                |used by c_str. Note|
|                                                                |that this          |
|                                                                |invalidates the    |
|                                                                |pointer that c_str |
|                                                                |returns.           |
|----------------------------------------------------------------+-------------------|
|rope operator+(const rope& L, const rope& R)                    |Returns a new rope |
|                                                                |consisting of the  |
|                                                                |concatenation of L |
|                                                                |and R. This is a   |
|                                                                |global function,   |
|                                                                |not a member       |
|                                                                |function.          |
|----------------------------------------------------------------+-------------------|
|rope& operator+=(rope& L, const rope& R)                        |Modifies L by      |
|                                                                |appending R, and   |
|                                                                |returns L. This is |
|                                                                |a global function, |
|                                                                |not a member       |
|                                                                |function.          |
|----------------------------------------------------------------+-------------------|
|rope operator+(const rope& L, const charT* s)                   |Returns a new rope |
|                                                                |consisting of the  |
|                                                                |concatenation of L |
|                                                                |and all of the     |
|                                                                |characters from s  |
|                                                                |up to, but not     |
|                                                                |including, the     |
|                                                                |first null         |
|                                                                |character. This is |
|                                                                |a global function, |
|                                                                |not a member       |
|                                                                |function.          |
|----------------------------------------------------------------+-------------------|
|rope& operator+=(rope& L, const charT* s)                       |Modifies L by      |
|                                                                |appending the      |
|                                                                |characters from s  |
|                                                                |up to, but not     |
|                                                                |including, the     |
|                                                                |first null         |
|                                                                |character. The     |
|                                                                |return value is L. |
|                                                                |This is a global   |
|                                                                |function, not a    |
|                                                                |member function.   |
|----------------------------------------------------------------+-------------------|
|rope operator+(const rope& L, charT c)                          |Returns a new rope |
|                                                                |consisting of L    |
|                                                                |with the character |
|                                                                |c appended to it.  |
|                                                                |This is a global   |
|                                                                |function, not a    |
|                                                                |member function.   |
|----------------------------------------------------------------+-------------------|
|rope& operator+=(rope& L, charT c)                              |Modifies L by      |
|                                                                |appending the      |
|                                                                |character c. This  |
|                                                                |is a global        |
|                                                                |function, not a    |
|                                                                |member function.   |
|----------------------------------------------------------------+-------------------|
|ostream& operator<<(ostream& os, rope x)                        |Outputs x to the   |
|                                                                |stream os. This is |
|                                                                |a global function, |
|                                                                |not a member       |
|                                                                |function.          |
+------------------------------------------------------------------------------------+

  Notes

   [1] For a detailed discussion of the rope data structure, see H.-J. Boehm,
   R. Atkinson, and M. Plass, "Ropes: An Alternative to Strings", Software
   Practice and Experience 25(12):1315, 1995.

   [2] Since the value type is usually either char or wchar_t, the library
   introduces two abbreviations: crope is a typedef for rope<char>, and wrope
   is a typedef for rope<wchar_t>.

   [3] Rope::reference is not value_type&, but a proxy type. In fact,
   reference is a typedef for the nested class charT_ref_proxy.
   Const_reference, however, is simply const value_type&. Similarly,
   const_pointer is just const value_type* but pointer is a proxy type. If r
   is an object of type reference, then &r is of type pointer.

   [4] Note that the return value of substr is conceptually a distinct rope:
   the two ropes may share storage, but this is a hidden implementation
   detail. If you modify a rope returned by substr, this will not change the
   value of the original rope.

   [5] The final const qualifier in the member function c_str() is
   conceptually slightly inaccurate in the interest of conformance to the
   basic_string interface in the draft C++ standard; the rope is updated to
   cache the converted string.

   [6] Concurrent calls to c_str() are allowed; the cache is updated
   atomically.

  See also

   |stl-RandomAccessContainer|, |stl-Sequence|, |stl-Vector|,
   |stl-sequence_buffer|


        ________________________________________________________________________
                                  Container adaptors
*stl-stack*

                               stack<T, Sequence>

   Categories: containers, adaptors                      Component type: type

  Description

   A stack is an adaptor that provides a restricted subset of |stl-Container|
   functionality: it provides insertion, removal, and inspection of the
   element at the top of the stack. Stack is a "last in first out" (LIFO)
   data structure: the element at the top of a stack is the one that was most
   recently added. [2][1] Stack does not allow iteration through its
   elements. [3][2]

   Stack is a container adaptor, meaning that it is implemented on top of
   some underlying container type. By default that underlying type is
   |stl-Deque|, but a different type may be selected explicitly.

*stl-stack-example*

 int main() {
   stack<int> S;
   S.push(8);
   S.push(7);
   S.push(4);
   assert(S.size() == 3);

   assert(S.top() == 4);
   S.pop();

   assert(S.top() == 7);
   S.pop();

   assert(S.top() == 8);
   S.pop();

   assert(S.empty());
 }

  Definition

   Defined in the standard header |stl-stack|, and in the nonstandard
   backward-compatibility header |stl-stack|.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                Description                |    Default     |
   |-----------+-------------------------------------------+----------------|
   | T         | The type of object stored in the stack.   |                |
   |-----------+-------------------------------------------+----------------|
   | Sequence  | The type of the underlying container used | |stl-Deque|<T> |
   |           | to implement the stack.                   |                |
   +------------------------------------------------------------------------+

  Model of

   |stl-Assignable|, |stl-DefaultConstructible|

  Type requirements

     * T is a model of |stl-Assignable|.
     * Sequence is a model of |stl-BackInsertionSequence|.
     * Sequence::value_type is the same type as T.
     * If operator== is used, then T is a model of |stl-EqualityComparable|
     * If operator< is used, then T is a model of |stl-LessThanComparable|.

  Public base classes

   None.

  Members

   +------------------------------------------------------------------------+
   |        Member         |       Where defined        |    Description    |
   |-----------------------+----------------------------+-------------------|
   | value_type            | stack                      | See below.        |
   |-----------------------+----------------------------+-------------------|
   | size_type             | stack                      | See below.        |
   |-----------------------+----------------------------+-------------------|
   | stack()               | |stl-DefaultConstructible| | The default       |
   |                       |                            | constructor.      |
   |                       |                            | Creates an empty  |
   |                       |                            | stack.            |
   |-----------------------+----------------------------+-------------------|
   | stack(const stack&)   | |stl-Assignable|           | The copy          |
   |                       |                            | constructor.      |
   |-----------------------+----------------------------+-------------------|
   | stack&                | |stl-Assignable|           | The assignment    |
   | operator=(const       |                            | operator.         |
   | stack&)               |                            |                   |
   |-----------------------+----------------------------+-------------------|
   | bool empty() const    | stack                      | See below.        |
   |-----------------------+----------------------------+-------------------|
   | size_type size()      | stack                      | See below.        |
   | const                 |                            |                   |
   |-----------------------+----------------------------+-------------------|
   | value_type& top()     | stack                      | See below.        |
   |-----------------------+----------------------------+-------------------|
   | const value_type&     | stack                      | See below.        |
   | top() const           |                            |                   |
   |-----------------------+----------------------------+-------------------|
   | void push(const       | stack                      | See below.        |
   | value_type&)          |                            |                   |
   |-----------------------+----------------------------+-------------------|
   | void pop() [6][3]     | stack                      | See below.        |
   |-----------------------+----------------------------+-------------------|
   | bool operator==(const | stack                      | See below.        |
   | stack&, const stack&) |                            |                   |
   |-----------------------+----------------------------+-------------------|
   | bool operator<(const  | stack                      | See below.        |
   | stack&, const stack&) |                            |                   |
   +------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-Assignable| and
   |stl-DefaultConstructible| requirements, but are specific to stack.

   +------------------------------------------------------------------------+
   |         Member          |                 Description                  |
   |-------------------------+----------------------------------------------|
   | value_type              | The type of object stored in the stack. This |
   |                         | is the same as T and Sequence::value_type.   |
   |-------------------------+----------------------------------------------|
   | size_type               | An unsigned integral type. This is the same  |
   |                         | as Sequence::size_type.                      |
   |-------------------------+----------------------------------------------|
   | bool empty() const      | Returns true if the stack contains no        |
   |                         | elements, and false otherwise. S.empty() is  |
   |                         | equivalent to S.size() == 0.                 |
   |-------------------------+----------------------------------------------|
   | size_type size() const  | Returns the number of elements contained in  |
   |                         | the stack.                                   |
   |-------------------------+----------------------------------------------|
   | value_type& top()       | Returns a mutable reference to the element   |
   |                         | at the top of the stack. Precondition:       |
   |                         | empty() is false.                            |
   |-------------------------+----------------------------------------------|
   | const value_type& top() | Returns a const reference to the element at  |
   | const                   | the top of the stack. Precondition: empty()  |
   |                         | is false.                                    |
   |-------------------------+----------------------------------------------|
   | void push(const         | Inserts x at the top of the stack.           |
   | value_type& x)          | Postconditions: size() will be incremented   |
   |                         | by 1, and top() will be equal to x.          |
   |-------------------------+----------------------------------------------|
   | void pop()              | Removes the element at the top of the stack. |
   |                         | [7][3] Precondition: empty() is false.       |
   |                         | Postcondition: size() will be decremented by |
   |                         | 1.                                           |
   |-------------------------+----------------------------------------------|
   | bool operator==(const   | Compares two stacks for equality. Two stacks |
   | stack&, const stack&)   | are equal if they contain the same number of |
   |                         | elements and if they are equal               |
   |                         | element-by-element. This is a global         |
   |                         | function, not a member function.             |
   |-------------------------+----------------------------------------------|
   | bool operator<(const    | Lexicographical ordering of two stacks. This |
   | stack&, const stack&)   | is a global function, not a member function. |
   +------------------------------------------------------------------------+

  Notes

   [1] Stacks are a standard data structure, and are discussed in all
   algorithm books. See, for example, section 2.2.1 of Knuth. (D. E. Knuth,
   The Art of Computer Programming. Volume 1: Fundamental Algorithms, second
   edition. Addison-Wesley, 1973.)

   [2] This restriction is the only reason for stack to exist at all. Note
   that any |stl-FrontInsertionSequence| or |stl-BackInsertionSequence| can
   be used as a stack; in the case of |stl-Vector|, for example, the stack
   operations are the member functions back, push_back, and pop_back. The
   only reason to use the container adaptor stack instead is to make it clear
   that you are performing only stack operations, and no other operations.

   [3] One might wonder why pop() returns void, instead of value_type. That
   is, why must one use top() and pop() to examine and remove the top
   element, instead of combining the two in a single member function? In
   fact, there is a good reason for this design. If pop() returned the top
   element, it would have to return by value rather than by reference: return
   by reference would create a dangling pointer. Return by value, however, is
   inefficient: it involves at least one redundant copy constructor call.
   Since it is impossible for pop() to return a value in such a way as to be
   both efficient and correct, it is more sensible for it to return no value
   at all and to require clients to use top() to inspect the value at the top
   of the stack.

  See also

   |stl-queue|, |stl-priority_queue|, |stl-Container|, |stl-Sequence|

*stl-queue*

                               queue<T, Sequence>

   Categories: containers, adaptors                      Component type: type

  Description

   A queue is an adaptor that provides a restricted subset of |stl-Container|
   functionality A queue is a "first in first out" (FIFO) data structure.
   [2][1] That is, elements are added to the back of the queue and may be
   removed from the front; Q.front() is the element that was added to the
   queue least recently. Queue does not allow iteration through its elements.
   [3][2]

   Queue is a container adaptor, meaning that it is implemented on top of
   some underlying container type. By default that underlying type is
   |stl-Deque|, but a different type may be selected explicitly.

*stl-queue-example*

 int main() {
   queue<int> Q;
   Q.push(8);
   Q.push(7);
   Q.push(6);
   Q.push(2);

   assert(Q.size() == 4);
   assert(Q.back() == 2);

   assert(Q.front() == 8);
   Q.pop();

   assert(Q.front() == 7);
   Q.pop();

   assert(Q.front() == 6);
   Q.pop();

   assert(Q.front() == 2);
   Q.pop();

   assert(Q.empty());
 }

  Definition

   Defined in the standard header |stl-queue|, and in the nonstandard
   backward-compatibility header |stl-stack|.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                Description                |    Default     |
   |-----------+-------------------------------------------+----------------|
   | T         | The type of object stored in the queue.   |                |
   |-----------+-------------------------------------------+----------------|
   | Sequence  | The type of the underlying container used | |stl-Deque|<T> |
   |           | to implement the queue.                   |                |
   +------------------------------------------------------------------------+

  Model of

   |stl-Assignable|, |stl-DefaultConstructible|

  Type requirements

     * T is a model of |stl-Assignable|.
     * Sequence is a model of |stl-FrontInsertionSequence|.
     * Sequence is a model of |stl-BackInsertionSequence|.
     * Sequence::value_type is the same type as T.
     * If operator== is used, then T is a model of |stl-EqualityComparable|
     * If operator< is used, then T is a model of |stl-LessThanComparable|.

  Public base classes

   None.

  Members

   +------------------------------------------------------------------------+
   |        Member         |       Where defined        |    Description    |
   |-----------------------+----------------------------+-------------------|
   | value_type            | queue                      | See below.        |
   |-----------------------+----------------------------+-------------------|
   | size_type             | queue                      | See below.        |
   |-----------------------+----------------------------+-------------------|
   | queue()               | |stl-DefaultConstructible| | The default       |
   |                       |                            | constructor.      |
   |                       |                            | Creates an empty  |
   |                       |                            | queue.            |
   |-----------------------+----------------------------+-------------------|
   | queue(const queue&)   | |stl-Assignable|           | The copy          |
   |                       |                            | constructor.      |
   |-----------------------+----------------------------+-------------------|
   | queue&                | |stl-Assignable|           | The assignment    |
   | operator=(const       |                            | operator.         |
   | queue&)               |                            |                   |
   |-----------------------+----------------------------+-------------------|
   | bool empty() const    | queue                      | See below.        |
   |-----------------------+----------------------------+-------------------|
   | size_type size()      | queue                      | See below.        |
   | const                 |                            |                   |
   |-----------------------+----------------------------+-------------------|
   | value_type& front()   | queue                      | See below.        |
   |-----------------------+----------------------------+-------------------|
   | const value_type&     | queue                      | See below.        |
   | front() const         |                            |                   |
   |-----------------------+----------------------------+-------------------|
   | value_type& back()    | queue                      | See below.        |
   |-----------------------+----------------------------+-------------------|
   | const value_type&     | queue                      | See below.        |
   | back() const          |                            |                   |
   |-----------------------+----------------------------+-------------------|
   | void push(const       | queue                      | See below.        |
   | value_type&)          |                            |                   |
   |-----------------------+----------------------------+-------------------|
   | void pop() [6][3]     | queue                      | See below.        |
   |-----------------------+----------------------------+-------------------|
   | bool operator==(const | queue                      | See below.        |
   | queue&, const queue&) |                            |                   |
   |-----------------------+----------------------------+-------------------|
   | bool operator<(const  | queue                      | See below.        |
   | queue&, const queue&) |                            |                   |
   +------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-Assignable| and
   |stl-DefaultConstructible| requirements, but are specific to queue.

   +------------------------------------------------------------------------+
   |          Member           |                Description                 |
   |---------------------------+--------------------------------------------|
   | value_type                | The type of object stored in the queue.    |
   |                           | This is the same as T and                  |
   |                           | Sequence::value_type.                      |
   |---------------------------+--------------------------------------------|
   | size_type                 | An unsigned integral type. This is the     |
   |                           | same as Sequence::size_type.               |
   |---------------------------+--------------------------------------------|
   | bool empty() const        | Returns true if the queue contains no      |
   |                           | elements, and false otherwise. Q.empty()   |
   |                           | is equivalent to Q.size() == 0.            |
   |---------------------------+--------------------------------------------|
   | size_type size() const    | Returns the number of elements contained   |
   |                           | in the queue.                              |
   |---------------------------+--------------------------------------------|
   | value_type& front()       | Returns a mutable reference to the element |
   |                           | at the front of the queue, that is, the    |
   |                           | element least recently inserted.           |
   |                           | Precondition: empty() is false.            |
   |---------------------------+--------------------------------------------|
   | const value_type& front() | Returns a const reference to the element   |
   | const                     | at the front of the queue, that is, the    |
   |                           | element least recently inserted.           |
   |                           | Precondition: empty() is false.            |
   |---------------------------+--------------------------------------------|
   | value_type& back()        | Returns a mutable reference to the element |
   |                           | at the back of the queue, that is, the     |
   |                           | element most recently inserted.            |
   |                           | Precondition: empty() is false.            |
   |---------------------------+--------------------------------------------|
   | const value_type& back()  | Returns a const reference to the element   |
   | const                     | at the back of the queue, that is, the     |
   |                           | element most recently inserted.            |
   |                           | Precondition: empty() is false.            |
   |---------------------------+--------------------------------------------|
   | void push(const           | Inserts x at the back of the queue.        |
   | value_type& x)            | Postconditions: size() will be incremented |
   |                           | by 1, and back() will be equal to x.       |
   |---------------------------+--------------------------------------------|
   | void pop()                | Removes the element at the front of the    |
   |                           | queue. [7][3] Precondition: empty() is     |
   |                           | false. Postcondition: size() will be       |
   |                           | decremented by 1.                          |
   |---------------------------+--------------------------------------------|
   | bool operator==(const     | Compares two queues for equality. Two      |
   | queue&, const queue&)     | queues are equal if they contain the same  |
   |                           | number of elements and if they are equal   |
   |                           | element-by-element. This is a global       |
   |                           | function, not a member function.           |
   |---------------------------+--------------------------------------------|
   | bool operator<(const      | Lexicographical ordering of two queues.    |
   | queue&, const queue&)     | This is a global function, not a member    |
   |                           | function.                                  |
   +------------------------------------------------------------------------+

  Notes

   [1] Queues are a standard data structure, and are discussed in all
   algorithm books. See, for example, section 2.2.1 of Knuth. (D. E. Knuth,
   The Art of Computer Programming. Volume 1: Fundamental Algorithms, second
   edition. Addison-Wesley, 1973.)

   [2] This restriction is the only reason for queue to exist at all. Any
   container that is both a |stl-FrontInsertionSequence| and a
   |stl-BackInsertionSequence| can be used as a queue; |stl-Deque|, for
   example, has member functions front, back, push_front, push_back,
   pop_front, and pop_back The only reason to use the container adaptor queue
   instead of the container |stl-Deque| is to make it clear that you are
   performing only queue operations, and no other operations.

   [3] One might wonder why pop() returns void, instead of value_type. That
   is, why must one use front() and pop() to examine and remove the element
   at the front of the queue, instead of combining the two in a single member
   function? In fact, there is a good reason for this design. If pop()
   returned the front element, it would have to return by value rather than
   by reference: return by reference would create a dangling pointer. Return
   by value, however, is inefficient: it involves at least one redundant copy
   constructor call. Since it is impossible for pop() to return a value in
   such a way as to be both efficient and correct, it is more sensible for it
   to return no value at all and to require clients to use front() to inspect
   the value at the front of the queue.

  See also

   |stl-stack|, |stl-priority_queue|, |stl-Deque|, |stl-Container|,
   |stl-Sequence|

*stl-priority_queue*

                      priority_queue<T, Sequence, Compare>

   Categories: containers, adaptors                      Component type: type

  Description

   A priority_queue is an adaptor that provides a restricted subset of
   |stl-Container| functionality: it provides insertion of elements, and
   inspection and removal of the top element. It is guaranteed that the top
   element is the largest element in the priority_queue, where the function
   object Compare is used for comparisons. [2][1] Priority_queue does not
   allow iteration through its elements. [3][2]

   Priority_queue is a container adaptor, meaning that it is implemented on
   top of some underlying container type. By default that underlying type is
   |stl-Vector|, but a different type may be selected explicitly.

*stl-priority_queue-example*

 int main() {
   priority_queue<int> Q;
   Q.push(1);
   Q.push(4);
   Q.push(2);
   Q.push(8);
   Q.push(5);
   Q.push(7);

   assert(Q.size() == 6);

   assert(Q.top() == 8);
   Q.pop();

   assert(Q.top() == 7);
   Q.pop();

   assert(Q.top() == 5);
   Q.pop();

   assert(Q.top() == 4);
   Q.pop();

   assert(Q.top() == 2);
   Q.pop();

   assert(Q.top() == 1);
   Q.pop();

   assert(Q.empty());
 }

  Definition

   Defined in the standard header |stl-queue|, and in the nonstandard
   backward-compatibility header |stl-stack|.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |               Description                |     Default     |
   |-----------+------------------------------------------+-----------------|
   | T         | The type of object stored in the         |                 |
   |           | priority queue.                          |                 |
   |-----------+------------------------------------------+-----------------|
   | Sequence  | The type of the underlying container     | |stl-Vector|<T> |
   |           | used to implement the priority queue.    |                 |
   |-----------+------------------------------------------+-----------------|
   | Compare   | The comparison function used to          | |stl-less|<T>   |
   |           | determine whether one element is smaller |                 |
   |           | than another element. If Compare(x,y) is |                 |
   |           | true, then x is smaller than y. The      |                 |
   |           | element returned by Q.top() is the       |                 |
   |           | largest element in the priority queue.   |                 |
   |           | That is, it has the property that, for   |                 |
   |           | every other element x in the priority    |                 |
   |           | queue, Compare(Q.top(), x) is false.     |                 |
   +------------------------------------------------------------------------+

  Model of

   |stl-Assignable|, |stl-DefaultConstructible|

  Type requirements

     * T is a model of |stl-Assignable|.
     * Sequence is a model of |stl-Sequence|.
     * Sequence is a model of |stl-RandomAccessContainer|
     * Sequence::value_type is the same type as T.
     * Compare is a model of |stl-BinaryPredicate|
     * Compare induces a strict weak ordering, as defined in the
       |stl-LessThanComparable| requirements, on its argument type.
     * T is convertible to Compare's argument type.

  Public base classes

   None.

  Members

+---------------------------------------------------------------------------------+
|              Member              |       Where defined       |   Description    |
|----------------------------------+---------------------------+------------------|
|value_type                        |priority_queue             |See below.        |
|----------------------------------+---------------------------+------------------|
|size_type                         |priority_queue             |See below.        |
|----------------------------------+---------------------------+------------------|
|priority_queue()                  ||stl-DefaultConstructible| |The default       |
|                                  |                           |constructor.      |
|                                  |                           |Creates an empty  |
|                                  |                           |priority_queue,   |
|                                  |                           |using Compare() as|
|                                  |                           |the comparison    |
|                                  |                           |function.         |
|----------------------------------+---------------------------+------------------|
|priority_queue(const              ||stl-Assignable|           |The copy          |
|priority_queue&)                  |                           |constructor.      |
|----------------------------------+---------------------------+------------------|
|priority_queue(const Compare&)    |priority_queue             |See below.        |
|----------------------------------+---------------------------+------------------|
|priority_queue(const value_type*, |priority_queue             |See below.        |
|               const value_type*) |                           |                  |
|----------------------------------+---------------------------+------------------|
|priority_queue(const value_type*, |priority_queue             |See below.        |
|               const value_type*, |                           |                  |
|               const Compare&)    |                           |                  |
|----------------------------------+---------------------------+------------------|
|priority_queue&                   ||stl-Assignable|           |The assignment    |
|operator=(const priority_queue&)  |                           |operator.         |
|----------------------------------+---------------------------+------------------|
|bool empty() const                |priority_queue             |See below.        |
|----------------------------------+---------------------------+------------------|
|size_type size() const            |priority_queue             |See below.        |
|----------------------------------+---------------------------+------------------|
|const value_type& top() const     |priority_queue             |See below.        |
|----------------------------------+---------------------------+------------------|
|void push(const value_type&)      |priority_queue             |See below.        |
|----------------------------------+---------------------------+------------------|
|void pop() [6][3]                 |priority_queue             |See below.        |
+---------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-Assignable| and
   |stl-DefaultConstructible| requirements, but are specific to
   priority_queue.

   +------------------------------------------------------------------------+
   |                 Member                 |          Description          |
   |----------------------------------------+-------------------------------|
   | value_type                             | The type of object stored in  |
   |                                        | the priority_queue. This is   |
   |                                        | the same as T and             |
   |                                        | Sequence::value_type.         |
   |----------------------------------------+-------------------------------|
   | size_type                              | An unsigned integral type.    |
   |                                        | This is the same as           |
   |                                        | Sequence::size_type.          |
   |----------------------------------------+-------------------------------|
   | priority_queue(const Compare& comp)    | The constructor. Creates an   |
   |                                        | empty priority_queue, using   |
   |                                        | comp as the comparison        |
   |                                        | function. The default         |
   |                                        | constructor uses Compare() as |
   |                                        | the comparison function.      |
   |----------------------------------------+-------------------------------|
   |priority_queue(const value_type* first, | The constructor. Creates a    |
   |               const value_type* last)  | priority_queue initialized to |
   |                                        | contain the elements in the   |
   |                                        | range [first, last), and      |
   |                                        | using Compare() as the        |
   |                                        | comparison function.          |
   |----------------------------------------+-------------------------------|
   |priority_queue(const value_type* first, | The constructor. Creates a    |
   |               const value_type* last,  | priority_queue initialized to |
   |               const Compare& comp)     | contain the elements in the   |
   |                                        | range [first, last), and      |
   |                                        | using comp as the comparison  |
   |                                        | function.                     |
   |----------------------------------------+-------------------------------|
   | bool empty() const                     | Returns true if the           |
   |                                        | priority_queue contains no    |
   |                                        | elements, and false           |
   |                                        | otherwise. S.empty() is       |
   |                                        | equivalent to S.size() == 0.  |
   |----------------------------------------+-------------------------------|
   | size_type size() const                 | Returns the number of         |
   |                                        | elements contained in the     |
   |                                        | priority_queue.               |
   |----------------------------------------+-------------------------------|
   | const value_type& top() const          | Returns a const reference to  |
   |                                        | the element at the top of the |
   |                                        | priority_queue. The element   |
   |                                        | at the top is guaranteed to   |
   |                                        | be the largest element in the |
   |                                        | priority queue, as determined |
   |                                        | by the comparison function    |
   |                                        | Compare. That is, for every   |
   |                                        | other element x in the        |
   |                                        | priority_queue,               |
   |                                        | Compare(Q.top(), x) is false. |
   |                                        | Precondition: empty() is      |
   |                                        | false.                        |
   |----------------------------------------+-------------------------------|
   | void push(const value_type& x)         | Inserts x into the            |
   |                                        | priority_queue.               |
   |                                        | Postcondition: size() will be |
   |                                        | incremented by 1.             |
   |----------------------------------------+-------------------------------|
   | void pop()                             | Removes the element at the    |
   |                                        | top of the priority_queue,    |
   |                                        | that is, the largest element  |
   |                                        | in the priority_queue. [7][3] |
   |                                        | Precondition: empty() is      |
   |                                        | false. Postcondition: size()  |
   |                                        | will be decremented by 1.     |
   +------------------------------------------------------------------------+

  Notes

   [1] Priority queues are a standard concept, and can be implemented in many
   different ways; this implementation uses heaps. Priority queues are
   discussed in all algorithm books; see, for example, section 5.2.3 of
   Knuth. (D. E. Knuth, The Art of Computer Programming. Volume 3: Sorting
   and Searching. Addison-Wesley, 1975.)

   [2] This restriction is the only reason for priority_queue to exist at
   all. If iteration through elements is important, you can either use a
   |stl-Vector| that is maintained in sorted order, or a |stl-set|, or a
   |stl-Vector| that is maintained as a heap using |stl-make_heap|,
   |stl-push_heap|, and |stl-pop_heap|. Priority_queue is, in fact,
   implemented as a |stl-RandomAccessContainer| that is maintained as a heap.
   The only reason to use the container adaptor priority_queue, instead of
   performing the heap operations manually, is to make it clear that you are
   never performing any operations that might violate the heap invariant.

   [3] One might wonder why pop() returns void, instead of value_type. That
   is, why must one use top() and pop() to examine and remove the element at
   the top of the priority_queue, instead of combining the two in a single
   member function? In fact, there is a good reason for this design. If pop()
   returned the top element, it would have to return by value rather than by
   reference: return by reference would create a dangling pointer. Return by
   value, however, is inefficient: it involves at least one redundant copy
   constructor call. Since it is impossible for pop() to return a value in
   such a way as to be both efficient and correct, it is more sensible for it
   to return no value at all and to require clients to use top() to inspect
   the value at the top of the priority_queue.

  See also

   |stl-stack|, |stl-queue|, |stl-set|, |stl-make_heap|, |stl-push_heap|,
   |stl-pop_heap|, |stl-is_heap|, |stl-sort|, |stl-is_sorted|,
   |stl-Container|, |stl-SortedAssociativeContainer|, |stl-Sequence|


        ________________________________________________________________________
                                     |stl-bitset|
*stl-bitset*

                                   bitset<N>

   Category: containers                                  Component type: type

  Description

   Bitset is very similar to |stl-Vector|<bool> (also known as
   |stl-bit_vector|): it contains a collection of bits, and provides
   constant-time access to each bit. There are two main differences between
   bitset and vector<bool>. First, the size of a bitset cannot be changed:
   bitset's template parameter N, which specifies the number of bits in the
   bitset, must be an integer constant. Second, bitset is not a
   |stl-Sequence|; in fact, it is not an STL |stl-Container| at all. It does
   not have iterators, for example, or begin() and end() member functions.
   Instead, bitset's interface resembles that of unsigned integers. It
   defines bitwise arithmetic operators such as &=, |=, and ^=.

   In general, bit 0 is the least significant bit and bit N-1 is the most
   significant bit.

*stl-bitset-example*

 int main() {
   const bitset<12> mask(2730ul);
   cout << "mask =      " << mask << endl;

   bitset<12> x;

   cout << "Enter a 12-bit bitset in binary: " << flush;
   if (cin >> x) {
     cout << "x =        " << x << endl;
     cout << "As ulong:  " << x.to_ulong() << endl;
     cout << "And with mask: " << (x & mask) << endl;
     cout << "Or with mask:  " << (x | mask) << endl;
   }
 }

  Definition

   Defined in the standard header |stl-bitset|.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | N         | A nonzero constant of type size_t: the number of |         |
   |           | bits that the bitset contains.                   |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-Assignable|, |stl-DefaultConstructible|, |stl-EqualityComparable|

  Type requirements

   N is a constant integer expression of a type convertible to size_t, and N
   is a positive number.

  Public base classes

   None.

  Members

+-----------------------------------------------------------------------------------------------------+
|                        Member                         |       Where defined       |   Description   |
|-------------------------------------------------------+---------------------------+-----------------|
|reference                                              |bitset                     |A proxy class    |
|                                                       |                           |that acts as a   |
|                                                       |                           |reference to a   |
|                                                       |                           |single bit.      |
|-------------------------------------------------------+---------------------------+-----------------|
|bitset()                                               ||stl-DefaultConstructible| |The default      |
|                                                       |                           |constructor. All |
|                                                       |                           |bits are         |
|                                                       |                           |initially zero.  |
|-------------------------------------------------------+---------------------------+-----------------|
|bitset(unsigned long val)                              |bitset                     |Conversion from  |
|                                                       |                           |unsigned long.   |
|-------------------------------------------------------+---------------------------+-----------------|
|bitset(const bitset&)                                  ||stl-Assignable|           |Copy constructor.|
|-------------------------------------------------------+---------------------------+-----------------|
|bitset& operator=(const bitset&)                       ||stl-Assignable|           |Assignment       |
|                                                       |                           |operator.        |
|-------------------------------------------------------+---------------------------+-----------------|
|template<class Char, class Traits, class Alloc>        |bitset                     |Conversion from  |
|explicit                                               |                           |string.          |
|bitset(const |stl-basic_string|<Char,Traits,Alloc>& s, |                           |                 |
|       size_t pos = 0,                                 |                           |                 |
|       size_t n =                                      |                           |                 |
|         |stl-basic_string|<Char,Traits,Alloc>::npos)  |                           |                 |
|-------------------------------------------------------+---------------------------+-----------------|
|bitset& operator&=(const bitset&)                      |bitset                     |Bitwise and.     |
|-------------------------------------------------------+---------------------------+-----------------|
|bitset& operator|=(const bitset&)                      |bitset                     |Bitwise inclusive|
|                                                       |                           |or.              |
|-------------------------------------------------------+---------------------------+-----------------|
|bitset& operator^=(const bitset&)                      |bitset                     |Bitwise exclusive|
|                                                       |                           |or.              |
|-------------------------------------------------------+---------------------------+-----------------|
|bitset& operator<<=(size_t)                            |bitset                     |Left shift.      |
|-------------------------------------------------------+---------------------------+-----------------|
|bitset& operator>>=(size_t)                            |bitset                     |Right shift.     |
|-------------------------------------------------------+---------------------------+-----------------|
|bitset operator<<(size_t n) const                      |bitset                     |Returns a copy of|
|                                                       |                           |*this shifted    |
|                                                       |                           |left by n bits.  |
|-------------------------------------------------------+---------------------------+-----------------|
|bitset operator>>(size_t n) const                      |bitset                     |Returns a copy of|
|                                                       |                           |*this shifted    |
|                                                       |                           |right by n bits. |
|-------------------------------------------------------+---------------------------+-----------------|
|bitset& set()                                          |bitset                     |Sets every bit.  |
|-------------------------------------------------------+---------------------------+-----------------|
|bitset& flip()                                         |bitset                     |Flips the value  |
|                                                       |                           |of every bit.    |
|-------------------------------------------------------+---------------------------+-----------------|
|bitset operator~() const                               |bitset                     |Returns a copy of|
|                                                       |                           |*this with all of|
|                                                       |                           |its bits flipped.|
|-------------------------------------------------------+---------------------------+-----------------|
|bitset& reset()                                        |bitset                     |Clears every bit.|
|-------------------------------------------------------+---------------------------+-----------------|
|bitset& set(size_t n, int val = 1)                     |bitset                     |Sets bit n if val|
|                                                       |                           |is nonzero, and  |
|                                                       |                           |clears bit n if  |
|                                                       |                           |val is zero.     |
|-------------------------------------------------------+---------------------------+-----------------|
|bitset& reset(size_t n)                                |bitset                     |Clears bit n.    |
|-------------------------------------------------------+---------------------------+-----------------|
|bitset flip(size_t n)                                  |bitset                     |Flips bit n.     |
|-------------------------------------------------------+---------------------------+-----------------|
|size_t size() const                                    |bitset                     |Returns N.       |
|-------------------------------------------------------+---------------------------+-----------------|
|size_t count() const                                   |bitset                     |Returns the      |
|                                                       |                           |number of bits   |
|                                                       |                           |that are set.    |
|-------------------------------------------------------+---------------------------+-----------------|
|bool any() const                                       |bitset                     |Returns true if  |
|                                                       |                           |any bits are set.|
|-------------------------------------------------------+---------------------------+-----------------|
|bool none() const                                      |bitset                     |Returns true if  |
|                                                       |                           |no bits are set. |
|-------------------------------------------------------+---------------------------+-----------------|
|bool test(size_t n) const                              |bitset                     |Returns true if  |
|                                                       |                           |bit n is set.    |
|-------------------------------------------------------+---------------------------+-----------------|
|reference operator[](size_t n)                         |bitset                     |Returns a        |
|                                                       |                           |reference to bit |
|                                                       |                           |n.               |
|-------------------------------------------------------+---------------------------+-----------------|
|bool operator[](size_t n) const                        |bitset                     |Returns true if  |
|                                                       |                           |bit n is set.    |
|-------------------------------------------------------+---------------------------+-----------------|
|unsigned long to_ulong() const                         |bitset                     |Returns an       |
|                                                       |                           |unsigned long    |
|                                                       |                           |corresponding to |
|                                                       |                           |the bits in      |
|                                                       |                           |*this.           |
|-------------------------------------------------------+---------------------------+-----------------|
|template<class Char, class Traits, class Alloc>        |bitset                     |Returns a string |
||stl-basic_string|<Char,Traits,Alloc> to_string() const|                           |representation of|
|                                                       |                           |*this.           |
|-------------------------------------------------------+---------------------------+-----------------|
|bool operator==(const bitset&) const                   ||stl-EqualityComparable|   |The equality     |
|                                                       |                           |operator.        |
|-------------------------------------------------------+---------------------------+-----------------|
|bool operator!=(const bitset&) const                   ||stl-EqualityComparable|   |The inequality   |
|                                                       |                           |operator.        |
|-------------------------------------------------------+---------------------------+-----------------|
|bitset operator&(const bitset&, const bitset&)         |bitset                     |Bitwise and of   |
|                                                       |                           |two bitsets. This|
|                                                       |                           |is a global      |
|                                                       |                           |function, not a  |
|                                                       |                           |member function. |
|-------------------------------------------------------+---------------------------+-----------------|
|bitset operator|(const bitset&, const bitset&)         |bitset                     |Bitwise or of two|
|                                                       |                           |bitsets. This is |
|                                                       |                           |a global         |
|                                                       |                           |function, not a  |
|                                                       |                           |member function. |
|-------------------------------------------------------+---------------------------+-----------------|
|bitset operator^(const bitset&, const bitset&)         |bitset                     |Bitwise exclusive|
|                                                       |                           |or of two        |
|                                                       |                           |bitsets. This is |
|                                                       |                           |a global         |
|                                                       |                           |function, not a  |
|                                                       |                           |member function. |
|-------------------------------------------------------+---------------------------+-----------------|
|template <class Char, class Traits,                    |bitset                     |Extract a bitset |
|          size_t N>                                    |                           |from an input    |
|basic_istream<Char,Traits>&                            |                           |stream.          |
|operator>>(basic_istream<Char,Traits>&,                |                           |                 |
|           bitset<N>&)                                 |                           |                 |
|-------------------------------------------------------+---------------------------+-----------------|
|template <class Char, class Traits,                    |bitset                     |Output a bitset  |
|          size_t N>                                    |                           |to an output     |
|basic_ostream<Char,Traits>&                            |                           |stream.          |
|operator>>(basic_ostream<Char,Traits>&,                |                           |                 |
|           const bitset<N>&)                           |                           |                 |
+-----------------------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-Assignable|,
   |stl-DefaultConstructible|, or |stl-EqualityComparable| requirements, but
   are specific to bitset.

+-------------------------------------------------------------------------------------------------------------------------+
|                        Member                         |                           Description                           |
|-------------------------------------------------------+-----------------------------------------------------------------|
|reference                                              |A proxy class that acts as a reference to a single bit. It       |
|                                                       |contains an assignment operator, a conversion to bool, an        |
|                                                       |operator~, and a member function flip. It exists only as a helper|
|                                                       |class for bitset's operator[]. That is, it supports the          |
|                                                       |expressions x = b[i], b[i] = x, b[i] = b[j], x = ~b[i], and      |
|                                                       |b[i].flip(). (Where b is a bitset and x is a bool.)              |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bitset(unsigned long val)                              |Conversion from unsigned long. Constructs a bitset, initializing |
|                                                       |the first min(N, sizeof(unsigned long) * CHAR_BIT) bits to the   |
|                                                       |corresponding bits in val and all other bits, if any, to zero.   |
|-------------------------------------------------------+-----------------------------------------------------------------|
|template<class Char, class Traits, class Alloc>        |Conversion from string. Constructs a bitset, initializing the    |
|explicit                                               |first M bits to the corresponding characters in s, where M is    |
|bitset(const |stl-basic_string|<Char,Traits,Alloc>& s, |defined as min(N, min(s.size() - pos, n)). Note that the highest |
|       size_t pos = 0,                                 |character position in s, not the lowest, corresponds to the least|
|       size_t n =                                      |significant bit. That is, character position pos + M - 1 - i     |
|         |stl-basic_string|<Char,Traits,Alloc>::npos)  |corresponds to bit i. So, for example, bitset(string("1101")) is |
|                                                       |the same as bitset(13ul). This function throws out_of_range if   |
|                                                       |pos > s.size(), and invalid_argument if any of the characters    |
|                                                       |used to initialize the bits are anything other than 0 or 1.      |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bitset& operator&=(const bitset&)                      |Bitwise and.                                                     |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bitset& operator|=(const bitset&)                      |Bitwise inclusive or.                                            |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bitset& operator^=(const bitset&)                      |Bitwise exclusive or.                                            |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bitset& operator<<=(size_t n)                          |Left shift, where bit 0 is considered the least significant bit. |
|                                                       |Bit i takes on the previous value of bit i - n, or zero if no    |
|                                                       |such bit exists.                                                 |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bitset& operator>>=(size_t n)                          |Right shift, where bit 0 is considered the least significant bit.|
|                                                       |Bit i takes on the previous value of bit i + n, or zero if no    |
|                                                       |such bit exists.                                                 |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bitset operator<<(size_t n) const                      |Returns a copy of *this shifted left by n bits. Note that the    |
|                                                       |expression b << n is equivalent to constructing a temporary copy |
|                                                       |of b and then using operator<<=.                                 |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bitset operator>>(size_t n) const                      |Returns a copy of *this shifted right by n bits. Note that the   |
|                                                       |expression b >> n is equivalent to constructing a temporary copy |
|                                                       |of b and then using operator>>=.                                 |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bitset& set()                                          |Sets every bit.                                                  |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bitset& flip()                                         |Flips the value of every bit.                                    |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bitset operator~() const                               |Returns a copy of *this with all of its bits flipped.            |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bitset& reset()                                        |Clears every bit.                                                |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bitset& set(size_t n, int val = 1)                     |Sets bit n if val is nonzero, and clears bit n if val is zero.   |
|                                                       |Throws out_of_range if n >= N.                                   |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bitset& reset(size_t n)                                |Clears bit n. Throws out_of_range if n >= N.                     |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bitset flip(size_t n)                                  |Flips bit n. Throws out_of_range if n >= N.                      |
|-------------------------------------------------------+-----------------------------------------------------------------|
|size_t size() const                                    |Returns N.                                                       |
|-------------------------------------------------------+-----------------------------------------------------------------|
|size_t count() const                                   |Returns the number of bits that are set.                         |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bool any() const                                       |Returns true if any bits are set.                                |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bool none() const                                      |Returns true if no bits are set.                                 |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bool test(size_t n) const                              |Returns true if bit n is set. Throws out_of_range if n >= N.     |
|-------------------------------------------------------+-----------------------------------------------------------------|
|reference operator[](size_t n)                         |Returns a reference to bit n. Note that reference is a proxy     |
|                                                       |class with an assignment operator and a conversion to bool, which|
|                                                       |allows you to use operator[] for assignment. That is, you can    |
|                                                       |write both x = b[n] and b[n] = x.                                |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bool operator[](size_t n) const                        |Returns true if bit n is set.                                    |
|-------------------------------------------------------+-----------------------------------------------------------------|
|unsigned long to_ulong() const                         |Returns an unsigned long corresponding to the bits in *this.     |
|                                                       |Throws overflow_error if it is impossible to represent *this as  |
|                                                       |an unsigned long. (That is, if N is larger than the number of    |
|                                                       |bits in an unsigned long and if any of the high-order bits are   |
|                                                       |set.                                                             |
|-------------------------------------------------------+-----------------------------------------------------------------|
|template<class Char, class Traits, class Alloc>        |Returns a string representation of *this: each character is 1 if |
||stl-basic_string|<Char,Traits,Alloc> to_string() const|the corresponding bit is set, and 0 if it is not. In general,    |
|                                                       |character position i corresponds to bit position N - 1 - i. Note |
|                                                       |that this member function relies on two language features, member|
|                                                       |templates and explicit function template argument specification, |
|                                                       |that are not yet universally available; this member function is  |
|                                                       |disabled for compilers that do not support those features. Note  |
|                                                       |also that the syntax for calling this member function is somewhat|
|                                                       |cumbersome. To convert a bitset b to an ordinary string, you must|
|                                                       |write                                                            |
|                                                       |                                                                 |
|                                                       |b.template to_string<char, char_traits<char>, allocator<char> >()|
|-------------------------------------------------------+-----------------------------------------------------------------|
|bitset operator&(const bitset&, const bitset&)         |Bitwise and of two bitsets. This is a global function, not a     |
|                                                       |member function. Note that the expression b1 & b2 is equivalent  |
|                                                       |to creating a temporary copy of b1, using operator&=, and        |
|                                                       |returning the temporary copy.                                    |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bitset operator|(const bitset&, const bitset&)         |Bitwise or of two bitsets. This is a global function, not a      |
|                                                       |member function. Note that the expression b1 | b2 is equivalent  |
|                                                       |to creating a temporary copy of b1, using operator|=, and        |
|                                                       |returning the temporary copy.                                    |
|-------------------------------------------------------+-----------------------------------------------------------------|
|bitset operator^(const bitset&, const bitset&)         |Bitwise exclusive or of two bitsets. This is a global function,  |
|                                                       |not a member function. Note that the expression b1 ^ b2 is       |
|                                                       |equivalent to creating a temporary copy of b1, using operator^=, |
|                                                       |and returning the temporary copy.                                |
|-------------------------------------------------------+-----------------------------------------------------------------|
|template <class Char, class Traits,                    |Extract a bitset from an input stream. This function first skips |
|          size_t N>                                    |whitespace, then extracts up to N characters from the input      |
|basic_istream<Char, Traits>&                           |stream. It stops either when it has successfully extracted N     |
|operator>>(basic_istream<Char,Traits>& is,             |character, or when extraction fails, or when it sees a character |
|           bitset<N>& x)                               |that is something other than 1 (in which case it does not extract|
|                                                       |that character). It then assigns a value to the bitset in the    |
|                                                       |same way as if it were initializing the bitset from a string. So,|
|                                                       |for example, if the input stream contains the characters         |
|                                                       |"1100abc", it will assign the value 12ul to the bitset, and the  |
|                                                       |next character read from the input stream will be a.             |
|-------------------------------------------------------+-----------------------------------------------------------------|
|template <class Char, class Traits,                    |Output a bitset to an output stream. This function behaves as if |
|          size_t N>                                    |it converts the bitset to a string and then writes that string to|
|basic_ostream<Char,Traits>&                            |the output stream. That is, it is equivalent to                  |
|operator>>(basic_ostream<Char,Traits>& os,             |                                                                 |
|           const bitset<N>& x)                         |os << x.template to_string<Char,Traits,allocator<Char> >()       |
+-------------------------------------------------------------------------------------------------------------------------+

  See also

   |stl-Vector|, |stl-bit_vector|, |stl-basic_string|







********************************************************************************
                                   Iterators
********************************************************************************
    ----------------------------------------------------------------------------
                              Iterator Introduction
    ----------------------------------------------------------------------------
*stl-Iterators*

                                   Iterators

   Category: iterators                               Component type: overview

  Summary

   Iterators are a generalization of pointers: they are objects that point to
   other objects. As the name suggests, iterators are often used to iterate
   over a range of objects: if an iterator points to one element in a range,
   then it is possible to increment it so that it points to the next element.

   Iterators are central to generic programming because they are an interface
   between containers and algorithms: algorithms typically take iterators as
   arguments, so a container need only provide a way to access its elements
   using iterators. This makes it possible to write a generic algorithm that
   operates on many different kinds of containers, even containers as
   different as a |stl-Vector| and a |stl-List|.

   The STL defines several different concepts related to iterators, several
   predefined iterators, and a collection of types and functions for
   manipulating iterators.

  Description

   Iterators are in fact not a single concept, but six concepts that form a
   hierarchy: some of them define only a very restricted set of operations,
   while others define additional functionality. The five concepts that are
   actually used by algorithms are |stl-InputIterator|, |stl-OutputIterator|,
   |stl-ForwardIterator|, |stl-BidirectionalIterator|, and
   |stl-RandomAccessIterator|. A sixth concept, |stl-TrivialIterator|, is introduced
   only to clarify the definitions of the other iterator concepts.

   The most restricted sorts of iterators are |stl-InputIterator| and
   |stl-OutputIterator|, both of which permit "single pass" algorithms but do
   not necessarily support "multi-pass" algorithms. |stl-InputIterator| only
   guarantee read access: it is possible to dereference an
   |stl-InputIterator| to obtain the value it points to, but not it is not
   necessarily possible to assign a new value through an input iterator.
   Similarly, |stl-OutputIterator| only guarantee write access: it is
   possible to assign a value through an |stl-OutputIterator|, but not
   necessarily possible to refer to that value.

   |stl-ForwardIterator| are a refinement of |stl-InputIterator| and
   |stl-OutputIterator|: they support the |stl-InputIterator| and
   |stl-OutputIterator| operations and also provide additional functionality.
   In particular, it is possible to use "multi-pass" algorithms with
   |stl-ForwardIterator|. A |stl-ForwardIterator| may be constant, in which
   case it is possible to access the object it points to but not to to assign
   a new value through it, or mutable, in which case it is possible to do
   both.

   |stl-BidirectionalIterator|, like |stl-ForwardIterator|, allow multi-pass
   algorithms. As the name suggests, they are different in that they support
   motion in both directions: a |stl-BidirectionalIterator| may be
   incremented to obtain the next element or decremented to obtain the
   previous element. A |stl-ForwardIterator|, by contrast, is only required
   to support forward motion. An iterator used to traverse a singly linked
   list, for example, would be a |stl-ForwardIterator|, while an iterator
   used to traverse a doubly linked list would be a
   |stl-BidirectionalIterator|.

   Finally, |stl-RandomAccessIterator| allow the operations of pointer
   arithmetic: addition of arbitrary offsets, subscripting, subtraction of
   one iterator from another to find a distance, and so on.

   Most algorithms are expressed not in terms of a single iterator but in
   terms of a range of iterators [2][1]; the notation [first, last) refers to
   all of the iterators from first up to, but not including, last. [3][2]
   Note that a range may be empty, i.e. first and last may be the same
   iterator. Note also that if there are n iterators in a range, then the
   notation [first, last) represents n+1 positions. This is crucial:
   algorithms that operate on n things frequently require n+1 positions.
   Linear search, for example (|stl-find|) must be able to return some value
   to indicate that the search was unsuccessful.

   Sometimes it is important to be able to infer some properties of an
   iterator: the type of object that is returned when it is dereferenced, for
   example. There are two different mechanisms to support this sort of
   inferrence: an older mechanism called |stl-iterator_tags|, and a newer
   mechanism called |stl-iterator_traits| [4][3].

  Concepts

     * |stl-TrivialIterator|
     * |stl-InputIterator|
     * |stl-OutputIterator|
     * |stl-ForwardIterator|
     * |stl-BidirectionalIterator|
     * |stl-RandomAccessIterator|

  Types

     * |stl-istream_iterator|
     * |stl-ostream_iterator|

     * |stl-ReverseIterator|
     * |stl-ReverseBidirectionalIterator|
     * |stl-insert_iterator|
     * |stl-front_insert_iterator|
     * |stl-back_insert_iterator|

     * |stl-iterator_traits|

     * |stl-input_iterator_tag|
     * |stl-output_iterator_tag|
     * |stl-forward_iterator_tag|
     * |stl-bidirectional_iterator_tag|
     * |stl-random_access_iterator_tag|

     * |stl-input_iterator|
     * |stl-output_iterator|
     * |stl-forward_iterator|
     * |stl-bidirectional_iterator|
     * |stl-random_access_iterator|

  Functions

     * |stl-distance_type|
     * |stl-value_type|
     * |stl-iterator_category|

     * |stl-distance|
     * |stl-advance|

     * |stl-insert_iterator|
     * |stl-front_insert_iterator|
     * |stl-back_insert_iterator|

  Notes

   [1] Ranges are not a well-defined concept for |stl-TrivialIterator|, because a
   |stl-TrivialIterator| cannot be incremented: there is no such thing as a next
   element. They are also not a well-defined concept for
   |stl-OutputIterator|, because it is impossible to compare two
   |stl-OutputIterator| for equality. Equality is crucial to the definition
   of a range, because only by comparing an iterator for equality with the
   last element is it possible to step through a range.

   [2] Sometimes the notation [first, last) refers to the iterators first,
   first+1, ..., last-1 and sometimes it refers to the objects pointed to by
   those iterators: *first, *(first+1), ..., *(last-1). In most cases it will
   be obvious from context which of these is meant; where the distinction is
   important, the notation will be qualified explicitly as "range of
   iterators" or "range of objects".

   [3] The |stl-iterator_traits| class relies on a C++ feature known as
   partial specialization. Many of today's compilers don't implement the
   complete standard; in particular, many compilers do not support partial
   specialization. If your compiler does not support partial specialization,
   then you will not be able to use |stl-iterator_traits|, and you will
   instead have to continue using the functions |stl-iterator_category|,
   |stl-distance_type|, and |stl-value_type|.

  See also



    ----------------------------------------------------------------------------
                                     Concepts
    ----------------------------------------------------------------------------
*stl-TrivialIterator*

                                Trivial Iterator

   Category: iterators                                Component type: concept

  Description

   A Trivial Iterator is an object that may be dereferenced to refer to some
   other object. Arithmetic operations (such as increment and comparison) are
   not guaranteed to be supported.

  Refinement of

   |stl-Assignable|, |stl-EqualityComparable|, |stl-DefaultConstructible|

  Associated types

   +------------------------------------------------------------------------+
   | Value type | The type of the value obtained by dereferencing a Trivial |
   |            | Iterator                                                  |
   +------------------------------------------------------------------------+

  Notation

   X    A type that is a model of Trivial Iterator
   T    The value type of X
   x, y Object of type X
   t    Object of type T

  Definitions

   A type that is a model of Trivial Iterator may be mutable, meaning that
   the values referred to by objects of that type may be modified, or
   constant, meaning that they may not. For example, int* is a mutable
   iterator type and const int* is a constant iterator type. If an iterator
   type is mutable, this implies that its value type is a model of
   |stl-Assignable|; the converse, though, is not necessarily true.

   A Trivial Iterator may have a singular value, meaning that the results of
   most operations, including comparison for equality, are undefined. The
   only operation that a is guaranteed to be supported is assigning a
   nonsingular iterator to a singular iterator.

   A Trivial Iterator may have a dereferenceable value, meaning that
   dereferencing it yields a well-defined value. Dereferenceable iterators
   are always nonsingular, but the converse is not true. For example, a null
   pointer is nonsingular (there are well defined operations involving null
   pointers) even thought it is not dereferenceable.

   Invalidating a dereferenceable iterator means performing an operation
   after which the iterator might be nondereferenceable or singular. For
   example, if p is a pointer, then delete p invalidates p.

  Valid expressions

   In addition to the expressions defined in |stl-Assignable|,
   |stl-EqualityComparable|, and |stl-DefaultConstructible|, the following
   expressions must be valid.

   +------------------------------------------------------------------------+
   |      Name      | Expression  |  Type requirements   |   Return type    |
   |----------------+-------------+----------------------+------------------|
   | Default        | X x         |                      |                  |
   | constructor    |             |                      |                  |
   |----------------+-------------+----------------------+------------------|
   | Dereference    | *x          |                      | Convertible to T |
   |                |             |                      | [2][1]           |
   |----------------+-------------+----------------------+------------------|
   | Dereference    | *x = t      | X is mutable         |                  |
   | assignment     |             |                      |                  |
   |----------------+-------------+----------------------+------------------|
   | Member access  | x->m [3][2] | T is a type for      |                  |
   |                |             | which x.m is defined |                  |
   +------------------------------------------------------------------------+

  Expression semantics

   +-------------------------------------------------------------------------+
   |      Name       |Expression |  Precondition  |Semantics | Postcondition |
   |-----------------+-----------+----------------+----------+---------------|
   |Default          |X x        |                |          |x is singular  |
   |constructor      |           |                |          |               |
   |-----------------+-----------+----------------+----------+---------------|
   |Dereference      |*x         |x is            |          |               |
   |                 |           |dereferenceable |          |               |
   |-----------------+-----------+----------------+----------+---------------|
   |Dereference      |*x = t     |x is            |          |*x is a copy of|
   |assignment       |           |dereferenceable |          |t              |
   |-----------------+-----------+----------------+----------+---------------|
   |Member access    |x->m       |x is            |Equivalent|               |
   |                 |           |dereferenceable |to (*x).m |               |
   +-------------------------------------------------------------------------+

  Complexity guarantees

   The complexity of operations on trivial iterators is guaranteed to be
   amortized constant time.

  Invariants

   +---------------------------------------------+
   | Identity | x == y if and only if &*x == &*y |
   +---------------------------------------------+

  Models

     * A pointer to an object that is not part of an array.

  Notes

   [1] The requirement for the return type of *x is specified as "convertible
   to T", rather than simply T, because it sometimes makes sense for an
   iterator to return some sort of proxy object instead of the object that
   the iterator conceptually points to. Proxy objects are implementation
   details rather than part of an interface (one use of them, for example, is
   to allow an iterator to behave differently depending on whether its value
   is being read or written), so the value type of an iterator that returns a
   proxy is still T.

   [2] Defining operator-> for iterators depends on a feature that is part of
   the C++ language but that is not yet implemented by all C++ compilers. If
   your compiler does not yet support this feature, the workaround is to use
   (*it).m instead of it->m.

  See also

   |stl-InputIterator|, |stl-OutputIterator|, |stl-ForwardIterator|,
   |stl-BidirectionalIterator|, |stl-RandomAccessIterator|, |stl-Iterators|

*stl-InputIterator*

                                 Input Iterator

   Category: iterators                                Component type: concept

  Description

   An Input Iterator is an iterator that may be dereferenced to refer to some
   object, and that may be incremented to obtain the next iterator in a
   sequence. Input Iterators are not required to be mutable.

  Refinement of

   |stl-TrivialIterator|.

  Associated types

   +------------------------------------------------------------------------+
   | Value type    | The type of the value obtained by dereferencing an     |
   |               | Input Iterator                                         |
   |---------------+--------------------------------------------------------|
   | Distance type | A signed integral type used to represent the distance  |
   |               | from one iterator to another, or the number of         |
   |               | elements in a range.                                   |
   +------------------------------------------------------------------------+

  Notation

   X    A type that is a model of Input Iterator
   T    The value type of X
   i, j Object of type X
   t    Object of type T

  Definitions

   An iterator is past-the-end if it points beyond the last element of a
   container. Past-the-end values are nonsingular and nondereferenceable.

   An iterator is valid if it is dereferenceable or past-the-end.

   An iterator i is incrementable if there is a "next" iterator, that is, if
   ++i is well-defined. Past-the-end iterators are not incrementable.

   An Input Iterator j is reachable from an Input Iterator i if, after
   applying operator++ to i a finite number of times, i == j. [2][1]

   The notation [i,j) refers to a range of iterators beginning with i and up
   to but not including j.

   The range [i,j) is a valid range if both i and j are valid iterators, and
   j is reachable from i [3][2].

  Valid expressions

   In addition to the expressions defined in |stl-TrivialIterator|, the following
   expressions must be valid.

   +------------------------------------------------------------------------+
   |          Name           | Expression | Type requirements | Return type |
   |-------------------------+------------+-------------------+-------------|
   | Preincrement            | ++i        |                   | X&          |
   |-------------------------+------------+-------------------+-------------|
   | Postincrement           | (void)i++  |                   |             |
   |-------------------------+------------+-------------------+-------------|
   | Postincrement and       | *i++       |                   | T           |
   | dereference             |            |                   |             |
   +------------------------------------------------------------------------+

  Expression semantics

 +-----------------------------------------------------------------------------+
 |     Name      |Expression |  Precondition  | Semantics  |   Postcondition   |
 |---------------+-----------+----------------+------------+-------------------|
 |Dereference    |*t         |i is            |            |                   |
 |               |           |incrementable   |            |                   |
 |---------------+-----------+----------------+------------+-------------------|
 |Preincrement   |++i        |i is            |            |i is               |
 |               |           |dereferenceable |            |dereferenceable or |
 |               |           |                |            |past-the-end [4][3]|
 |               |           |                |            |[5][4]             |
 |---------------+-----------+----------------+------------+-------------------|
 |Postincrement  |(void)i++  |i is            |Equivalent  |i is               |
 |               |           |dereferenceable |to (void)++i|dereferenceable or |
 |               |           |                |            |past-the-end [6][3]|
 |               |           |                |            |[7][4]             |
 |---------------+-----------+----------------+------------+-------------------|
 |Postincrement  |*i++       |i is            |Equivalent  |i is               |
 |and dereference|           |dereferenceable |to {T t =   |dereferenceable or |
 |               |           |                |*i; ++i;    |past-the-end [8][3]|
 |               |           |                |return t;}  |[9][4]             |
 +-----------------------------------------------------------------------------+

  Complexity guarantees

   All operations are amortized constant time.

  Invariants

  Models

     * |stl-istream_iterator|

  Notes

   [1] i == j does not imply ++i == ++j.

   [2] Every iterator in a valid range [i, j) is dereferenceable, and j is
   either dereferenceable or past-the-end. The fact that every iterator in
   the range is dereferenceable follows from the fact that incrementable
   iterators must be deferenceable.

   [3] After executing ++i, it is not required that copies of the old value
   of i be dereferenceable or that they be in the domain of operator==.

   [4] It is not guaranteed that it is possible to pass through the same
   input iterator twice.

  See also

   |stl-OutputIterator|, |stl-Iterators|

*stl-OutputIterator*

                                Output Iterator

   Category: iterators                                Component type: concept

  Description

   An Output Iterator is a type that provides a mechanism for storing (but
   not necessarily accessing) a sequence of values. Output Iterators are in
   some sense the converse of |stl-InputIterator|, but they have a far more
   restrictive interface: they do not necessarily support member access or
   equality, and they do not necessarily have either an associated distance
   type or even a value type [2][1]. Intuitively, one picture of an Output
   Iterator is a tape: you can write a value to the current location and you
   can advance to the next location, but you cannot read values and you
   cannot back up or rewind.

  Refinement of

   |stl-Assignable|, |stl-DefaultConstructible|

  Associated types

   None. [3][1]

  Notation

   X    A type that is a model of Output Iterator
   x, y Object of type X

  Definitions

   If x is an Output Iterator of type X, then the expression *x = t; stores
   the value t into x. Note that operator=, like other C++ functions, may be
   overloaded; it may, in fact, even be a template function. In general,
   then, t may be any of several different types. A type T belongs to the set
   of value types of X if, for an object t of type T, *x = t; is well-defined
   and does not require performing any non-trivial conversions on t. [4][1]

   An Output Iterator may be singular, meaning that the results of most
   operations, including copying and dereference assignment, are undefined.
   The only operation that is guaranteed to be supported is assigning a
   nonsingular iterator to a singular iterator.

   An Output Iterator may be dereferenceable, meaning that assignment through
   it is defined. Dereferenceable iterators are always nonsingular, but
   nonsingular iterators are not necessarily dereferenceable.

  Valid expressions

   +------------------------------------------------------------------------+
   |       Name        |   Expression   |   Type requirements   |  Return   |
   |                   |                |                       |   type    |
   |-------------------+----------------+-----------------------+-----------|
   | Default           |X x;            |                       |           |
   | constructor       |X()             |                       |           |
   |-------------------+----------------+-----------------------+-----------|
   | Copy constructor  | X(x)           |                       | X         |
   |-------------------+----------------+-----------------------+-----------|
   | Copy constructor  | X y(x); or X y |                       |           |
   |                   | = x;           |                       |           |
   |-------------------+----------------+-----------------------+-----------|
   | Dereference       | *x = t         | t is convertible to a | Result is |
   | assignment        |                | type in the set of    | not used  |
   |                   |                | value types of X.     |           |
   |                   |                | [5][1]                |           |
   |-------------------+----------------+-----------------------+-----------|
   | Preincrement      | ++x            |                       | X&        |
   |-------------------+----------------+-----------------------+-----------|
   | Postincrement     | (void) x++     |                       | void      |
   |-------------------+----------------+-----------------------+-----------|
   | Postincrement and | *x++ = t;      |                       | Result is |
   | assign            |                |                       | not used  |
   +------------------------------------------------------------------------+

  Expression semantics

  +----------------------------------------------------------------------------+
  |     Name     | Expression |    Precondition    | Semantics | Postcondition |
  |--------------+------------+--------------------+-----------+---------------|
  |Default       |X x;        |                    |           |x may be       |
  |constructor   |X()         |                    |           |singular       |
  |--------------+------------+--------------------+-----------+---------------|
  |Copy          |X(x)        |x is nonsingular    |           |*X(x) = t is   |
  |constructor   |            |                    |           |equivalent to  |
  |              |            |                    |           |*x = t [6][2]  |
  |--------------+------------+--------------------+-----------+---------------|
  |Copy          |X x(y); or X|y is nonsingular    |           |*y = t is      |
  |constructor   |x = y;      |                    |           |equivalent to  |
  |              |            |                    |           |*x = t [7][2]  |
  |--------------+------------+--------------------+-----------+---------------|
  |Dereference   |*x = t      |x is                |           |               |
  |assignment    |            |dereferenceable. If |           |               |
  |              |            |there has been a    |           |               |
  |              |            |previous assignment |           |               |
  |              |            |through x, then     |           |               |
  |              |            |there has been an   |           |               |
  |              |            |intervening         |           |               |
  |              |            |increment. [8][3]   |           |               |
  |--------------+------------+--------------------+-----------+---------------|
  |Preincrement  |++x         |x is                |           |x points to the|
  |              |            |dereferenceable. x  |           |next location  |
  |              |            |has previously been |           |into which a   |
  |              |            |assigned through. If|           |value may be   |
  |              |            |x has previously    |           |stored         |
  |              |            |been incremented,   |           |               |
  |              |            |then there has been |           |               |
  |              |            |an intervening      |           |               |
  |              |            |assignment through x|           |               |
  |              |            |[9][3] [10][4]      |           |               |
  |--------------+------------+--------------------+-----------+---------------|
  |Postincrement |(void) x++  |x is                |Equivalent |x points to the|
  |              |            |dereferenceable. x  |to (void)  |next location  |
  |              |            |has previously been |++x        |into which a   |
  |              |            |assigned through.   |           |value may be   |
  |              |            |                    |           |stored         |
  |--------------+------------+--------------------+-----------+---------------|
  |Postincrement |*x++ = t;   |x is                |Equivalent |x points to the|
  |and assign    |            |dereferenceable. If |to {*x = t;|next location  |
  |              |            |there has been a    |++x; }     |into which a   |
  |              |            |previous assignment |           |value may be   |
  |              |            |through x, then     |           |stored         |
  |              |            |there has been an   |           |               |
  |              |            |intervening         |           |               |
  |              |            |increment. [11][3]  |           |               |
  |              |            |[12][4]             |           |               |
  +----------------------------------------------------------------------------+

  Complexity guarantees

   The complexity of operations on output iterators is guaranteed to be
   amortized constant time.

  Invariants

  Models

     * |stl-ostream_iterator|
     * |stl-insert_iterator|
     * |stl-front_insert_iterator|
     * |stl-back_insert_iterator|

  Notes

   [1] Other iterator types, including |stl-TrivialIterator| and |stl-InputIterator|,
   define the notion of a value type, the type returned when an iterator is
   dereferenced. This notion does not apply to Output Iterators, however,
   since the dereference operator (unary operator*) does not return a usable
   value for Output Iterators. The only context in which the dereference
   operator may be used is assignment through an output iterator: *x = t.
   Although |stl-InputIterator| and output iterators are roughly symmetrical
   concepts, there is an important sense in which accessing and storing
   values are not symmetrical: for an |stl-InputIterator| operator* must
   return a unique type, but, for an Output Iterator, in the expression *x =
   t, there is no reason why operator= must take a unique type. [13][5]
   Consequently, there need not be any unique "value type" for Output
   Iterators.

   [2] There should be only one active copy of a single Output Iterator at
   any one time. That is: after creating and using a copy x of an Output
   Iterator y, the original output iterator y should no longer be used.

   [3] Assignment through an Output Iterator x is expected to alternate with
   incrementing x, and there must be an assignment through x before x is ever
   incremented. Any other order of operations results in undefined behavior.
   That is: {*x = t; ++x; *x = t2; ++x} is acceptable, but {*x = t; ++x; ++x;
   *x = t2;} is not.

   [4] Note that an Output Iterator need not define comparison for equality.
   Even if an operator== is defined, x == y need not imply ++x == ++y.

   [5] If you are implementing an Output Iterator class X, one sensible way
   to define *x = t is to define X::operator*() to return an object of some
   private class X_proxy, and then to define X_proxy::operator=. Note that
   you may overload X_proxy::operator=, or even define it as a member
   template; this allows assignment of more than one type through Output
   Iterators of class X.

  See also

   |stl-TrivialIterator|, |stl-InputIterator|, |stl-Iterators|

*stl-ForwardIterator*

                                Forward Iterator

   Category: iterators                                Component type: concept

  Description

   A Forward Iterator is an iterator that corresponds to the usual intuitive
   notion of a linear sequence of values. It is possible to use Forward
   Iterators (unlike |stl-InputIterator| and |stl-OutputIterator|) in
   multipass algorithms. Forward Iterators do not, however, allow stepping
   backwards through a sequence, but only, as the name suggests, forward.

   A type that is a model of Forward Iterator may be either mutable or
   immutable, as defined in the |stl-TrivialIterator| requirements.

  Refinement of

   |stl-InputIterator|, |stl-OutputIterator|

  Associated types

   The same as for |stl-InputIterator|

  Notation

   X    A type that is a model of Forward Iterator
   T    The value type of X
   i, j Object of type X
   t    Object of type T

  Definitions

  Valid expressions

   Forward Iterator does not define any new expressions beyond those defined
   in |stl-InputIterator|. However, some of the restrictions described in
   |stl-InputIterator| are relaxed.

   +--------------------------------------------------------------+
   |     Name      | Expression | Type requirements | Return type |
   |---------------+------------+-------------------+-------------|
   | Preincrement  | ++i        |                   | X&          |
   |---------------+------------+-------------------+-------------|
   | Postincrement | i++        |                   | X           |
   +--------------------------------------------------------------+

  Expression semantics

   Forward Iterator does not define any new expressions beyond those defined
   in |stl-InputIterator|. However, some of the restrictions described in
   |stl-InputIterator| are relaxed.

 +-----------------------------------------------------------------------------+
 |     Name     |Expression |  Precondition  | Semantics  |   Postcondition    |
 |--------------+-----------+----------------+------------+--------------------|
 |Preincrement  |++i        |i is            |i points to |i is dereferenceable|
 |              |           |dereferenceable |the next    |or past-the-end. &i |
 |              |           |                |value       |== &++i. If i == j, |
 |              |           |                |            |then ++i == ++j.    |
 |              |           |                |            |[2][1]              |
 |--------------+-----------+----------------+------------+--------------------|
 |Postincrement |i++        |i is            |Equivalent  |i is dereferenceable|
 |              |           |dereferenceable |to {X tmp = |or past-the-end.    |
 |              |           |                |i; ++i;     |[3][1]              |
 |              |           |                |return tmp;}|                    |
 +-----------------------------------------------------------------------------+

  Complexity guarantees

   The complexity of operations on Forward Iterators is guaranteed to be
   amortized constant time.

  Invariants

  Models

     * T*
     * |stl-hash_set|<T>::iterator

  Notes

   [1] The restrictions described in |stl-InputIterator| have been removed.
   Incrementing a forward iterator does not invalidate copies of the old
   value and it is guaranteed that, if i and j are dereferenceable and i ==
   j, then ++i == ++j. As a consequence of these two facts, it is possible to
   pass through the same Forward Iterator twice.

  See also

   |stl-InputIterator|, |stl-OutputIterator|, |stl-BidirectionalIterator|,
   |stl-RandomAccessIterator|, |stl-Iterators|

*stl-BidirectionalIterator*

                             Bidirectional Iterator

   Category: iterators                                Component type: concept

  Description

   A Bidirectional Iterator is an iterator that can be both incremented and
   decremented. The requirement that a Bidirectional Iterator can be
   decremented is the only thing that distinguishes Bidirectional Iterators
   from |stl-ForwardIterator|.

  Refinement of

   |stl-ForwardIterator|

  Associated types

   The same as for |stl-ForwardIterator|.

  Notation

   X    A type that is a model of Bidirectional Iterator
   T    The value type of X
   i, j Object of type X
   t    Object of type T

  Definitions

  Valid expressions

   In addition to the expressions defined in |stl-ForwardIterator|, the
   following expressions must be valid.

   +--------------------------------------------------------------+
   |     Name      | Expression | Type requirements | Return type |
   |---------------+------------+-------------------+-------------|
   | Predecrement  | --i        |                   | X&          |
   |---------------+------------+-------------------+-------------|
   | Postdecrement | i--        |                   | X           |
   +--------------------------------------------------------------+

  Expression Semantics

   Semantics of an expression is defined only where it is not defined in
   |stl-ForwardIterator|.

+--------------------------------------------------------------------------------+
|     Name     |Expression |  Precondition  |  Semantics   |    Postcondition    |
|--------------+-----------+----------------+--------------+---------------------|
|Predecrement  |--i        |i is            |i is modified |i is dereferenceable.|
|              |           |dereferenceable |to point to   |&i = &--i. If i == j,|
|              |           |or past-the-end.|the previous  |then --i == --j. If j|
|              |           |There exists a  |element.      |is dereferenceable   |
|              |           |dereferenceable |              |and i == ++j, then   |
|              |           |iterator j such |              |--i == j.            |
|              |           |that i == ++j.  |              |                     |
|--------------+-----------+----------------+--------------+---------------------|
|Postdecrement |i--        |i is            |Equivalent to |                     |
|              |           |dereferenceable |              |                     |
|              |           |or past-the-end.|{             |                     |
|              |           |There exists a  |  X tmp = i;  |                     |
|              |           |dereferenceable |  --i;        |                     |
|              |           |iterator j such |  return tmp; |                     |
|              |           |that i == ++j.  |}             |                     |
+--------------------------------------------------------------------------------+

  Complexity guarantees

   The complexity of operations on bidirectional iterators is guaranteed to
   be amortized constant time.

  Invariants

   +------------------------------------------------------------------------+
   | Symmetry of increment | If i is dereferenceable, then ++i; --i; is a   |
   | and decrement         | null operation. Similarly, --i; ++i; is a null |
   |                       | operation.                                     |
   +------------------------------------------------------------------------+

  Models

     * T*
     * |stl-List|<T>::iterator

  See also

   |stl-InputIterator|, |stl-OutputIterator|, |stl-ForwardIterator|,
   |stl-RandomAccessIterator|, |stl-Iterators|

*stl-RandomAccessIterator*

                             Random Access Iterator

   Category: iterators                                Component type: concept

  Description

   A Random Access Iterator is an iterator that provides both increment and
   decrement (just like a |stl-BidirectionalIterator|), and that also
   provides constant-time methods for moving forward and backward in
   arbitrary-sized steps. Random Access Iterators provide essentially all of
   the operations of ordinary C pointer arithmetic.

  Refinement of

   |stl-BidirectionalIterator|, |stl-LessThanComparable|

  Associated types

   The same as for |stl-BidirectionalIterator|

  Notation

   X        A type that is a model of Random Access Iterator
   T        The value type of X
   Distance The distance type of X
   i, j     Object of type X
   t        Object of type T
   n        Object of type Distance

  Definitions

  Valid expressions

   In addition to the expressions defined in |stl-BidirectionalIterator|, the
   following expressions must be valid.

   +------------------------------------------------------------------------+
   |         Name         |   Expression   |     Type      |  Return type   |
   |                      |                | requirements  |                |
   |----------------------+----------------+---------------+----------------|
   | Iterator addition    | i += n         |               | X&             |
   |----------------------+----------------+---------------+----------------|
   | Iterator addition    | i + n or n + i |               | X              |
   |----------------------+----------------+---------------+----------------|
   | Iterator subtraction | i -= n         |               | X&             |
   |----------------------+----------------+---------------+----------------|
   | Iterator subtraction | i - n          |               | X              |
   |----------------------+----------------+---------------+----------------|
   | Difference           | i - j          |               | Distance       |
   |----------------------+----------------+---------------+----------------|
   | Element operator     | i[n]           |               | Convertible to |
   |                      |                |               | T              |
   |----------------------+----------------+---------------+----------------|
   | Element assignment   | i[n] = t       | X is mutable  | Convertible to |
   |                      |                |               | T              |
   +------------------------------------------------------------------------+

  Expression semantics

   Semantics of an expression is defined only where it differs from, or is
   not defined in, |stl-BidirectionalIterator| or |stl-LessThanComparable|.

+------------------------------------------------------------------------------------------+
|    Name    | Expression |   Precondition    |        Semantics         |  Postcondition  |
|------------+------------+-------------------+--------------------------+-----------------|
|Forward     |i += n      |Including i itself,|If n > 0, equivalent to   |i is             |
|motion      |            |there must be n    |executing ++i n times. If |dereferenceable  |
|            |            |dereferenceable or |n < 0, equivalent to      |or past-the-end. |
|            |            |past-the-end       |executing --i n times. If |                 |
|            |            |iterators following|n == 0, this is a null    |                 |
|            |            |or preceding i,    |operation. [2][1]         |                 |
|            |            |depending on       |                          |                 |
|            |            |whether n is       |                          |                 |
|            |            |positive or        |                          |                 |
|            |            |negative.          |                          |                 |
|------------+------------+-------------------+--------------------------+-----------------|
|Iterator    |i + n or n +|Same as for i += n |Equivalent to { X tmp = i;|Result is        |
|addition    |i           |                   |return tmp += n; }. The   |dereferenceable  |
|            |            |                   |two forms i + n and n + i |or past-the-end  |
|            |            |                   |are identical.            |                 |
|------------+------------+-------------------+--------------------------+-----------------|
|Iterator    |i -= n      |Including i itself,|Equivalent to i += (-n).  |i is             |
|subtraction |            |there must be n    |                          |dereferenceable  |
|            |            |dereferenceable or |                          |or past-the-end. |
|            |            |past-the-end       |                          |                 |
|            |            |iterators preceding|                          |                 |
|            |            |or following i,    |                          |                 |
|            |            |depending on       |                          |                 |
|            |            |whether n is       |                          |                 |
|            |            |positive or        |                          |                 |
|            |            |negative.          |                          |                 |
|------------+------------+-------------------+--------------------------+-----------------|
|Iterator    |i - n       |Same as for i -= n |Equivalent to { X tmp = i;|Result is        |
|subtraction |            |                   |return tmp -= n; }.       |dereferenceable  |
|            |            |                   |                          |or past-the-end  |
|------------+------------+-------------------+--------------------------+-----------------|
|Difference  |i - j       |Either i is        |Returns a number n such   |                 |
|            |            |reachable from j or|that i == j + n           |                 |
|            |            |j is reachable from|                          |                 |
|            |            |i, or both.        |                          |                 |
|------------+------------+-------------------+--------------------------+-----------------|
|Element     |i[n]        |i + n exists and is|Equivalent to *(i + n)    |                 |
|operator    |            |dereferenceable.   |[3][2]                    |                 |
|------------+------------+-------------------+--------------------------+-----------------|
|Element     |i[n] = t    |i + n exists and is|Equivalent to *(i + n) = t|i[n] is a copy of|
|assignment  |            |dereferenceable.   |[4][2]                    |t.               |
|------------+------------+-------------------+--------------------------+-----------------|
|Less        |i < j       |Either i is        |As described in           |                 |
|            |            |reachable from j or||stl-LessThanComparable|  |                 |
|            |            |j is reachable from|[6][4]                    |                 |
|            |            |i, or both. [5][3] |                          |                 |
+------------------------------------------------------------------------------------------+

  Complexity guarantees

   All operations on Random Access Iterators are amortized constant time.
   [7][5]

  Invariants

   +------------------------------------------------------------------------+
   | Symmetry of addition   | If i + n is well-defined, then i += n; i -=   |
   | and subtraction        | n; and (i + n) - n are null operations.       |
   |                        | Similarly, if i - n is well-defined, then i   |
   |                        | -= n; i += n; and (i - n) + n are null        |
   |                        | operations.                                   |
   |------------------------+-----------------------------------------------|
   | Relation between       | If i - j is well-defined, then i == j + (i -  |
   | distance and addition  | j).                                           |
   |------------------------+-----------------------------------------------|
   | Reachability and       | If i is reachable from j, then i - j >= 0.    |
   | distance               |                                               |
   |------------------------+-----------------------------------------------|
   | Ordering               | operator < is a strict weak ordering, as      |
   |                        | defined in |stl-LessThanComparable|.          |
   +------------------------------------------------------------------------+

  Models

     * T*
     * |stl-Vector|<T>::iterator
     * |stl-Vector|<T>::const_iterator
     * |stl-Deque|<T>::iterator
     * |stl-Deque|<T>::const_iterator

  Notes

   [1] "Equivalent to" merely means that i += n yields the same iterator as
   if i had been incremented (decremented) n times. It does not mean that
   this is how operator+= should be implemented; in fact, this is not a
   permissible implementation. It is guaranteed that i += n is amortized
   constant time, regardless of the magnitude of n. [8][5]

   [2] One minor syntactic oddity: in C, if p is a pointer and n is an int,
   then p[n] and n[p] are equivalent. This equivalence is not guaranteed,
   however, for Random Access Iterators: only i[n] need be supported. This
   isn't a terribly important restriction, though, since the equivalence of
   p[n] and n[p] has essentially no application except for obfuscated C
   contests.

   [3] The precondition defined in |stl-LessThanComparable| is that i and j
   be in the domain of operator <. Essentially, then, this is a definition of
   that domain: it is the set of pairs of iterators such that one iterator is
   reachable from the other.

   [4] All of the other comparison operators have the same domain and are
   defined in terms of operator <, so they have exactly the same semantics as
   described in |stl-LessThanComparable|.

   [5] This complexity guarantee is in fact the only reason why Random Access
   Iterator exists as a distinct concept. Every operation in iterator
   arithmetic can be defined for |stl-BidirectionalIterator|; in fact, that
   is exactly what the algorithms |stl-advance| and |stl-distance| do. The
   distinction is simply that the |stl-BidirectionalIterator| implementations
   are linear time, while Random Access Iterators are required to support
   random access to elements in amortized constant time. This has major
   implications for the sorts of algorithms that can sensibly be written
   using the two types of iterators.

  See also

   |stl-LessThanComparable|, |stl-TrivialIterator|, |stl-BidirectionalIterator|,
   |stl-Iterators|



    ----------------------------------------------------------------------------
                                  Iterator Tags
    ----------------------------------------------------------------------------
*stl-iterator_tags*

                                 Iterator Tags

   Category: iterators                               Component type: overview

  Summary

   Iterator tag functions are a method for accessing information that is
   associated with iterators. Specifically, an iterator type must, as
   discussed in the |stl-InputIterator| requirements, have an associated
   distance type and value type. [2][1] It is sometimes important for an
   algorithm parameterized by an iterator type to be able to determine the
   distance type and value type. Iterator tags also allow algorithms to
   determine an iterator's category, so that they can take different actions
   depending on whether an iterator is an |stl-InputIterator|,
   |stl-OutputIterator|, |stl-ForwardIterator|, |stl-BidirectionalIterator|,
   or |stl-RandomAccessIterator|.

   Note that the iterator tag functions |stl-distance_type|,
   |stl-value_type|, and |stl-iterator_category| are an older method of
   accessing the type information associated with iterators: they were
   defined in the original STL. The draft C++ standard, however, defines a
   different and more convenient mechanism: |stl-iterator_traits|. Both
   mechanisms are supported [3][2], for reasons of backwards compatibility,
   but the older mechanism will eventually be removed.

  Description

   The basic idea of the iterator tag functions, and of
   |stl-iterator_traits|, is quite simple: iterators have associated type
   information, and there must be a way to access that information.
   Specifically, iterator tag functions and |stl-iterator_traits| are used to
   determine an iterator's value type, distance type, and iterator category.

   An iterator's category is the most specific concept that it is a model of:
   |stl-InputIterator|, |stl-OutputIterator|, |stl-ForwardIterator|,
   |stl-BidirectionalIterator|, or |stl-RandomAccessIterator|. This
   information is expressed in the C++ type system by defining five category
   tag types, |stl-input_iterator_tag|, |stl-output_iterator_tag|,
   |stl-forward_iterator_tag|, |stl-bidirectional_iterator_tag|, and
   |stl-random_access_iterator_tag|, each of which corresponds to one of
   those concepts. [4][3]

   The function |stl-iterator_category| takes a single argument, an iterator,
   and returns the tag corresponding to that iterator's category. That is, it
   returns a |stl-random_access_iterator_tag| if its argument is a pointer, a
   |stl-bidirectional_iterator_tag| if its argument is a
   |stl-List|::iterator, and so on. Iterator_traits provides the same
   information in a slightly different way: if I is an iterator, then
   |stl-iterator_traits|<I>::iterator_category is a nested typedef: it is one
   of the five category tag types.

   An iterator's value type is the type of object that is returned when the
   iterator is dereferenced. (See the discussion in the |stl-InputIterator|
   requirements.) Ideally, one might want |stl-value_type| to take a single
   argument, an iterator, and return the iterator's value type.
   Unfortunately, that's impossible: a function must return an object, and
   types aren't objects. Instead, |stl-value_type| returns the value (T*) 0,
   where T is the argument's value type. The iterator_traits class, however,
   does not have this restriction: iterator_traits<I>::value_type is a type,
   not a value. It is a nested typedef, and it can be used in declarations of
   variables, as an function's argument type or return type, and in any other
   ways that C++ types can be used.

   (Note that the function |stl-value_type| need not be defined for
   |stl-OutputIterator|, since an |stl-OutputIterator| need not have a value
   type. Similarly, |stl-iterator_traits|<I>::value_type is typically defined
   as void when I is an output iterator)

   An iterator's distance type, or difference type (the terms are synonymous)
   is the type that is used to represent the distance between two iterators.
   (See the discussion in the |stl-InputIterator| requirements.) The function
   |stl-distance_type| returns this information in the same form that
   |stl-value_type| does: its argument is an iterator, and it returns the
   value (Distance*) 0, where Distance is the iterator's distance type.
   Similarly, |stl-iterator_traits|<I>::difference_type is I's distance type.

   Just as with |stl-value_type|, the function |stl-distance_type| need not
   be defined for |stl-OutputIterator|, and, if I is an |stl-OutputIterator|,
   |stl-iterator_traits|<I>::difference_type may be defined as void. An
   |stl-OutputIterator| need not have a distance type.

   The functions |stl-iterator_category|, |stl-value_type|, and
   |stl-distance_type| must be provided for every type of iterator. (Except,
   as noted above, that |stl-value_type| and |stl-distance_type| need not be
   provided for |stl-OutputIterator|.) In principle, this is simply a matter
   of overloading: anyone who defines a new iterator type must define those
   three functions for it. In practice, there's a slightly more convenient
   method. The STL defines five base classes, |stl-output_iterator|,
   |stl-input_iterator|, |stl-forward_iterator|,
   |stl-bidirectional_iterator|, and |stl-random_access_iterator|. The
   functions |stl-iterator_category|, |stl-value_type|, and
   |stl-distance_type| are defined for those base classes. The effect, then,
   is that if you are defining a new type of iterator you can simply derive
   it from one of those base classes, and the iterator tag functions will
   automatically be defined correctly. These base classes contain no member
   functions or member variables, so deriving from one of them ought not to
   incur any overhead.

   (Again, note that base classes are provided solely for the convenience of
   people who define iterators. If you define a class Iter that is a new kind
   of |stl-BidirectionalIterator|, you do not have to derive it from the base
   class |stl-bidirectional_iterator|. You do, however, have to make sure
   that |stl-iterator_category|, |stl-value_type|, and |stl-distance_type|
   are defined correctly for arguments of type Iter, and deriving Iter from
   |stl-bidirectional_iterator| is usually the most convenient way to do
   that.)

*stl-iterator_tags-example*

   This example uses the |stl-value_type| iterator tag function in order to
   declare a temporary variable of an iterator's value type. Note the use of
   an auxiliary function, __iter_swap. This is a very common idiom: most uses
   of iterator tags involve auxiliary functions.

     template <class |stl-ForwardIterator|1, class |stl-ForwardIterator|2, class ValueType>
     inline void __iter_swap(ForwardIterator1 a, ForwardIterator2 b, ValueType*) {
         ValueType tmp = *a;
         *a = *b;
         *b = tmp;
     }

     template <class |stl-ForwardIterator|1, class |stl-ForwardIterator|2>
     inline void iter_swap(ForwardIterator1 a, ForwardIterator2 b) {
         __iter_swap(a, b, |stl-value_type|(a));
     }

   This example does exactly the same thing, using |stl-iterator_traits|
   instead. Note how much simpler it is: the auxiliary function is no longer
   required.

     template <class |stl-ForwardIterator|1, class |stl-ForwardIterator|2>
     inline void iter_swap(ForwardIterator1 a, ForwardIterator2 b) {
         |stl-iterator_traits|<ForwardIterator1>::value_type tmp = *a;
         *a = *b;
         *b = tmp;
     }

   This example uses the |stl-iterator_category| iterator tag function:
   |stl-reverse| can be implemented for either |stl-BidirectionalIterator|s
   or for |stl-RandomAccessIterator|, but the algorithm for
   |stl-RandomAccessIterator| is more efficient. Consequently, |stl-reverse|
   is written to dispatch on the iterator category. This dispatch takes place
   at compile time, and should not incur any run-time penalty.

     template <class |stl-BidirectionalIterator|>
     void __reverse(BidirectionalIterator first, BidirectionalIterator last,
                    |stl-bidirectional_iterator_tag|) {
         while (true)
             if (first == last || first == --last)
                 return;
             else
                 iter_swap(first++, last);
     }

     template <class |stl-RandomAccessIterator|>
     void __reverse(RandomAccessIterator first, RandomAccessIterator last,
                    |stl-random_access_iterator_tag|) {
         while (first < last) iter_swap(first++, --last);
     }

     template <class |stl-BidirectionalIterator|>
     inline void |stl-reverse|(BidirectionalIterator first, BidirectionalIterator last) {
         __reverse(first, last, |stl-iterator_category|(first));
     }

   In this case, |stl-iterator_traits| would not be different in any
   substantive way: it would still be necessary to use auxiliary functions to
   dispatch on the iterator category. The only difference is changing the
   top-level function to

     template <class |stl-BidirectionalIterator|>
     inline void |stl-reverse|(BidirectionalIterator first, BidirectionalIterator last) {
         __reverse(first, last,
                   |stl-iterator_traits|<first>::iterator_category());
     }

  Concepts

  Types

     * |stl-output_iterator|
     * |stl-input_iterator|
     * |stl-forward_iterator|
     * |stl-bidirectional_iterator|
     * |stl-random_access_iterator|

     * |stl-output_iterator_tag|
     * |stl-input_iterator_tag|
     * |stl-forward_iterator_tag|
     * |stl-bidirectional_iterator_tag|
     * |stl-random_access_iterator_tag|

     * |stl-iterator_traits|

  Functions

     * |stl-iterator_category|
     * |stl-value_type|
     * |stl-distance_type|

  Notes

   [1] |stl-OutputIterator| have neither a distance type nor a value type; in
   many ways, in fact, |stl-OutputIterator| aren't really iterators. Output
   iterators do not have a value type, because it is impossible to obtain a
   value from an output iterator but only to write a value through it. They
   do not have a distance type, similarly, because it is impossible to find
   the distance from one output iterator to another. Finding a distance
   requires a comparison for equality, and output iterators do not support
   operator==.

   [2] The |stl-iterator_traits| class relies on a C++ feature known as
   partial specialization. Many of today's compilers don't implement the
   complete standard; in particular, many compilers do not support partial
   specialization. If your compiler does not support partial specialization,
   then you will not be able to use |stl-iterator_traits|, and you will have
   to continue to use the older iterator tag functions.

   [3] Note that |stl-TrivialIterator| does not appear in this list. The
   |stl-TrivialIterator| concept is introduced solely for conceptual clarity; the STL
   does not actually define any |stl-TrivialIterator| types, so there is no need for
   a |stl-TrivialIterator| tag. There is, in fact, a strong reason not to define one:
   the C++ type system does not provide any way to distinguish between a
   pointer that is being used as a trivial iterator (that is, a pointer to an
   object that isn't part of an array) and a pointer that is being used as a
   |stl-RandomAccessIterator| into an array.

  See also

   |stl-InputIterator|, |stl-OutputIterator|, |stl-ForwardIterator|,
   |stl-BidirectionalIterator|, |stl-RandomAccessIterator|,
   |stl-iterator_traits|, |stl-Iterators|

*stl-iterator_traits*

                           iterator_traits<Iterator>

   Category: iterators                                   Component type: type

  Description

   As described in the |stl-Iterators|, one of the most important facts about
   iterators is that they have associated types. An iterator type, for
   example, has an associated value type: the type of object that the
   iterator points to. It also has an associated distance type, or difference
   type, a signed integral type that can be used to represent the distance
   between two iterators.

   (Pointers, for example, are iterators; the value type of int* is int. Its
   distance type is ptrdiff_t, because, if p1 and p2 are pointers, the
   expression p1 - p2 has type ptrdiff_t.)

   Generic algorithms often need to have access to these associated types; an
   algorithm that takes a range of iterators, for example, might need to
   declare a temporary variable whose type is the iterators' value type. The
   class iterator_traits is a mechanism that allows such declarations.

   The most obvious way to allow declarations of that sort would be to
   require that all iterators declare nested types; an iterator I's value
   type, for example, would be I::value_type. That can't possibly work,
   though. Pointers are iterators, and pointers aren't classes; if I is (say)
   int*, then it's impossible to define I::value_type to be int. Instead, I's
   value type is written iterator_traits<I>::value_type. iterator_traits is a
   template class that contains nothing but nested typedefs; in addition to
   value_type, iterator_traits defines the nested types iterator_category,
   difference_type, pointer, and reference.

   The library contains two definitions of iterator_traits: a fully generic
   one, and a specialization that is used whenever the template argument is a
   pointer type [2][1]. The fully generic version defines
   iterator_traits<I>::value_type as a synonym for I::value_type,
   iterator_traits<I>::difference_type as a synonym for I::difference_type,
   and so on. Since pointers don't have nested types, iterator_traits<T*> has
   a different definition.

   The implementation of iterator_traits is actually simpler than this
   discussion.

   template <class Iterator>
   struct iterator_traits {
     typedef typename Iterator::iterator_category iterator_category;
     typedef typename Iterator::value_type        value_type;
     typedef typename Iterator::difference_type   difference_type;
     typedef typename Iterator::pointer           pointer;
     typedef typename Iterator::reference         reference;
   };

   template <class T>
   struct iterator_traits<T*> {
     typedef random_access_iterator_tag iterator_category;
     typedef T                          value_type;
     typedef ptrdiff_t                  difference_type;
     typedef T*                         pointer;
     typedef T&                         reference;
   };

   If you are defining a new iterator type I, then you must ensure that
   iterator_traits<I> is defined properly. There are two ways to do this.
   First, you can define your iterator so that it has nested types
   I::value_type, I::difference_type, and so on. Second, you can explicitly
   specialize iterator_traits for your type. The first way is almost always
   more convenient, however, especially since you can easily ensure that your
   iterator has the appropriate nested types just by inheriting from one of
   the base classes |stl-input_iterator|, |stl-output_iterator|,
   |stl-forward_iterator|, |stl-bidirectional_iterator|, or
   |stl-random_access_iterator|.

   Note that iterator_traits is new; it was added to the draft C++ standard
   relatively recently. Both the old |stl-iterator_tags| mechanism and the
   new iterator_traits mechanism are currently supported [3][1], but the old
   iterator tag functions are no longer part of the standard C++ library and
   they will eventually be removed.

*stl-iterator_traits-example*

   This generic function returns the last element in a non-empty range. Note
   that there is no way to define a function with this interface in terms of
   the old |stl-value_type| function, because the function's return type must
   be declared to be the iterator's value type.

 template <class InputIterator>
 iterator_traits<InputIterator>::value_type
 last_value(InputIterator first, InputIterator last) {
   iterator_traits<InputIterator>::value_type result = *first;
   for (++first; first != last; ++first)
     result = *first;
   return result;
 }

   (Note: this is an example of how to use iterator_traits; it is not an
   example of good code. There are better ways of finding the last element in
   a range of |stl-BidirectionalIterator|, or even |stl-ForwardIterator|.)

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | Iterator  | The iterator type whose associated types are     |         |
   |           | being accessed.                                  |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-DefaultConstructible|, |stl-Assignable|

  Type requirements

     * Iterator is a model of one of the iterator concepts.
       (|stl-InputIterator|, |stl-OutputIterator|, |stl-ForwardIterator|,
       |stl-BidirectionalIterator|, or |stl-RandomAccessIterator|.)

  Public base classes

   None.

  Members

   None, except for nested types.

   +------------------------------------------------------------------------+
   |      Member       |                    Description                     |
   |-------------------+----------------------------------------------------|
   | iterator_category | One of the types input_iterator_tag,               |
   |                   | output_iterator_tag, forward_iterator_tag,         |
   |                   | bidirectional_iterator_tag, or                     |
   |                   | random_access_iterator_tag. An iterator's category |
   |                   | is the most specific iterator concept that it is a |
   |                   | model of.                                          |
   |-------------------+----------------------------------------------------|
   | value_type        | Iterator's value type, as defined in the           |
   |                   | |stl-TrivialIterator| requirements.                |
   |-------------------+----------------------------------------------------|
   | difference_type   | Iterator's distance type, as defined in the        |
   |                   | |stl-InputIterator| requirements.                  |
   |-------------------+----------------------------------------------------|
   | pointer           | Iterator's pointer type: a pointer to its value    |
   |                   | type.                                              |
   |-------------------+----------------------------------------------------|
   | reference         | Iterator's reference type: a reference to its      |
   |                   | value type.                                        |
   +------------------------------------------------------------------------+

  Notes

   [3] The iterator_traits class relies on a C++ feature known as partial
   specialization. Many of today's compilers don't implement the complete
   standard; in particular, many compilers do not support partial
   specialization. If your compiler does not support partial specialization,
   then you will not be able to use iterator_traits, and you will have to
   continue using the old iterator tag functions |stl-iterator_category|,
   |stl-distance_type|, and |stl-value_type|. This is one reason that those
   functions have not yet been removed.

  See also

   The |stl-Iterators|, |stl-iterator_tags|, |stl-input_iterator_tag|,
   |stl-output_iterator_tag|, |stl-forward_iterator_tag|,
   |stl-bidirectional_iterator_tag|, |stl-random_access_iterator_tag|,
   |stl-input_iterator|, |stl-output_iterator|, |stl-forward_iterator|,
   |stl-bidirectional_iterator|, |stl-random_access_iterator|

*stl-iterator_category*

                               iterator_category

   Category: iterators                               Component type: function

  Prototype

   Iterator_category is overloaded; it is in fact six different functions.

 inline output_iterator_tag iterator_category(const output_iterator&);

 template <class T, class Distance>
 inline |stl-input_iterator_tag|
 iterator_category(const |stl-input_iterator|<T, Distance>&);

 template <class T, class Distance>
 inline |stl-forward_iterator_tag|
 iterator_category(const |stl-forward_iterator|<T, Distance>&);

 template <class T, class Distance>
 inline |stl-bidirectional_iterator_tag|
 iterator_category(const |stl-bidirectional_iterator|<T, Distance>&);

 template <class T, class Distance>
 inline |stl-random_access_iterator_tag|
 iterator_category(const |stl-random_access_iterator|<T, Distance>&);

 template <class T>
 inline |stl-random_access_iterator_tag| iterator_category(const T*);

  Description

   Iterator_category is an |stl-iterator_tags| function: it is used to
   determine the category to which an iterator belongs. Specifically, every
   iterator must belong to a type that is a model of the concept
   |stl-OutputIterator|, |stl-InputIterator|, |stl-ForwardIterator|,
   |stl-BidirectionalIterator|, or |stl-RandomAccessIterator|. [2][1]
   Iterator_category returns an object of class |stl-output_iterator_tag|,
   |stl-input_iterator_tag|, |stl-forward_iterator_tag|, or
   |stl-random_access_iterator_tag|, depending on which concept the type of
   iterator_category's argument is a model of. [3][2] This information is
   useful in the case of an algorithm that has a sensible definition for more
   than one category of iterator, but whose definition is different depending
   on the category.

   Although iterator_category looks like a single function whose return type
   depends on its argument type, in reality it is a set of functions; the
   name iterator_category is overloaded. The function iterator_category must
   be overloaded for every iterator type.

   In practice, ensuring that iterator_category is defined requires
   essentially no work at all. It is already defined for pointers, and for
   the base classes |stl-input_iterator|, |stl-output_iterator|,
   |stl-forward_iterator|, |stl-bidirectional_iterator|, and
   |stl-random_access_iterator|. If you are implementing a new type of
   forward iterator, for example, you can simply derive it from the base
   class |stl-forward_iterator|; this means that iterator_category (along
   with |stl-distance_type| and |stl-value_type|) will automatically be
   defined for your iterator. These base classes are empty: they contain no
   member functions or member variables, but only type information. Using
   them should therefore incur no overhead.

   Note that, while the function iterator_category was present in the
   original STL, it is no longer present in the most recent draft C++
   standard: it has been replaced by the |stl-iterator_traits| class. At
   present both mechanisms are supported [4][3], but eventually
   iterator_category will be removed.

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h. This function is no longer
   part of the C++ standard, although it was present in early drafts of the
   standard. It is retained in this implementation for backward
   compatibility.

  Requirements on types

   The argument of iterator_category must be an iterator.

  Preconditions

   None. Iterator_category's argument is even permitted to be a singular
   iterator.

  Complexity

   At most amortized constant time. In many cases, a compiler should be able
   to optimize away iterator_category entirely.

*stl-iterator_category-example*

   |stl-reverse| can be implemented for either |stl-BidirectionalIterator| or
   for |stl-RandomAccessIterator|, but the algorithm for
   |stl-RandomAccessIterator| is more efficient. Consequently, |stl-reverse|
   uses iterator_category to select whichever algorithm is appropriate for
   the iterator type. This dispatch takes place at compile time, and should
   not incur any run-time penalty.

 template <class |stl-BidirectionalIterator|>
 void __reverse(BidirectionalIterator first, BidirectionalIterator last,
                |stl-bidirectional_iterator_tag|) {
     while (true)
         if (first == last || first == --last)
             return;
         else
             iter_swap(first++, last);
 }

 template <class |stl-RandomAccessIterator|>
 void __reverse(RandomAccessIterator first, RandomAccessIterator last,
                |stl-random_access_iterator_tag|) {
     while (first < last) iter_swap(first++, --last);
 }

 template <class |stl-BidirectionalIterator|>
 inline void |stl-reverse|(BidirectionalIterator first, BidirectionalIterator last) {
     __reverse(first, last, iterator_category(first));
 }

  Notes

   [1] The STL also defines one other concept, |stl-TrivialIterator|. This concept is
   introduced only for conceptual clarity, however, in order to separate the
   axioms related to an object that refers to another object from those
   related to iteration over a range. In fact, the STL does not define any
   types that are |stl-TrivialIterator|. Although built-in C pointers may be
   |stl-TrivialIterator|, the C type system does not allow a distinction between
   pointers that are |stl-TrivialIterator| and pointers that are
   |stl-RandomAccessIterator| into C arrays. Consequently, there is no
   |stl-TrivialIterator| category tag.

   [2] Any type that is a model of |stl-ForwardIterator| is also a model of
   |stl-InputIterator|, any type that is a model of
   |stl-BidirectionalIterator| is also a model of |stl-ForwardIterator|, and
   any type that is a model of |stl-RandomAccessIterator| is also a model of
   |stl-BidirectionalIterator|. Iterator_category must return a tag
   representing the most specific concept that its argument is a model of. If
   its argument is a |stl-Vector|::iterator, for example, then it must return
   |stl-random_access_iterator_tag|.

   [3] The |stl-iterator_traits| class relies on a C++ feature known as
   partial specialization. Many of today's compilers don't implement the
   complete standard; in particular, many compilers do not support partial
   specialization. If your compiler does not support partial specialization,
   then you will not be able to use |stl-iterator_traits|, and you will have
   to continue using the functions iterator_category, |stl-distance_type|,
   and |stl-value_type|. This is one reason that those functions have not yet
   been removed.

  See also

   The |stl-iterator_tags| overview, |stl-iterator_traits|,
   |stl-distance_type|, |stl-value_type|, |stl-output_iterator_tag|,
   |stl-input_iterator_tag|, |stl-forward_iterator_tag|,
   |stl-bidirectional_iterator_tag|, |stl-random_access_iterator_tag|

*stl-distance_type*

                                 distance_type

   Category: iterators                               Component type: function

  Prototype

   Distance_type is overloaded; it is in fact five different functions.

 template <class T, class Distance>
 inline Distance* distance_type(const |stl-input_iterator|<T, Distance>&);

 template <class T, class Distance>
 inline Distance* distance_type(const |stl-forward_iterator|<T, Distance>&);

 template <class T, class Distance>
 inline Distance* distance_type(const |stl-bidirectional_iterator|<T, Distance>&);

 template <class T, class Distance>
 inline Distance* distance_type(const |stl-random_access_iterator|<T, Distance>&);

 template <class T> inline ptrdiff_t* distance_type(const T*);

  Description

   Distance_type is an |stl-iterator_tags| function: it is used to determine
   the distance type associated with an iterator. An |stl-InputIterator|,
   |stl-ForwardIterator|, |stl-BidirectionalIterator|, or
   |stl-RandomAccessIterator| [2][1] must have associated with it some signed
   integral type that is used to represent the distance between two iterators
   of that type. In some cases (such as an algorithm that must declare a
   local variable that represents the size of a range), it is necessary to
   find out an iterator's distance type. Accordingly, distance_type(Iter)
   returns (Distance*) 0, where Distance is Iter's distance type.

   Although distance_type looks like a single function whose return type
   depends on its argument type, in reality it is a set of functions; the
   name distance_type is overloaded. The function distance_type must be
   overloaded for every iterator type [3][1].

   In practice, ensuring that distance_type is defined requires essentially
   no work at all. It is already defined for pointers, and for the base
   classes |stl-input_iterator|, |stl-forward_iterator|,
   |stl-bidirectional_iterator|, and |stl-random_access_iterator|. If you are
   implementing a new type of forward iterator, for example, you can simply
   derive it from the base class |stl-forward_iterator|; this means that
   distance_type (along with |stl-iterator_category| and |stl-value_type|)
   will automatically be defined for your iterator. These base classes are
   empty: they contain no member functions or member variables, but only type
   information. Using them should therefore incur no overhead.

   Note that, while the function distance_type was present in the original
   STL, it is no longer present in the most recent draft C++ standard: it has
   been replaced by the |stl-iterator_traits| class. At present both
   mechanisms are supported [4][2], but eventually distance_type will be
   removed.

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h. This function is no longer
   part of the C++ standard, although it was present in early drafts of the
   standard. It is retained in this implementation for backward
   compatibility.

  Requirements on types

   The argument of distance_type must be an |stl-InputIterator|,
   |stl-ForwardIterator|, |stl-BidirectionalIterator|, or
   |stl-RandomAccessIterator|. [7][1]

  Preconditions

   None. Distance_type's argument is even permitted to be a singular
   iterator.

  Complexity

   At most amortized constant time. In many cases, a compiler should be able
   to optimize away distance_type entirely.

*stl-distance_type-example*

 template <class |stl-RandomAccessIterator|, class |stl-LessThanComparable|,
           class Distance>
 RandomAccessIterator __lower_bound(RandomAccessIterator first,
                                    RandomAccessIterator last,
                                    const LessThanComparable& value,
                                    Distance*)
     Distance len = last - first;
     Distance half;
     RandomAccessIterator middle;

     while (len > 0) {
         half = len / 2;
         middle = first + half;
         if (*middle < value) {
             first = middle + 1;
             len = len - half - 1;
         } else
             len = half;
     }
     return first;
 }

 template <class |stl-RandomAccessIterator|, class |stl-LessThanComparable|>
 inline RandomAccessIterator |stl-lower_bound|(RandomAccessIterator first,
                                         RandomAccessIterator last,
                                         const LessThanComparable& value) {
     return __lower_bound(first, last, value, distance_type(first));
 }

   The algorithm |stl-lower_bound| (a type of binary search) takes a range of
   iterators, and must declare a local variable whose type is the iterators'
   distance type. It uses distance type, and an auxiliary function, so that
   it can declare that variable. [8][3] Note: this is a simplified example.
   The actual algorithm |stl-lower_bound| can operate on a range of
   |stl-RandomAccessIterator| or a range of |stl-ForwardIterator|. It uses
   both distance_type and |stl-iterator_category|.

  Notes

   [1] Note that distance_type is not defined for |stl-OutputIterator| or for
   |stl-TrivialIterator|. There is no meaningful definition of a distance for either
   of those concepts, so there is no need for a distance type.

   [2] The |stl-iterator_traits| class relies on a C++ feature known as
   partial specialization. Many of today's compilers don't implement the
   complete standard; in particular, many compilers do not support partial
   specialization. If your compiler does not support partial specialization,
   then you will not be able to use |stl-iterator_traits|, and you will have
   to continue using the functions |stl-iterator_category|, distance_type,
   and |stl-value_type|. This is one reason that those functions have not yet
   been removed.

   [3] This use of an auxiliary function is an extremely common idiom:
   distance_type is almost always used with auxiliary functions, simply
   because it returns type information in a form that is hard to use in any
   other way. This is one of the reasons that distance_type is so much less
   convenient than |stl-iterator_traits|.

  See also

   The |stl-iterator_tags| overview, |stl-iterator_traits|,
   |stl-iterator_category|, |stl-value_type|, |stl-output_iterator_tag|,
   |stl-input_iterator_tag|, |stl-forward_iterator_tag|,
   |stl-bidirectional_iterator_tag|, |stl-random_access_iterator_tag|

*stl-value_type*

                                   value_type

   Category: iterators                               Component type: function

  Prototype

   Value_type is overloaded; it is in fact five different functions.

 template <class T, class Distance>
 inline T* value_type(const |stl-input_iterator|<T, Distance>&);

 template <class T, class Distance>
 inline T* value_type(const |stl-forward_iterator|<T, Distance>&);

 template <class T, class Distance>
 inline T* value_type(const |stl-bidirectional_iterator|<T, Distance>&);

 template <class T, class Distance>
 inline T* value_type(const |stl-random_access_iterator|<T, Distance>&);

 template <class T> inline T* value_type(const T*);

  Description

   Value_type is an |stl-iterator_tags| function: it is used to determine the
   value type associated with an iterator. An iterator's value type is the
   type of object returned when the iterator is dereferenced;
   |stl-OutputIterator| do not have value types (|stl-OutputIterator| may
   only be used for storing values, not for accessing values), but
   |stl-InputIterator|, |stl-ForwardIterator|, |stl-BidirectionalIterator|,
   and |stl-RandomAccessIterator| do. [2][1] In some cases, such as an
   algorithm that must declare a local variable that holds a value returned
   from dereferencing an iterator, it is necessary to find out an iterator's
   value type. Accordingly, value_type(Iter) returns (T*) 0, where T is
   Iter's value type.

   Although value_type looks like a single function whose return type depends
   on its argument type, in reality it is a set of functions; the name
   value_type is overloaded. The function value_type must be overloaded for
   every iterator type [3][1].

   In practice, ensuring that value_type is defined requires essentially no
   work at all. It is already defined for pointers, and for the base classes
   |stl-input_iterator|, |stl-forward_iterator|,
   |stl-bidirectional_iterator|, and |stl-random_access_iterator|. If you are
   implementing a new type of forward iterator, for example, you can simply
   derive it from the base class |stl-forward_iterator|; this means that
   value_type (along with |stl-iterator_category| and |stl-distance_type|)
   will automatically be defined for your iterator. These base classes are
   empty: they contain no member functions or member variables, but only type
   information. Using them should therefore incur no overhead.

   Note that, while the function value_type was present in the original STL,
   it is no longer present in the most recent draft C++ standard: it has been
   replaced by the |stl-iterator_traits| class At present both mechanisms are
   supported [4][2], but eventually value_type will be removed.

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h. This function is no longer
   part of the C++ standard, although it was present in early drafts of the
   standard. It is retained in this implementation for backward
   compatibility.

  Requirements on types

   The argument of value_type must be an |stl-InputIterator|,
   |stl-ForwardIterator|, |stl-BidirectionalIterator|, or
   |stl-RandomAccessIterator|. [7][1]

  Preconditions

   None. Value_type's argument is even permitted to be a singular iterator.

  Complexity

   At most amortized constant time. In many cases, a compiler should be able
   to optimize away value_type entirely.

*stl-value_type-example*

   This example uses the |stl-value_type| iterator tag function in order to
   declare a temporary variable of an iterator's value type.

 template <class |stl-ForwardIterator|1, class |stl-ForwardIterator|2, class ValueType>
 inline void __iter_swap(ForwardIterator1 a, ForwardIterator2 b, ValueType*) {
     T tmp = *a;
     *a = *b;
     *b = tmp;
 }

 template <class |stl-ForwardIterator|1, class |stl-ForwardIterator|2>
 inline void iter_swap(ForwardIterator1 a, ForwardIterator2 b) {
     __iter_swap(a, b, |stl-value_type|(a));
 }

  Notes

   [1] Note that distance_type is not defined for |stl-OutputIterator| or for
   |stl-TrivialIterator|. In the case of |stl-OutputIterator|, this is because an
   |stl-OutputIterator| does not have a value type: it is not possible to
   dereference an |stl-OutputIterator| and obtain a value. In the case of
   |stl-TrivialIterator|, this is because the concept was introduced only for
   conceptual clarity, in order to separate the axioms related to an object
   that refers to another object from those related to iteration over a
   range. In fact, the STL does not define any types that are |stl-TrivialIterator|.
   Although built-in C pointers may be |stl-TrivialIterator|, the C type system does
   not allow a distinction between pointers that are |stl-TrivialIterator| and
   pointers that are |stl-RandomAccessIterator| into C arrays. Consequently,
   there is no |stl-TrivialIterator| category tag or iterator base.

   [2] The |stl-iterator_traits| class relies on a C++ feature known as
   partial specialization. Many of today's compilers don't implement the
   complete standard; in particular, many compilers do not support partial
   specialization. If your compiler does not support partial specialization,
   then you will not be able to use |stl-iterator_traits|, and you will have
   to continue using the functions |stl-iterator_category|,
   |stl-distance_type|, and value_type. This is one reason that those
   functions have not yet been removed.

  See also

   The |stl-iterator_tags| overview, |stl-iterator_traits|,
   |stl-iterator_category|, |stl-distance_type|, |stl-output_iterator_tag|,
   |stl-input_iterator_tag|, |stl-forward_iterator_tag|,
   |stl-bidirectional_iterator_tag|, |stl-random_access_iterator_tag|

        ________________________________________________________________________
                                 Iterator tag classes
*stl-input_iterator_tag*

                               input_iterator_tag

   Category: iterators                                   Component type: type

  Description

   Input_iterator_tag is an empty class: it has no member functions, member
   variables, or nested types. It is used solely as a "tag": a representation
   of the |stl-InputIterator| concept within the C++ type system.
   Specifically, it is used as a return value for the function
   |stl-iterator_category|. |stl-iterator_category| takes a single argument,
   an iterator, and returns an object whose type depends on the iterator's
   category. |stl-iterator_category|'s return value is of type
   input_iterator_tag if its argument is an |stl-InputIterator|.

*stl-input_iterator_tag-example*

   See |stl-iterator_category|

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h.

  Template parameters

   None.

  Model of

   |stl-Assignable|

  Type requirements

   None.

  Public base classes

   None.

  Members

   None.

  New Members

   None.

  See also

   |stl-iterator_category|, |stl-iterator_tags|, |stl-iterator_traits|,
   |stl-output_iterator_tag|, |stl-forward_iterator_tag|,
   |stl-bidirectional_iterator_tag|, |stl-random_access_iterator_tag|

*stl-output_iterator_tag*

                              output_iterator_tag

   Category: iterators                                   Component type: type

  Description

   Output_iterator_tag is an empty class: it has no member functions, member
   variables, or nested types. It is used solely as a "tag": a representation
   of the |stl-OutputIterator| concept within the C++ type system.
   Specifically, it is used as a return value for the function
   |stl-iterator_category|. |stl-iterator_category| takes a single argument,
   an iterator, and returns an object whose type depends on the iterator's
   category. |stl-iterator_category|'s return value is of type
   output_iterator_tag if its argument is an |stl-OutputIterator|.

*stl-output_iterator_tag-example*

   See |stl-iterator_category|

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h.

  Template parameters

   None.

  Model of

   |stl-Assignable|

  Type requirements

   None.

  Public base classes

   None.

  Members

   None.

  New Members

   None.

  See also

   |stl-iterator_category|, |stl-iterator_tags|, |stl-iterator_traits|,
   |stl-input_iterator_tag|, |stl-forward_iterator_tag|,
   |stl-bidirectional_iterator_tag|, |stl-random_access_iterator_tag|

*stl-forward_iterator_tag*

                              forward_iterator_tag

   Category: iterators                                   Component type: type

  Description

   Forward_iterator_tag is an empty class: it has no member functions, member
   variables, or nested types. It is used solely as a "tag": a representation
   of the |stl-ForwardIterator| concept within the C++ type system.
   Specifically, it is used as a return value for the function
   |stl-iterator_category|. |stl-iterator_category| takes a single argument,
   an iterator, and returns an object whose type depends on the iterator's
   category. |stl-iterator_category|'s return value is of type
   forward_iterator_tag if its argument is a |stl-ForwardIterator|.

*stl-forward_iterator_tag-example*

   See |stl-iterator_category|

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h.

  Template parameters

   None.

  Model of

   |stl-Assignable|

  Type requirements

   None.

  Public base classes

   None.

  Members

   None.

  New Members

   None.

  See also

   |stl-iterator_category|, |stl-iterator_tags|, |stl-iterator_traits|,
   |stl-output_iterator_tag|, |stl-input_iterator_tag|,
   |stl-bidirectional_iterator_tag|, |stl-random_access_iterator_tag|

*stl-bidirectional_iterator_tag*

                           bidirectional_iterator_tag

   Category: iterators                                   Component type: type

  Description

   Bidirectional_iterator_tag is an empty class: it has no member functions,
   member variables, or nested types. It is used solely as a "tag": a
   representation of the |stl-BidirectionalIterator| concept within the C++
   type system. Specifically, it is used as a return value for the function
   |stl-iterator_category|. |stl-iterator_category| takes a single argument,
   an iterator, and returns an object whose type depends on the iterator's
   category. |stl-iterator_category|'s return value is of type
   bidirectional_iterator_tag if its argument is a
   |stl-BidirectionalIterator|.

*stl-bidirectional_iterator_tag-example*

   See |stl-iterator_category|

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h.

  Template parameters

   None.

  Model of

   |stl-Assignable|

  Type requirements

   None.

  Public base classes

   None.

  Members

   None.

  New Members

   None.

  See also

   |stl-iterator_category|, |stl-iterator_tags|, |stl-iterator_traits|,
   |stl-output_iterator_tag|, |stl-input_iterator_tag|,
   |stl-forward_iterator_tag| |stl-random_access_iterator_tag|

*stl-random_access_iterator_tag*

                           random_access_iterator_tag

   Category: iterators                                   Component type: type

  Description

   Random_access_iterator_tag is an empty class: it has no member functions,
   member variables, or nested types. It is used solely as a "tag": a
   representation of the |stl-RandomAccessIterator| concept within the C++
   type system. Specifically, it is used as a return value for the function
   |stl-iterator_category|. |stl-iterator_category| takes a single argument,
   an iterator, and returns an object whose type depends on the iterator's
   category. |stl-iterator_category|'s return value is of type
   random_access_iterator_tag if its argument is a
   |stl-RandomAccessIterator|.

*stl-random_access_iterator_tag-example*

   See |stl-iterator_category|

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h.

  Template parameters

   None.

  Model of

   |stl-Assignable|

  Type requirements

   None.

  Public base classes

   None.

  Members

   None.

  New Members

   None.

  See also

   |stl-iterator_category|, |stl-iterator_tags|, |stl-iterator_traits|,
   |stl-output_iterator_tag|, |stl-input_iterator_tag|,
   |stl-forward_iterator_tag|, |stl-bidirectional_iterator_tag|


        ________________________________________________________________________
                                Iterator base classes
*stl-input_iterator*

                          input_iterator<T, Distance>

   Category: iterators                                   Component type: type

  Description

   Input_iterator is an iterator base class: it is intended that an iterator
   that is a model of |stl-InputIterator|, and whose value type and distance
   type are T and Distance, may be defined by inheriting from
   input_iterator<T, Distance> [2][1]. Input_iterator is entirely empty: it
   has no member functions, member variables, or nested types. It exists
   solely to simplify the definition of the functions
   |stl-iterator_category|, |stl-distance_type|, and |stl-value_type|.

*stl-input_iterator-example*

 class my_input_iterator : public input_iterator<double>
 {
   ...
 };

   This declares my_input_iterator to be an |stl-InputIterator| whose value
   type is double and whose distance type is ptrdiff_t. If Iter is an object
   of class my_input_iterator, then |stl-iterator_category|(Iter) will return
   |stl-input_iterator_tag|(), |stl-value_type|(Iter) will return (double*)
   0, and |stl-distance_type|(Iter) will return (ptrdiff_t*) 0.

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h. This class is no longer part
   of the C++ standard, although it was present in early drafts of the
   standard. It is retained in this implementation for backward
   compatibility.

  Template parameters

   +------------------------------------------------------+
   | Parameter |         Description          |  Default  |
   |-----------+------------------------------+-----------|
   | T         | The iterator's value type    |           |
   |-----------+------------------------------+-----------|
   | Distance  | The iterator's distance type | ptrdiff_t |
   +------------------------------------------------------+

  Model of

   |stl-Assignable|

  Public base classes

   None

  Type requirements

   The distance type must be a signed integral type.

  Public base classes

   None.

  Members

   None.

  New Members

   None.

  Notes

   [1] It is not required that an |stl-InputIterator| inherit from the base
   input_iterator. It is, however, required that the functions
   |stl-iterator_category|, |stl-distance_type|, and |stl-value_type| be
   defined for every |stl-InputIterator|. (Or, if you are using the
   |stl-iterator_traits| mechanism, that iterator_traits is properly
   specialized for every |stl-InputIterator|.) Since those functions are
   defined for the base input_iterator, the easiest way to ensure that are
   defined for a new iterator class is to derive that class from
   input_iterator and rely on the derived-to-base standard conversion of
   function arguments.

  See also

   The |stl-iterator_tags| overview, |stl-iterator_traits|,
   |stl-iterator_category|, |stl-value_type|, |stl-distance_type|,
   |stl-output_iterator|, |stl-forward_iterator|,
   |stl-bidirectional_iterator|, |stl-random_access_iterator|

*stl-output_iterator*

                                output_iterator

   Category: iterators                                   Component type: type

  Description

   Output_iterator is an iterator base class: it is intended that an iterator
   that is a model of |stl-OutputIterator| may be defined by inheriting from
   output_iterator [2][1]. Output_iterator is entirely empty: it has no
   member functions, member variables, or nested types. It exists solely to
   simplify the definition of the functions |stl-iterator_category|,
   |stl-distance_type|, and |stl-value_type|.

*stl-output_iterator-example*

 class my_output_iterator : public output_iterator
 {
   ...
 };

   This declares my_output_iterator to be an |stl-OutputIterator|. If Iter is
   an object of class my_output_iterator, then |stl-iterator_category|(Iter)
   will return |stl-output_iterator_tag|(), and |stl-distance_type| and
   |stl-value_type| will be undefined for objects of class
   my_output_iterator.

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h. This class is no longer part
   of the C++ standard, although it was present in early drafts of the
   standard. It is retained in this implementation for backward
   compatibility.

  Template parameters

   None. (Note that |stl-OutputIterator| need have neither distance types nor
   value types.)

  Model of

   |stl-Assignable|

  Public base classes

   None

  Type requirements

   None.

  Public base classes

   None.

  Members

   None.

  New Members

   None.

  Notes

   [1] It is not required that an |stl-OutputIterator| inherit from the base
   output_iterator. It is, however, required that the function
   |stl-iterator_category| be defined for every |stl-OutputIterator|. (Or, if
   you are using the |stl-iterator_traits| mechanism, that iterator_traits is
   properly specialized for every |stl-OutputIterator|.) Since it is defined
   for the base output_iterator, the easiest way to ensure that it defined
   for a new type is to derive that class from output_iterator and rely on
   the derived-to-base standard conversion of function arguments.

  See also

   The |stl-iterator_tags| overview, |stl-iterator_traits|,
   |stl-iterator_category|, |stl-value_type|, |stl-distance_type|,
   |stl-input_iterator|, |stl-forward_iterator|,
   |stl-bidirectional_iterator|, |stl-random_access_iterator|

*stl-forward_iterator*

                         forward_iterator<T, Distance>

   Category: iterators                                   Component type: type

  Description

   Forward_iterator is an iterator base class: it is intended that an
   iterator that is a model of |stl-ForwardIterator|, and whose value type
   and distance type are T and Distance, may be defined by inheriting from
   forward_iterator<T, Distance> [2][1]. Forward_iterator is entirely empty:
   it has no member functions, member variables, or nested types. It exists
   solely to simplify the definition of the functions
   |stl-iterator_category|, |stl-distance_type|, and |stl-value_type|.

*stl-forward_iterator-example*

 class my_forward_iterator : public forward_iterator<double>
 {
   ...
 };

   This declares my_forward_iterator to be a |stl-ForwardIterator| whose
   value type is double and whose distance type is ptrdiff_t. If Iter is an
   object of class my_forward_iterator, then |stl-iterator_category|(Iter)
   will return |stl-forward_iterator_tag|(), |stl-value_type|(Iter) will
   return (double*) 0, and |stl-distance_type|(Iter) will return (ptrdiff_t*)
   0.

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h. This class is no longer part
   of the C++ standard, although it was present in early drafts of the
   standard. It is retained in this implementation for backward
   compatibility.

  Template parameters

   +------------------------------------------------------+
   | Parameter |         Description          |  Default  |
   |-----------+------------------------------+-----------|
   | T         | The iterator's value type    |           |
   |-----------+------------------------------+-----------|
   | Distance  | The iterator's distance type | ptrdiff_t |
   +------------------------------------------------------+

  Model of

   |stl-Assignable|

  Public base classes

   None

  Type requirements

   The distance type must be a signed integral type.

  Public base classes

   None.

  Members

   None.

  New Members

   None.

  Notes

   [1] It is not required that a |stl-ForwardIterator| inherit from the base
   forward_iterator. It is, however, required that the functions
   |stl-iterator_category|, |stl-distance_type|, and |stl-value_type| be
   defined for every |stl-ForwardIterator|. (Or, if you are using the
   |stl-iterator_traits| mechanism, that iterator_traits is properly
   specialized for every |stl-ForwardIterator|.) Since those functions are
   defined for the base forward_iterator, the easiest way to ensure that are
   defined for a new type is to derive that class from forward_iterator and
   rely on the derived-to-base standard conversion of function arguments.

  See also

   The |stl-iterator_tags| overview, |stl-iterator_traits|,
   |stl-iterator_category|, |stl-value_type|, |stl-distance_type|,
   |stl-input_iterator|, |stl-output_iterator|, |stl-bidirectional_iterator|,
   |stl-random_access_iterator|

*stl-bidirectional_iterator*

                      bidirectional_iterator<T, Distance>

   Category: iterators                                   Component type: type

  Description

   Bidirectional_iterator is an iterator base class: it is intended that an
   iterator that is a model of |stl-BidirectionalIterator|, and whose value
   type and distance type are T and Distance, may be defined by inheriting
   from bidirectional_iterator<T, Distance> [2][1]. Bidirectional_iterator is
   entirely empty: it has no member functions, member variables, or nested
   types. It exists solely to simplify the definition of the functions
   |stl-iterator_category|, |stl-distance_type|, and |stl-value_type|.

*stl-bidirectional_iterator-example*

 class my_bidirectional_iterator : public bidirectional_iterator<double>
 {
   ...
 };

   This declares my_bidirectional_iterator to be a
   |stl-BidirectionalIterator| whose value type is double and whose distance
   type is ptrdiff_t. If Iter is an object of class
   my_bidirectional_iterator, then |stl-iterator_category|(Iter) will return
   |stl-bidirectional_iterator_tag|(), |stl-value_type|(Iter) will return
   (double*) 0, and |stl-distance_type|(Iter) will return (ptrdiff_t*) 0.

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h. This class is no longer part
   of the C++ standard, although it was present in early drafts of the
   standard. It is retained in this implementation for backward
   compatibility.

  Template parameters

   +------------------------------------------------------+
   | Parameter |         Description          |  Default  |
   |-----------+------------------------------+-----------|
   | T         | The iterator's value type    |           |
   |-----------+------------------------------+-----------|
   | Distance  | The iterator's distance type | ptrdiff_t |
   +------------------------------------------------------+

  Model of

   |stl-Assignable|

  Public base classes

   None

  Type requirements

   The distance type must be a signed integral type.

  Public base classes

   None.

  Members

   None.

  New Members

   None.

  Notes

   [1] It is not required that a |stl-BidirectionalIterator| inherit from the
   base bidirectional_iterator. It is, however, required that the functions
   |stl-iterator_category|, |stl-distance_type|, and |stl-value_type| be
   defined for every |stl-BidirectionalIterator|. (Or, if you are using the
   |stl-iterator_traits| mechanism, that iterator_traits is properly
   specialized for every |stl-BidirectionalIterator|.) Since those functions
   are defined for the base bidirectional_iterator, the easiest way to ensure
   that are defined for a new type is to derive that class from
   bidirectional_iterator and rely on the derived-to-base standard conversion
   of function arguments.

  See also

   The |stl-iterator_tags| overview, |stl-iterator_traits|,
   |stl-iterator_category|, |stl-value_type|, |stl-distance_type|,
   |stl-input_iterator|, |stl-output_iterator|, |stl-forward_iterator|,
   |stl-random_access_iterator|

*stl-random_access_iterator*

                      random_access_iterator<T, Distance>

   Category: iterators                                   Component type: type

  Description

   Random_access_iterator is an iterator base class: it is intended that an
   iterator that is a model of |stl-RandomAccessIterator|, and whose value
   type and distance type are T and Distance, may be defined by inheriting
   from random_access_iterator<T, Distance> [2][1]. Random_access_iterator is
   entirely empty: it has no member functions, member variables, or nested
   types. It exists solely to simplify the definition of the functions
   |stl-iterator_category|, |stl-distance_type|, and |stl-value_type|.

*stl-random_access_iterator-example*

 class my_random_access_iterator : public random_access_iterator<double>
 {
   ...
 };

   This declares my_random_access_iterator to be a |stl-RandomAccessIterator|
   whose value type is double and whose distance type is ptrdiff_t. If Iter
   is an object of class my_random_access_iterator, then
   |stl-iterator_category|(Iter) will return
   |stl-random_access_iterator_tag|(), |stl-value_type|(Iter) will return
   (double*) 0, and |stl-distance_type|(Iter) will return (ptrdiff_t*) 0.

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h. This class is no longer part
   of the C++ standard, although it was present in early drafts of the
   standard. It is retained in this implementation for backward
   compatibility.

  Template parameters

   +------------------------------------------------------+
   | Parameter |         Description          |  Default  |
   |-----------+------------------------------+-----------|
   | T         | The iterator's value type    |           |
   |-----------+------------------------------+-----------|
   | Distance  | The iterator's distance type | ptrdiff_t |
   +------------------------------------------------------+

  Model of

   |stl-Assignable|

  Public base classes

   None

  Type requirements

   The distance type must be a signed integral type.

  Public base classes

   None.

  Members

   None.

  New Members

   None.

  Notes

   [1] It is not required that a |stl-RandomAccessIterator| inherit from the
   base random_access_iterator. It is, however, required that the functions
   |stl-iterator_category|, |stl-distance_type|, and |stl-value_type| be
   defined for every |stl-RandomAccessIterator|. (Or, if you are using the
   |stl-iterator_traits| mechanism, that iterator_traits is properly
   specialized for every |stl-RandomAccessIterator|.) Since those functions
   are defined for the base random_access_iterator, the easiest way to ensure
   that are defined for a new type is to derive that class from
   random_access_iterator and rely on the derived-to-base standard conversion
   of function arguments.

  See also

   The |stl-iterator_tags| overview, |stl-iterator_traits|,
   |stl-iterator_category|, |stl-value_type|, |stl-distance_type|,
   |stl-input_iterator|, |stl-output_iterator|, |stl-forward_iterator|,
   |stl-bidirectional_iterator|




    ----------------------------------------------------------------------------
                                Iterator functions
    ----------------------------------------------------------------------------
*stl-distance*

                                    distance

   Categories: algorithms, iterators                 Component type: function

  Prototype

   Distance is an overloaded name; there are actually two distance functions.

 template <class InputIterator>
 inline |stl-iterator_traits|<InputIterator>::difference_type
 distance(InputIterator first, InputIterator last);

 template <class |stl-InputIterator|, class Distance>
 void distance(InputIterator first, InputIterator last, Distance& n);

  Description

   Finds the distance between first and last, i.e. the number of times that
   first must be incremented until it is equal to last. [2][1] The first
   version of distance, which takes two arguments, simply returns that
   distance; the second version, which takes three arguments and which has a
   return type of void, increments n by that distance.

   The second version of distance was the one defined in the original STL,
   and the first version is the one defined in the draft C++ standard; the
   definition was changed because the older interface was clumsy and
   error-prone. The older interface required the use of a temporary variable,
   and it has semantics that are somewhat nonintuitive: it increments n by
   the distance from first to last, rather than storing that distance in n.
   [3][2]

   Both interfaces are currently supported [4][3], for reasons of backward
   compatibility, but eventually the older version will be removed.

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h.

  Requirements on types

   For the first version:

     * InputIterator is a model of |stl-InputIterator|.

   For the second version:

     * InputIterator is a model of |stl-InputIterator|.
     * Distance is an integral type that is able to represent a distance
       between iterators of type InputIterator.

  Preconditions

     * [first, last) is a valid range, as defined in the |stl-InputIterator|
       requirements.

  Complexity

   Constant time if InputIterator is a model of |stl-RandomAccessIterator|,
   otherwise linear time.

*stl-distance-example*

 int main() {
   |stl-List|<int> L;
   L.push_back(0);
   L.push_back(1);

   assert(distance(L.begin(), L.end()) == L.size());
 }

  Notes

   [1] This is the reason that distance is not defined for
   |stl-OutputIterator|: it is impossible to compare two |stl-OutputIterator|
   for equality.

   [2] Forgetting to initialize n to 0 is a common mistake.

   [3] The new distance interface uses the |stl-iterator_traits| class, which
   relies on a C++ feature known as partial specialization. Many of today's
   compilers don't implement the complete standard; in particular, many
   compilers do not support partial specialization. If your compiler does not
   support partial specialization, then you will not be able to use the newer
   version of distance, or any other STL components that involve
   |stl-iterator_traits|.

  See also

   |stl-distance_type|, |stl-advance|, |stl-InputIterator|,
   |stl-RandomAccessIterator|, |stl-iterator_tags|, |stl-iterator_traits|,
   |stl-Iterators|.

*stl-advance*

                                    advance

   Categories: algorithms, iterators                 Component type: function

  Prototype

 template <class |stl-InputIterator|, class Distance>
 void advance(InputIterator& i, Distance n);

  Description

   Advance(i, n) increments the iterator i by the distance n. If n > 0 it is
   equivalent to executing ++i n times, and if n < 0 it is equivalent to
   executing --i n times. If n == 0, the call has no effect.

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h.

  Requirements on types

     * InputIterator is a model of |stl-InputIterator|.
     * Distance is an integral type that is convertible to InputIterator's
       distance type.

  Preconditions

     * i is nonsingular.
     * Every iterator between i and i+n (inclusive) is nonsingular.
     * If InputIterator is a model of |stl-InputIterator| or
       |stl-ForwardIterator|, then n must be nonnegative. If InputIterator is
       a model of |stl-BidirectionalIterator| or |stl-RandomAccessIterator|,
       then this precondition does not apply.

  Complexity

   Constant time if InputIterator is a model of |stl-RandomAccessIterator|,
   otherwise linear time.

*stl-advance-example*

 |stl-List|<int> L;
 L.push_back(0);
 L.push_back(1);

 |stl-List|<int>::iterator i = L.begin();
 advance(i, 2);
 assert(i == L.end());

  See also

   |stl-distance|, |stl-InputIterator|, |stl-BidirectionalIterator|,
   |stl-RandomAccessIterator|, |stl-iterator_traits|, |stl-Iterators|.



    ----------------------------------------------------------------------------
                                 Iterator classes
    ----------------------------------------------------------------------------
*stl-istream_iterator*

                         istream_iterator<T, Distance>

   Category: iterators                                   Component type: type

  Description

   An istream_iterator is an |stl-InputIterator| that performs formatted
   input of objects of type T from a particular istream. When end of stream
   is reached, the istream_iterator takes on a special end of stream value,
   which is a past-the-end iterator. Note that all of the restrictions of an
   |stl-InputIterator| must be obeyed, including the restrictions on the
   ordering of operator* and operator++ operations.

*stl-istream_iterator-example*

   Fill a |stl-Vector| with values read from standard input.

 |stl-Vector|<int> V;
 |stl-copy|(istream_iterator<int>(cin), istream_iterator<int>(),
      |stl-back_insert_iterator|(V));

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                  Description                   |  Default  |
   |-----------+------------------------------------------------+-----------|
   | T         | The istream_iterator's value type. Operator*   |           |
   |           | returns a const T&.                            |           |
   |-----------+------------------------------------------------+-----------|
   | Distance  | The istream_iterator's distance type.          | ptrdiff_t |
   +------------------------------------------------------------------------+

  Model of

   |stl-InputIterator|

  Type requirements

   The value type T must be a type such that cin >> T is a valid expression.

   The value type T must be a model of |stl-DefaultConstructible|.

   The distance type must, as described in the |stl-InputIterator|
   requirements, be a signed integral type.

  Public base classes

   None.

  Members

   +------------------------------------------------------------------------+
   |            Member             |    Where defined    |   Description    |
   |-------------------------------+---------------------+------------------|
   | istream_iterator()            | istream_iterator    | See below.       |
   |-------------------------------+---------------------+------------------|
   | istream_iterator(istream&)    | istream_iterator    | See below.       |
   |-------------------------------+---------------------+------------------|
   | istream_iterator(const        ||stl-TrivialIterator|| The copy         |
   | istream_iterator&)            |                     | constructor      |
   |-------------------------------+---------------------+------------------|
   | istream_iterator&             ||stl-TrivialIterator|| The assignment   |
   | operator=(const               |                     | operator         |
   | istream_iterator&)            |                     |                  |
   |-------------------------------+---------------------+------------------|
   | const T& operator*() const    | |stl-InputIterator| | Returns the next |
   |                               |                     | object in the    |
   |                               |                     | stream.          |
   |-------------------------------+---------------------+------------------|
   | istream_iterator&             | |stl-InputIterator| | Preincrement.    |
   | operator++()                  |                     |                  |
   |-------------------------------+---------------------+------------------|
   | istream_iterator&             | |stl-InputIterator| | Postincrement.   |
   | operator++(int)               |                     |                  |
   |-------------------------------+---------------------+------------------|
   | bool operator==(const         ||stl-TrivialIterator|| The equality     |
   | istream_iterator&, const      |                     | operator. This   |
   | istream_iterator&)            |                     | is a global      |
   |                               |                     | function, not a  |
   |                               |                     | member function. |
   |-------------------------------+---------------------+------------------|
   | input_iterator_tag            | |stl-iterator_tags| | Returns the      |
   | iterator_category(const       |                     | iterator's       |
   | istream_iterator&)            |                     | category.        |
   |-------------------------------+---------------------+------------------|
   | T* value_type(const           | |stl-iterator_tags| | Returns the      |
   | istream_iterator&)            |                     | iterator's value |
   |                               |                     | type.            |
   |-------------------------------+---------------------+------------------|
   | Distance* distance_type(const | |stl-iterator_tags| | Returns the      |
   | istream_iterator&)            |                     | iterator's       |
   |                               |                     | distance type. < |
   +------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-InputIterator| requirements, but
   are specific to istream_iterator.

   +------------------------------------------------------------------------+
   |           Function           |               Description               |
   |------------------------------+-----------------------------------------|
   | istream_iterator()           | The default constructor: Constructs an  |
   |                              | end-of-stream iterator. This is a       |
   |                              | past-the-end iterator, and it is useful |
   |                              | when constructing a "range".            |
   |------------------------------+-----------------------------------------|
   | istream_iterator(istream& s) | Creates an istream_iterator that reads  |
   |                              | values from the input stream s. When s  |
   |                              | reaches end of stream, this iterator    |
   |                              | will compare equal to an end-of-stream  |
   |                              | iterator created using the default      |
   |                              | constructor.                            |
   +------------------------------------------------------------------------+

  See also

   |stl-ostream_iterator|, |stl-InputIterator|, |stl-OutputIterator|.

*stl-ostream_iterator*

                              ostream_iterator<T>

   Category: iterators                                   Component type: type

  Description

   An ostream_iterator is an |stl-OutputIterator| that performs formatted
   output of objects of type T to a particular ostream. Note that all of the
   restrictions of an |stl-OutputIterator| must be obeyed, including the
   restrictions on the ordering of operator* and operator++ operations.

*stl-ostream_iterator-example*

   Copy the elements of a |stl-Vector| to the standard output, one per line.

 |stl-Vector|<int> V;
 // ...
 |stl-copy|(V.begin(), V.end(), ostream_iterator<int>(cout, "\n"));

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | T         | The type of object that will be written to the   |         |
   |           | ostream. The set of value types of an            |         |
   |           | ostream_iterator consists of a single type, T.   |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-OutputIterator|.

  Type requirements

   T must be a type such that cout << T is a valid expression.

  Public base classes

   None.

  Members

   +--------------------------------------------------------------------------+
   |          Member           |    Where defined    |      Description       |
   |---------------------------+---------------------+------------------------|
   |ostream_iterator(ostream&) |ostream_iterator     |See below.              |
   |---------------------------+---------------------+------------------------|
   |ostream_iterator(ostream&, |ostream_iterator     |See below.              |
   |const char* s)             |                     |                        |
   |---------------------------+---------------------+------------------------|
   |ostream_iterator(const     ||stl-OutputIterator| |The copy constructor    |
   |ostream_iterator&)         |                     |                        |
   |---------------------------+---------------------+------------------------|
   |ostream_iterator&          ||stl-OutputIterator| |The assignment operator |
   |operator=(const            |                     |                        |
   |ostream_iterator&)         |                     |                        |
   |---------------------------+---------------------+------------------------|
   |ostream_iterator&          ||stl-OutputIterator| |Used to implement the   |
   |operator=(const T&)        |                     ||stl-OutputIterator|    |
   |                           |                     |requirement *i = t.     |
   |                           |                     |[4][1]                  |
   |---------------------------+---------------------+------------------------|
   |ostream_iterator&          ||stl-OutputIterator| |Used to implement the   |
   |operator*()                |                     ||stl-OutputIterator|    |
   |                           |                     |requirement *i = t.     |
   |                           |                     |[5][1]                  |
   |---------------------------+---------------------+------------------------|
   |ostream_iterator&          ||stl-OutputIterator| |Preincrement            |
   |operator++()               |                     |                        |
   |---------------------------+---------------------+------------------------|
   |ostream_iterator&          ||stl-OutputIterator| |Postincrement           |
   |operator++(int)            |                     |                        |
   |---------------------------+---------------------+------------------------|
   |output_iterator_tag        ||stl-iterator_tags|  |Returns the iterator's  |
   |iterator_category(const    |                     |category.               |
   |ostream_iterator&)         |                     |                        |
   +--------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-OutputIterator| requirements,
   but are specific to ostream_iterator.

   +------------------------------------------------------------------------+
   |              Function              |            Description            |
   |------------------------------------+-----------------------------------|
   | ostream_iterator(ostream& s)       | Creates an ostream_iterator such  |
   |                                    | that assignment of t through it   |
   |                                    | is equivalent to s << t.          |
   |------------------------------------+-----------------------------------|
   | ostream_iterator(ostream& s, const | Creates an ostream_iterator such  |
   | char* delim)                       | that assignment of t through it   |
   |                                    | is equivalent to s << t << delim. |
   +------------------------------------------------------------------------+

  Notes

   [1] Note how assignment through an ostream_iterator is implemented. In
   general, unary operator* must be defined so that it returns a proxy
   object, where the proxy object defines operator= to perform the output
   operation. In this case, for the sake of simplicity, the proxy object is
   the ostream_iterator itself. That is, *i simply returns i, and *i = t is
   equivalent to i = t. You should not, however, rely on this behavior. It is
   an implementation detail, and it is not guaranteed to remain the same in
   future versions.

  See also

   |stl-istream_iterator|, |stl-OutputIterator|, |stl-InputIterator|.

*stl-front_insert_iterator*

                 front_insert_iterator<FrontInsertionSequence>

   Categories: iterators, adaptors                       Component type: type

  Description

   Front_insert_iterator is an iterator adaptor that functions as an
   |stl-OutputIterator|: assignment through a front_insert_iterator inserts
   an object before the first element of a |stl-FrontInsertionSequence|.
   [2][1] [3][2]

*stl-front_insert_iterator-example*

 |stl-List|<int> L;
 L.push_front(3);
 front_insert_iterator<|stl-List|<int> > ii(L);
 *ii++ = 0;
 *ii++ = 1;
 *ii++ = 2;
 |stl-copy|(L.begin(), L.end(), |stl-ostream_iterator|<int>(cout, " "));
 // The values that are printed are 2 1 0 3

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h.

  Template parameters

   +------------------------------------------------------------------------+
   |       Parameter        |             Description             | Default |
   |------------------------+-------------------------------------+---------|
   | FrontInsertionSequence | The type of                         |         |
   |                        | |stl-FrontInsertionSequence| into   |         |
   |                        | which values will be inserted.      |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-OutputIterator|. A front insert iterator's set of value types (as
   defined in the |stl-OutputIterator| requirements) consists of a single
   type: |stl-FrontInsertionSequence|::value_type.

  Type requirements

   The template parameter FrontInsertionSequence must be a
   |stl-FrontInsertionSequence|.

  Public base classes

   None.

  Members

+---------------------------------------------------------------------------------------------------+
|                       Member                       |    Where defined     |      Description      |
|----------------------------------------------------+----------------------+-----------------------|
|front_insert_iterator(FrontInsertionSequence&)      |front_insert_iterator |See below.             |
|----------------------------------------------------+----------------------+-----------------------|
|front_insert_iterator(const front_insert_iterator&) ||stl-TrivialIterator| |The copy constructor   |
|----------------------------------------------------+----------------------+-----------------------|
|front_insert_iterator&                              ||stl-TrivialIterator| |The assignment operator|
|operator=(const front_insert_iterator&)             |                      |                       |
|----------------------------------------------------+----------------------+-----------------------|
|front_insert_iterator& operator*()                  ||stl-OutputIterator|  |Used to implement the  |
|                                                    |                      ||stl-OutputIterator|   |
|                                                    |                      |expression *i = x.     |
|                                                    |                      |[6][3]                 |
|----------------------------------------------------+----------------------+-----------------------|
|front_insert_iterator&                              ||stl-OutputIterator|  |Used to implement the  |
|operator=(const FrontInsertionSequence::value_type&)|                      ||stl-OutputIterator|   |
|                                                    |                      |expression *i = x.     |
|                                                    |                      |[7][3]                 |
|----------------------------------------------------+----------------------+-----------------------|
|front_insert_iterator& operator++()                 ||stl-OutputIterator|  |Preincrement.          |
|----------------------------------------------------+----------------------+-----------------------|
|front_insert_iterator& operator++(int)              ||stl-OutputIterator|  |Postincrement.         |
|----------------------------------------------------+----------------------+-----------------------|
|output_iterator_tag                                 ||stl-iterator_tags|   |Returns the iterator's |
|iterator_category(const front_insert_iterator&)     |                      |category. This is a    |
|                                                    |                      |global function, not a |
|                                                    |                      |member.                |
|----------------------------------------------------+----------------------+-----------------------|
|template<class FrontInsertionSequence>              |front_insert_iterator |See below.             |
|front_insert_iterator<FrontInsertionSequence>       |                      |                       |
|front_inserter(FrontInsertionSequence& S)           |                      |                       |
+---------------------------------------------------------------------------------------------------+

  New members.

   These members are not defined in the |stl-OutputIterator| requirements,
   but are specific to front_insert_iterator.

+---------------------------------------------------------------------------------------------------+
|                   Member                    |                     Description                     |
|---------------------------------------------+-----------------------------------------------------|
|front_insert_iterator(FrontInsertionSequence&|Constructs a front_insert_iterator that inserts      |
|S)                                           |objects before the first element of S.               |
|---------------------------------------------+-----------------------------------------------------|
|template<class FrontInsertionSequence>       |Equivalent to                                        |
|front_insert_iterator<FrontInsertionSequence>|front_insert_iterator<FrontInsertionSequence>(S).    |
|front_inserter(FrontInsertionSequence& S);   |[8][4] This is a global function, not a member       |
|                                             |function.                                            |
+---------------------------------------------------------------------------------------------------+

  Notes

   [1] Note the difference between assignment through a
   |stl-FrontInsertionSequence|::iterator and assignment through an
   front_insert_iterator<|stl-FrontInsertionSequence|>. If i is a valid
   |stl-FrontInsertionSequence|::iterator, then it points to some particular
   element in the |stl-FrontInsertionSequence|; the expression *i = t
   replaces that element with t, and does not change the total number of
   elements in the sequence. If ii is a valid
   front_insert_iterator<|stl-FrontInsertionSequence|>, however, then the
   expression *ii = t is equivalent, for some |stl-FrontInsertionSequence|
   seq, to the expression seq.push_front(t). That is, it does not overwrite
   any of seq's elements and it does change seq's size.

   [2] Note the difference between a front_insert_iterator and an
   |stl-insert_iterator|. It may seem that a front_insert_iterator is the
   same as an |stl-insert_iterator| constructed with an insertion point that
   is the beginning of a sequence. In fact, though, there is a very important
   difference: every assignment through a front_insert_iterator corresponds
   to an insertion before the first element of the sequence. If you are
   inserting elements at the beginning of a sequence using an
   insert_iterator, then the elements will appear in the order in which they
   were inserted. If, however, you are inserting elements at the beginning of
   a sequence using a front_insert_iterator, then the elements will appear in
   the reverse of the order in which they were inserted.

   [3] Note how assignment through an front_insert_iterator is implemented.
   In general, unary operator* must be defined so that it returns a proxy
   object, where the proxy object defines operator= to perform the insert
   operation. In this case, for the sake of simplicity, the proxy object is
   the front_insert_iterator itself. That is, *i simply returns i, and *i = t
   is equivalent to i = t. You should not, however, rely on this behavior. It
   is an implementation detail, and it is not guaranteed to remain the same
   in future versions.

   [4] This function exists solely for the sake of convenience: since it is a
   non-member function, the template parameters may be inferred and the type
   of the front_insert_iterator need not be declared explicitly. One easy way
   to reverse a range and insert it at the beginning of a
   |stl-FrontInsertionSequence| S, for example, is |stl-copy|(first, last,
   front_inserter(S)).

  See also

   |stl-insert_iterator|, |stl-back_insert_iterator|, |stl-OutputIterator|,
   |stl-Sequence|, |stl-FrontInsertionSequence|, |stl-Iterators|

*stl-back_insert_iterator*

                  back_insert_iterator<BackInsertionSequence>

   Categories: iterators, adaptors                       Component type: type

  Description

   Back_insert_iterator is an iterator adaptor that functions as an
   |stl-OutputIterator|: assignment through a back_insert_iterator inserts an
   object after the last element of a |stl-BackInsertionSequence|. [2][1]

*stl-back_insert_iterator-example*

 |stl-List|<int> L;
 L.push_front(3);
 back_insert_iterator<|stl-List|<int> > ii(L);
 *ii++ = 0;
 *ii++ = 1;
 *ii++ = 2;
 |stl-copy|(L.begin(), L.end(), |stl-ostream_iterator|<int>(cout, " "));
 // The values that are printed are 3 0 1 2

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h.

  Template parameters

   +------------------------------------------------------------------------+
   |       Parameter       |             Description              | Default |
   |-----------------------+--------------------------------------+---------|
   | BackInsertionSequence | The type of                          |         |
   |                       | |stl-BackInsertionSequence| into     |         |
   |                       | which values will be inserted.       |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-OutputIterator|. An insert iterator's set of value types (as defined
   in the |stl-OutputIterator| requirements) consists of a single type:
   |stl-BackInsertionSequence|::value_type.

  Type requirements

   The template parameter BackInsertionSequence must be a
   |stl-BackInsertionSequence|.

  Public base classes

   None.

  Members

+-------------------------------------------------------------------------------------------------+
|                      Member                       |    Where defined    |      Description      |
|---------------------------------------------------+---------------------+-----------------------|
|back_insert_iterator(BackInsertionSequence&)       |back_insert_iterator |See below.             |
|---------------------------------------------------+---------------------+-----------------------|
|back_insert_iterator(const back_insert_iterator&)  ||stl-TrivialIterator||The copy constructor   |
|---------------------------------------------------+---------------------+-----------------------|
|back_insert_iterator&                              ||stl-TrivialIterator||The assignment operator|
|operator=(const back_insert_iterator&)             |                     |                       |
|---------------------------------------------------+---------------------+-----------------------|
|back_insert_iterator& operator*()                  ||stl-OutputIterator| |Used to implement the  |
|                                                   |                     ||stl-OutputIterator|   |
|                                                   |                     |expression *i = x.     |
|                                                   |                     |[5][2]                 |
|---------------------------------------------------+---------------------+-----------------------|
|back_insert_iterator&                              ||stl-OutputIterator| |Used to implement the  |
|operator=(const BackInsertionSequence::value_type&)|                     ||stl-OutputIterator|   |
|                                                   |                     |expression *i = x.     |
|                                                   |                     |[6][2]                 |
|---------------------------------------------------+---------------------+-----------------------|
|back_insert_iterator& operator++()                 ||stl-OutputIterator| |Preincrement.          |
|---------------------------------------------------+---------------------+-----------------------|
|back_insert_iterator& operator++(int)              ||stl-OutputIterator| |Postincrement.         |
|---------------------------------------------------+---------------------+-----------------------|
|output_iterator_tag                                ||stl-iterator_tags|  |Returns the iterator's |
|iterator_category(const back_insert_iterator&)     |                     |category. This is a    |
|                                                   |                     |global function, not a |
|                                                   |                     |member.                |
|---------------------------------------------------+---------------------+-----------------------|
|template<class BackInsertionSequence>              |back_insert_iterator |See below.             |
|back_insert_iterator<BackInsertionSequence>        |                     |                       |
|back_inserter(BackInsertionSequence& S)            |                     |                       |
+-------------------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-OutputIterator| requirements,
   but are specific to back_insert_iterator.

+-----------------------------------------------------------------------------------------------+
|              Member function              |                    Description                    |
|-------------------------------------------+---------------------------------------------------|
|back_insert_iterator(BackInsertionSequence&|Constructs a back_insert_iterator that inserts     |
|S)                                         |objects after the last element of S. (That is, it  |
|                                           |inserts objects just before S's past-the-end       |
|                                           |iterator.)                                         |
|-------------------------------------------+---------------------------------------------------|
|template<class BackInsertionSequence>      |Equivalent to                                      |
|back_insert_iterator<BackInsertionSequence>|back_insert_iterator<BackInsertionSequence>(S).    |
|back_inserter(BackInsertionSequence& S);   |[7][3] This is a global function, not a member     |
|                                           |function.                                          |
+-----------------------------------------------------------------------------------------------+

  Notes

   [1] Note the difference between assignment through a
   |stl-BackInsertionSequence|::iterator and assignment through a
   back_insert_iterator<|stl-BackInsertionSequence|>. If i is a valid
   |stl-BackInsertionSequence|::iterator, then it points to some particular
   element in the |stl-BackInsertionSequence|; the expression *i = t replaces
   that element with t, and does not change the total number of elements in
   the |stl-BackInsertionSequence|. If ii is a valid
   back_insert_iterator<|stl-BackInsertionSequence|>, however, then the
   expression *ii = t is equivalent, to the expression seq.push_back(t). That
   is, it does not overwrite any of seq's elements and it does change seq's
   size.

   [2] Note how assignment through a back_insert_iterator is implemented. In
   general, unary operator* must be defined so that it returns a proxy
   object, where the proxy object defines operator= to perform the insert
   operation. In this case, for the sake of simplicity, the proxy object is
   the back_insert_iterator itself. That is, *i simply returns i, and *i = t
   is equivalent to i = t. You should not, however, rely on this behavior. It
   is an implementation detail, and it is not guaranteed to remain the same
   in future versions.

   [3] This function exists solely for the sake of convenience: since it is a
   non-member function, the template parameters may be inferred and the type
   of the back_insert_iterator need not be declared explicitly. One easy way
   to reverse a range and insert it at the end of a
   |stl-BackInsertionSequence| S, for example, is |stl-reverse_copy|(first,
   last, back_inserter(S)).

  See also

   |stl-insert_iterator|, |stl-front_insert_iterator|, |stl-OutputIterator|,
   |stl-BackInsertionSequence|, |stl-Sequence|, |stl-Iterators|

*stl-insert_iterator*

                           insert_iterator<Container>

   Categories: iterators, adaptors                       Component type: type

  Description

   Insert_iterator is an iterator adaptor that functions as an
   |stl-OutputIterator|: assignment through an insert_iterator inserts an
   object into a |stl-Container|. Specifically, if ii is an insert_iterator,
   then ii keeps track of a |stl-Container| c and an insertion point p; the
   expression *ii = x performs the insertion c.insert(p, x). [2][1]

   There are two different |stl-Container| concepts that define this
   expression: |stl-Sequence|, and |stl-SortedAssociativeContainer|. Both
   concepts define insertion into a container by means of c.insert(p, x), but
   the semantics of this expression is very different in the two cases.

   For a |stl-Sequence| S, the expression S.insert(p, x) means to insert the
   value x immediately before the iterator p. That is, the two-argument
   version of insert allows you to control the location at which the new
   element will be inserted. For a |stl-SortedAssociativeContainer|, however,
   no such control is possible: the elements in a
   |stl-SortedAssociativeContainer| always appear in ascending order of keys.
   |stl-SortedAssociativeContainer| define the two-argument version of insert
   as an optimization. The first argument is only a hint: it points to the
   location where the search will begin.

   If you assign through an insert_iterator several times, then you will be
   inserting several elements into the underlying container. In the case of a
   |stl-Sequence|, they will appear at a particular location in the
   underlying sequence, in the order in which they were inserted: one of the
   arguments to insert_iterator's constructor is an iterator p, and the new
   range will be inserted immediately before p.

   In the case of a |stl-SortedAssociativeContainer|, however, the iterator
   in the insert_iterator's constructor is almost irrelevant. The new
   elements will not necessarily form a contiguous range; they will appear in
   the appropriate location in the container, in ascending order by key. The
   order in which they are inserted only affects efficiency: inserting an
   already-sorted range into a |stl-SortedAssociativeContainer| is an O(N)
   operation.

*stl-insert_iterator-example*

   Insert a range of elements into a |stl-List|.

 |stl-List|<int> L;
 L.push_front(3);
 insert_iterator<|stl-List|<int> > ii(L, L.begin());
 *ii++ = 0;
 *ii++ = 1;
 *ii++ = 2;
 |stl-copy|(L.begin(), L.end(), |stl-ostream_iterator|<int>(cout, " "));
 // The values that are printed are 0 1 2 3.

   Merge two sorted lists, inserting the resulting range into a |stl-set|.
   Note that a |stl-set| never contains duplicate elements.

 int main()
 {
   const int N = 6;

   int A1[N] = {1, 3, 5, 7, 9, 11};
   int A2[N] = {1, 2, 3, 4, 5, 6};
   |stl-set|<int> result;

   |stl-merge|(A1, A1 + N, A2, A2 + N,
         inserter(result, result.begin()));

   |stl-copy|(result.begin(), result.end(), |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;

   // The output is "1 2 3 4 5 6 7 9 11".
 }

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | Container | The type of Container into which values will be  |         |
   |           | inserted.                                        |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-OutputIterator|. An insert iterator's set of value types (as defined
   in the |stl-OutputIterator| requirements) consists of a single type:
   |stl-Container|::value_type.

  Type requirements

     * The template parameter Container is a model of |stl-Container|.
     * Container is variable-sized, as described in the |stl-Container|
       requirements.
     * Container has a two-argument insert member function. Specifically, if
       c is an object of type Container, p is an object of type
       Container::iterator and v is an object of type Container::value_type,
       then c.insert(p, v) must be a valid expression.

  Public base classes

   None.

  Members

+-----------------------------------------------------------------------------------+
|               Member                |    Where defined    |      Description      |
|-------------------------------------+---------------------+-----------------------|
|insert_iterator(Container&,          |insert_iterator      |See below.             |
|Container::iterator)                 |                     |                       |
|-------------------------------------+---------------------+-----------------------|
|insert_iterator(const                ||stl-TrivialIterator||The copy constructor   |
|insert_iterator&)                    |                     |                       |
|-------------------------------------+---------------------+-----------------------|
|insert_iterator& operator=(const     ||stl-TrivialIterator||The assignment operator|
|insert_iterator&)                    |                     |                       |
|-------------------------------------+---------------------+-----------------------|
|insert_iterator& operator*()         ||stl-OutputIterator| |Used to implement the  |
|                                     |                     ||stl-OutputIterator|   |
|                                     |                     |expression *i = x.     |
|                                     |                     |[5][2]                 |
|-------------------------------------+---------------------+-----------------------|
|insert_iterator& operator=(const     ||stl-OutputIterator| |Used to implement the  |
|Container::value_type&)              |                     ||stl-OutputIterator|   |
|                                     |                     |expression *i = x.     |
|                                     |                     |[6][2]                 |
|-------------------------------------+---------------------+-----------------------|
|insert_iterator& operator++()        ||stl-OutputIterator| |Preincrement.          |
|-------------------------------------+---------------------+-----------------------|
|insert_iterator& operator++(int)     ||stl-OutputIterator| |Postincrement.         |
|-------------------------------------+---------------------+-----------------------|
|output_iterator_tag                  ||stl-iterator_tags|  |Returns the iterator's |
|iterator_category(const              |                     |category. This is a    |
|insert_iterator&)                    |                     |global function, not a |
|                                     |                     |member.                |
|-------------------------------------+---------------------+-----------------------|
|template<class Container, class Iter)|insert_iterator      |See below.             |
|insert_iterator<Container>           |                     |                       |
|inserter(Container& C, Iter i);      |                     |                       |
+-----------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-OutputIterator| requirements,
   but are specific to insert_iterator.

   +-------------------------------------------------------------------------+
   |               Member                |            Description            |
   |-------------------------------------+-----------------------------------|
   |insert_iterator(Container& C,        |Constructs an insert_iterator that |
   |Container::iterator i)               |inserts objects in C. If Container |
   |                                     |is a |stl-Sequence|, then each     |
   |                                     |object will be inserted immediately|
   |                                     |before the element pointed to by i.|
   |                                     |If C is a                          |
   |                                     ||stl-SortedAssociativeContainer|,  |
   |                                     |then the first insertion will use i|
   |                                     |as a hint for beginning the search.|
   |                                     |The iterator i must be a           |
   |                                     |dereferenceable or past-the-end    |
   |                                     |iterator in C.                     |
   |-------------------------------------+-----------------------------------|
   |template<class Container, class Iter)|Equivalent to                      |
   |insert_iterator<Container>           |insert_iterator<Container>(C, i).  |
   |inserter(Container& C, Iter i);      |[7][2] This is a global function,  |
   |                                     |not a member function.             |
   +-------------------------------------------------------------------------+

  Notes

   [1] Note the difference between assignment through a
   |stl-Container|::iterator and assignment through an
   insert_iterator<|stl-Container|>. If i is a valid
   |stl-Sequence|::iterator, then it points to some particular element in the
   |stl-Container|; the expression *i = t replaces that element with t, and
   does not change the total number of elements in the |stl-Container|. If ii
   is a valid insert_iterator<|stl-Container|>, however, then the expression
   *ii = t is equivalent, for some |stl-Container| c and some valid
   |stl-Container|::iterator j, to the expression c.insert(j, t). That is, it
   does not overwrite any of c's elements and it does change c's size.

   [2] Note how assignment through an insert_iterator is implemented. In
   general, unary operator* must be defined so that it returns a proxy
   object, where the proxy object defines operator= to perform the insert
   operation. In this case, for the sake of simplicity, the proxy object is
   the insert_iterator itself. That is, *i simply returns i, and *i = t is
   equivalent to i = t. You should not, however, rely on this behavior. It is
   an implementation detail, and it is not guaranteed to remain the same in
   future versions.

   [3] This function exists solely for the sake of convenience: since it is a
   non-member function, the template parameters may be inferred and the type
   of the insert_iterator need not be declared explicitly. One easy way to
   reverse a range and insert it into a |stl-Sequence| S, for example, is
   |stl-reverse_copy|(first, last, inserter(S, S.begin())).

  See also

   |stl-front_insert_iterator|, |stl-back_insert_iterator|,
   |stl-OutputIterator|, |stl-Sequence|, |stl-Iterators|

*stl-ReverseIterator*

         reverse_iterator<RandomAccessIterator, T, Reference, Distance>

   Categories: iterators, adaptors                       Component type: type

  Description

   Reverse_iterator is an iterator adaptor that enables backwards traversal
   of a range. Operator++ applied to an object of class
   reverse_iterator<|stl-RandomAccessIterator|> means the same thing as
   operator-- applied to an object of class |stl-RandomAccessIterator|. There
   are two different reverse iterator adaptors: the class reverse_iterator
   has a template argument that is a |stl-RandomAccessIterator|, and the
   class |stl-ReverseBidirectionalIterator| has a template argument that is a
   |stl-BidirectionalIterator|. [2][1]

*stl-ReverseIterator-example*

 template <class T>
 void forw(const |stl-Vector|<T>& V)
 {
    vector<T>::iterator first = V.begin();
    vector<T>::iterator last = V.end();
    while (first != last)
       cout << *first++ << endl;
 }

 template <class T>
 void rev(const |stl-Vector|<T>& V)
 {
    typedef reverse_iterator<vector<T>::iterator,
                             T,
                             vector<T>::reference_type,
                             vector<T>::difference_type>
            reverse_iterator; [3][2]
    reverse_iterator rfirst(V.end());
    reverse_iterator rlast(V.begin());

    while (rfirst != rlast)
       cout << *rfirst++ << endl;
 }

   In the function forw, the elements are printed in the order *first,
   *(first+1), ..., *(last-1). In the function rev, they are printed in the
   order *(last - 1), *(last-2), ..., *first. [4][3]

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h.

  Template parameters

   +------------------------------------------------------------------------+
   |      Parameter       |             Description             |  Default  |
   |----------------------+-------------------------------------+-----------|
   | RandomAccessIterator | The base iterator class.            |           |
   |                      | Incrementing an object of class     |           |
   |                      | reverse_iterator<Iterator>          |           |
   |                      | corresponds to decrementing an      |           |
   |                      | object of class Iterator.           |           |
   |----------------------+-------------------------------------+-----------|
   | T                    | The reverse iterator's value type.  |           |
   |                      | This should always be the same as   |           |
   |                      | the base iterator's value type.     |           |
   |----------------------+-------------------------------------+-----------|
   | Reference            | The reverse iterator's reference    | T&        |
   |                      | type. This should always be the     |           |
   |                      | same as the base iterator's         |           |
   |                      | reference type.                     |           |
   |----------------------+-------------------------------------+-----------|
   | Distance             | The reverse iterator's distance     | ptrdiff_t |
   |                      | type. This should always be the     |           |
   |                      | same as the base iterator's         |           |
   |                      | distance type.                      |           |
   +------------------------------------------------------------------------+

  Model of

   |stl-RandomAccessIterator|

  Type requirements

   The base iterator type (that is, the template parameter
   RandomAccessIterator) must be a |stl-RandomAccessIterator|. The
   reverse_iterator's value type, reference type, and distance type (that is,
   the template parameters T, Reference, and Distance, respectively) must be
   the same as the base iterator's value type, reference type, and distance
   type.

  Public base classes

   None.

  Members

+-------------------------------------------------------------------------------------+
|                Member                 |       Where defined        |  Description   |
|---------------------------------------+----------------------------+----------------|
|self                                   |reverse_iterator            |See below       |
|---------------------------------------+----------------------------+----------------|
|reverse_iterator()                     ||stl-TrivialIterator|       |The default     |
|                                       |                            |constructor     |
|---------------------------------------+----------------------------+----------------|
|reverse_iterator(const                 ||stl-TrivialIterator|       |The copy        |
|reverse_iterator& x)                   |                            |constructor     |
|---------------------------------------+----------------------------+----------------|
|reverse_iterator& operator=(const      ||stl-TrivialIterator|       |The assignment  |
|reverse_iterator& x)                   |                            |operator        |
|---------------------------------------+----------------------------+----------------|
|reverse_iterator(RandomAccessIterator  |reverse_iterator            |See below.      |
|x)                                     |                            |                |
|---------------------------------------+----------------------------+----------------|
|RandomAccessIterator base()            |reverse_iterator            |See below.      |
|---------------------------------------+----------------------------+----------------|
|Reference operator*() const            ||stl-TrivialIterator|       |The dereference |
|                                       |                            |operator        |
|---------------------------------------+----------------------------+----------------|
|reverse_iterator& operator++()         ||stl-ForwardIterator|       |Preincrement    |
|---------------------------------------+----------------------------+----------------|
|reverse_iterator operator++(int)       ||stl-ForwardIterator|       |Postincrement   |
|---------------------------------------+----------------------------+----------------|
|reverse_iterator& operator--()         ||stl-BidirectionalIterator| |Predecrement    |
|---------------------------------------+----------------------------+----------------|
|reverse_iterator operator--(int)       ||stl-BidirectionalIterator| |Postdecrement   |
|---------------------------------------+----------------------------+----------------|
|reverse_iterator operator+(Distance)   ||stl-RandomAccessIterator|  |Iterator        |
|                                       |                            |addition        |
|---------------------------------------+----------------------------+----------------|
|reverse_iterator& operator+=(Distance) ||stl-RandomAccessIterator|  |Iterator        |
|                                       |                            |addition        |
|---------------------------------------+----------------------------+----------------|
|reverse_iterator operator-(Distance)   ||stl-RandomAccessIterator|  |Iterator        |
|                                       |                            |subtraction     |
|---------------------------------------+----------------------------+----------------|
|reverse_iterator& operator-=(Distance) ||stl-RandomAccessIterator|  |Iterator        |
|                                       |                            |subtraction     |
|---------------------------------------+----------------------------+----------------|
|Reference operator[](Distance)         ||stl-RandomAccessIterator|  |Random access to|
|                                       |                            |an element.     |
|---------------------------------------+----------------------------+----------------|
|reverse_iterator operator+(Distance,   ||stl-RandomAccessIterator|  |Iterator        |
|reverse_iterator)                      |                            |addition. This  |
|                                       |                            |is a global     |
|                                       |                            |function, not a |
|                                       |                            |member function.|
|---------------------------------------+----------------------------+----------------|
|Distance operator-(const               ||stl-RandomAccessIterator|  |Finds the       |
|reverse_iterator&, const               |                            |distance between|
|reverse_iterator&)                     |                            |two iterators.  |
|                                       |                            |This is a global|
|                                       |                            |function, not a |
|                                       |                            |member function.|
|---------------------------------------+----------------------------+----------------|
|bool operator==(const                  ||stl-TrivialIterator|       |Compares two    |
|reverse_iterator&, const               |                            |iterators for   |
|reverse_iterator&)                     |                            |equality. This  |
|                                       |                            |is a global     |
|                                       |                            |function, not a |
|                                       |                            |member function.|
|---------------------------------------+----------------------------+----------------|
|bool operator<(const reverse_iterator&,||stl-RandomAccessIterator|  |Determines      |
|const reverse_iterator&)               |                            |whether the     |
|                                       |                            |first argument  |
|                                       |                            |precedes the    |
|                                       |                            |second. This is |
|                                       |                            |a global        |
|                                       |                            |function, not a |
|                                       |                            |member function.|
|---------------------------------------+----------------------------+----------------|
|random_access_iterator_tag             ||stl-iterator_tags|         |Returns the     |
|iterator_category(const                |                            |iterator's      |
|reverse_iterator&)                     |                            |category. This  |
|                                       |                            |is a global     |
|                                       |                            |function, not a |
|                                       |                            |member function.|
|---------------------------------------+----------------------------+----------------|
|T* value_type(const reverse_iterator&) ||stl-iterator_tags|         |Returns the     |
|                                       |                            |iterator's value|
|                                       |                            |type. This is a |
|                                       |                            |global function,|
|                                       |                            |not a member    |
|                                       |                            |function.       |
|---------------------------------------+----------------------------+----------------|
|Distance* distance_type(const          ||stl-iterator_tags|         |Returns the     |
|reverse_iterator&)                     |                            |iterator's      |
|                                       |                            |distance type.  |
|                                       |                            |This is a global|
|                                       |                            |function, not a |
|                                       |                            |member function.|
+-------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-RandomAccessIterator|
   requirements, but are specific to reverse_iterator.

+--------------------------------------------------------------------------------------------+
|                  Member                   |                  Description                   |
|-------------------------------------------+------------------------------------------------|
|self                                       |A typedef for                                   |
|                                           |reverse_iterator<|stl-RandomAccessIterator|, T, |
|                                           |Reference, Distance>.                           |
|-------------------------------------------+------------------------------------------------|
||stl-RandomAccessIterator| base()          |Returns the current value of the                |
|                                           |reverse_iterator's base iterator. If ri is a    |
|                                           |reverse iterator and i is any iterator, the two |
|                                           |fundamental identities of reverse iterators can |
|                                           |be written as reverse_iterator(i).base() == i   |
|                                           |and &*ri == &*(ri.base() - 1).                  |
|-------------------------------------------+------------------------------------------------|
|reverse_iterator(|stl-RandomAccessIterator||Constructs a reverse_iterator whose base        |
|i)                                         |iterator is i.                                  |
+--------------------------------------------------------------------------------------------+

  Notes

   [1] There isn't really any good reason to have two separate classes: this
   separation is purely because of a technical limitation in some of today's
   C++ compilers. If the two classes were combined into one, then there would
   be no way to declare the return types of the |stl-iterator_tags| functions
   |stl-iterator_category|, |stl-distance_type| and |stl-value_type|
   correctly. The iterator traits class solves this problem: it addresses the
   same issues as the iterator tag functions, but in a cleaner and more
   flexible manner. Iterator traits, however, rely on partial specialization,
   and many C++ compilers do not yet implement partial specialization. Once
   compilers that support partial specialization become more common, these
   two different reverse iterator classes will be combined into a single
   class.

   [2] The declarations for rfirst and rlast are written in this clumsy form
   simply as an illustration of how to declare a reverse_iterator.
   |stl-Vector| is a |stl-ReversibleContainer|, so it provides a typedef for
   the appropriate instantiation of reverse_iterator. The usual way of
   declaring these variables is much simpler:

     vector<T>::reverse_iterator rfirst = rbegin();
     vector<T>::reverse_iterator rlast = rend();

   [3] Note the implications of this remark. The variable rfirst is
   initialized as reverse_iterator<...> rfirst(V.end());. The value obtained
   when it is dereferenced, however, is *(V.end() - 1). This is a general
   property: the fundamental identity of reverse iterators is
   &*(reverse_iterator(i)) == &*(i - 1). This code sample shows why this
   identity is important: if [f, l) is a valid range, then it allows
   [reverse_iterator(l), reverse_iterator(f)) to be a valid range as well.
   Note that the iterator l is not part of the range, but it is required to
   be dereferenceable or past-the-end. There is no requirement that any such
   iterator precedes f.

  See also

   |stl-ReversibleContainer|, |stl-ReverseBidirectionalIterator|,
   |stl-RandomAccessIterator|, |stl-iterator_tags|, |stl-Iterators|

*stl-ReverseBidirectionalIterator*

 reverse_bidirectional_iterator<BidirectionalIterator, T, Reference, Distance>

   Categories: iterators, adaptors                       Component type: type

  Description

   Reverse_bidirectional_iterator is an iterator adaptor that enables
   backwards traversal of a range. Operator++ applied to an object of class
   reverse_bidirectional_iterator<|stl-BidirectionalIterator|> means the same
   thing as operator-- applied to an object of class
   |stl-BidirectionalIterator|. There are two different reverse iterator
   adaptors: the class reverse_bidirectional_iterator has a template argument
   that is a |stl-BidirectionalIterator|, and the class |stl-ReverseIterator|
   has a template argument that is a |stl-RandomAccessIterator|. [2][1]

*stl-ReverseBidirectionalIterator-example*

 template <class T>
 void forw(const |stl-List|<T>& L)
 {
    list<T>::iterator first = L.begin();
    list<T>::iterator last = L.end();
    while (first != last)
       cout << *first++ << endl;
 }

 template <class T>
 void rev(const |stl-List|<T>& L)
 {
    typedef reverse_bidirectional_iterator<list<T>::iterator,
                                           T,
                                           list<T>::reference_type,
                                           list<T>::difference_type>
            reverse_iterator; [3][2]
    reverse_iterator rfirst(L.end());
    reverse_iterator rlast(L.begin());

    while (rfirst != rlast)
       cout << *rfirst++ << endl;
 }

   In the function forw, the elements are printed in the order *first,
   *(first+1), ..., *(last-1). In the function rev, they are printed in the
   order *(last - 1), *(last-2), ..., *first. [4][3]

  Definition

   Defined in the standard header |stl-iterator|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h. This class is no longer part
   of the C++ standard, but it was present in early drafts, and it is
   retained in this implementation for backward compatibility.

  Template parameters

+-------------------------------------------------------------------------------------------+
|      Parameter       |                       Description                       | Default  |
|----------------------+---------------------------------------------------------+----------|
|BidirectionalIterator |The base iterator class. Incrementing an object of class |          |
|                      |reverse_bidirectional_iterator<BidirectionalIterator>    |          |
|                      |corresponds to decrementing an object of class           |          |
|                      |BidirectionalIterator.                                   |          |
|----------------------+---------------------------------------------------------+----------|
|T                     |The reverse iterator's value type. This should always be |          |
|                      |the same as the base iterator's value type.              |          |
|----------------------+---------------------------------------------------------+----------|
|Reference             |The reverse iterator's reference type. This should always|T&        |
|                      |be the same as the base iterator's reference type.       |          |
|----------------------+---------------------------------------------------------+----------|
|Distance              |The reverse iterator's distance type. This should always |ptrdiff_t |
|                      |be the same as the base iterator's distance type.        |          |
+-------------------------------------------------------------------------------------------+

  Model of

   |stl-BidirectionalIterator|.

  Type requirements

   The base iterator type (that is, the template parameter
   BidirectionalIterator) must be a |stl-BidirectionalIterator|. The
   reverse_bidirectional_iterator's value type, reference type, and distance
   type (that is, the template parameters T, Reference, and Distance,
   respectively) must be the same as the base iterator's value type,
   reference type, and distance type.

  Public base classes

   None.

  Members

+-------------------------------------------------------------------------------------------------------+
|                        Member                         |         Where defined         |  Description  |
|-------------------------------------------------------+-------------------------------+---------------|
|self                                                   |reverse_bidirectional_iterator |See below      |
|-------------------------------------------------------+-------------------------------+---------------|
|reverse_bidirectional_iterator()                       ||stl-TrivialIterator|          |The default    |
|                                                       |                               |constructor    |
|-------------------------------------------------------+-------------------------------+---------------|
|reverse_bidirectional_iterator(const                   ||stl-TrivialIterator|          |The copy       |
|reverse_bidirectional_iterator& x)                     |                               |constructor    |
|-------------------------------------------------------+-------------------------------+---------------|
|reverse_bidirectional_iterator& operator=(const        ||stl-TrivialIterator|          |The assignment |
|reverse_bidirectional_iterator& x)                     |                               |operator       |
|-------------------------------------------------------+-------------------------------+---------------|
|reverse_bidirectional_iterator(BidirectionalIterator x)|reverse_bidirectional_iterator |See below.     |
|-------------------------------------------------------+-------------------------------+---------------|
|BidirectionalIterator base()                           |reverse_bidirectional_iterator |See below.     |
|-------------------------------------------------------+-------------------------------+---------------|
|Reference operator*() const                            ||stl-TrivialIterator|          |The dereference|
|                                                       |                               |operator       |
|-------------------------------------------------------+-------------------------------+---------------|
|reverse_bidirectional_iterator& operator++()           ||stl-ForwardIterator|          |Preincrement   |
|-------------------------------------------------------+-------------------------------+---------------|
|reverse_bidirectional_iterator operator++(int)         ||stl-ForwardIterator|          |Postincrement  |
|-------------------------------------------------------+-------------------------------+---------------|
|reverse_bidirectional_iterator& operator--()           ||stl-BidirectionalIterator|    |Predecrement   |
|-------------------------------------------------------+-------------------------------+---------------|
|reverse_bidirectional_iterator operator--(int)         ||stl-BidirectionalIterator|    |Postdecrement  |
|-------------------------------------------------------+-------------------------------+---------------|
|bool operator==(const reverse_bidirectional_iterator&, ||stl-TrivialIterator|          |Compares two   |
|const reverse_bidirectional_iterator&)                 |                               |iterators for  |
|                                                       |                               |equality. This |
|                                                       |                               |is a global    |
|                                                       |                               |function, not a|
|                                                       |                               |member         |
|                                                       |                               |function.      |
|-------------------------------------------------------+-------------------------------+---------------|
|bidirectional_iterator_tag iterator_category(const     ||stl-iterator_tags|            |Returns the    |
|reverse_bidirectional_iterator&)                       |                               |iterator's     |
|                                                       |                               |category. This |
|                                                       |                               |is a global    |
|                                                       |                               |function, not a|
|                                                       |                               |member         |
|                                                       |                               |function.      |
|-------------------------------------------------------+-------------------------------+---------------|
|T* value_type(const reverse_bidirectional_iterator&)   ||stl-iterator_tags|            |Returns the    |
|                                                       |                               |iterator's     |
|                                                       |                               |value type.    |
|                                                       |                               |This is a      |
|                                                       |                               |global         |
|                                                       |                               |function, not a|
|                                                       |                               |member         |
|                                                       |                               |function.      |
|-------------------------------------------------------+-------------------------------+---------------|
|Distance* distance_type(const                          ||stl-iterator_tags|            |Returns the    |
|reverse_bidirectional_iterator&)                       |                               |iterator's     |
|                                                       |                               |distance type. |
|                                                       |                               |This is a      |
|                                                       |                               |global         |
|                                                       |                               |function, not a|
|                                                       |                               |member         |
|                                                       |                               |function.      |
+-------------------------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-BidirectionalIterator|
   requirements, but are specific to reverse_bidirectional_iterator.

+--------------------------------------------------------------------------------------------------------------------------+
|                          Member                          |                          Description                          |
|----------------------------------------------------------+---------------------------------------------------------------|
|self                                                      |A typedef for                                                  |
|                                                          |reverse_bidirectional_iterator<|stl-BidirectionalIterator|, T, |
|                                                          |Reference, Distance>.                                          |
|----------------------------------------------------------+---------------------------------------------------------------|
||stl-BidirectionalIterator| base()                        |Returns the current value of the                               |
|                                                          |reverse_bidirectional_iterator's base iterator. If ri is a     |
|                                                          |reverse iterator and i is any iterator, the two fundamental    |
|                                                          |identities of reverse iterators can be written as              |
|                                                          |reverse_bidirectional_iterator(i).base() == i and &*ri ==      |
|                                                          |&*(ri.base() - 1).                                             |
|----------------------------------------------------------+---------------------------------------------------------------|
|reverse_bidirectional_iterator(|stl-BidirectionalIterator||Constructs a reverse_bidirectional_iterator whose base iterator|
|i)                                                        |is i.                                                          |
+--------------------------------------------------------------------------------------------------------------------------+

  Notes

   [1] There isn't really any good reason to have two separate classes: this
   separation is purely because of a technical limitation in some of today's
   C++ compilers. If the two classes were combined into one, then there would
   be no way to declare the return types of the |stl-iterator_tags| functions
   |stl-iterator_category|, |stl-distance_type| and |stl-value_type|
   correctly. The iterator traits class solves this problem: it addresses the
   same issues as the iterator tag functions, but in a cleaner and more
   flexible manner. Iterator traits, however, rely on partial specialization,
   and many C++ compilers do not yet implement partial specialization. Once
   compilers that support partial specialization become more common, these
   two different reverse iterator classes will be combined into a single
   class.

   [2] The declarations for rfirst and rlast are written in this clumsy form
   simply as an illustration of how to declare a
   reverse_bidirectional_iterator. |stl-List| is a |stl-ReversibleContainer|,
   so it provides a typedef for the appropriate instantiation of
   reverse_bidirectional_iterator. The usual way of declaring these variables
   is much simpler:

     list<T>::reverse_bidirectional_iterator rfirst = rbegin();
     list<T>::reverse_bidirectional_iterator rlast = rend();

   [3] Note the implications of this remark. The variable rfirst is
   initialized as reverse_bidirectional_iterator<...> rfirst(V.end());. The
   value obtained when it is dereferenced, however, is *(V.end() - 1). This
   is a general property: the fundamental identity of reverse iterators is
   &*(reverse_bidirectional_iterator(i)) == &*(i - 1). This code sample shows
   why this identity is important: if [f, l) is a valid range, then it allows
   [reverse_bidirectional_iterator(l), reverse_bidirectional_iterator(f)) to
   be a valid range as well. Note that the iterator l is not part of the
   range, but it is required to be dereferenceable or past-the-end. There is
   no requirement that any such iterator precedes f.

  See also

   |stl-ReversibleContainer|, |stl-ReverseIterator|,
   |stl-BidirectionalIterator|, |stl-iterator_tags|, |stl-Iterators|

*stl-raw_storage_iterator*

                    raw_storage_iterator<ForwardIterator, T>

   Categories: allocators, iterators, adaptors           Component type: type

  Description

   In C++, the operator new allocates memory for an object and then creates
   an object at that location by calling a constructor. Occasionally,
   however, it is useful to separate those two operations. [2][1] If i is an
   iterator that points to a region of uninitialized memory, then you can use
   |stl-construct| to create an object in the location pointed to by i.
   Raw_storage_iterator is an adaptor that makes this procedure more
   convenient. If r is a raw_storage_iterator, then it has some underlying
   iterator i. The expression *r = x is equivalent to |stl-construct|(&*i,
   x).

*stl-raw_storage_iterator-example*

 class Int {
 public:
   Int(int x) : val(x) {}
   int get() { return val; }
 private:
   int val;
 };

 int main()
 {
   int A1[] = {1, 2, 3, 4, 5, 6, 7};
   const int N = sizeof(A1) / sizeof(int);

   Int* A2 = (Int*) malloc(N * sizeof(Int));
   |stl-transform|(A1, A1 + N,
             raw_storage_iterator<Int*, int>(A2),
             |stl-negate|<int>());
 }

  Definition

   Defined in the standard header |stl-memory|, and in the nonstandard
   backward-compatibility header |stl-iterator|.h.

  Template parameters

   +------------------------------------------------------------------------+
   |   Parameter    |                 Description                 | Default |
   |----------------+---------------------------------------------+---------|
   | OutputIterator | The type of the raw_storage_iterator's      |         |
   |                | underlying iterator.                        |         |
   |----------------+---------------------------------------------+---------|
   | T              | The type that will be used as the argument  |         |
   |                | to the constructor.                         |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-OutputIterator|

  Type requirements

     * ForwardIterator is a model of |stl-ForwardIterator|
     * ForwardIterator's value type has a constructor that takes a single
       argument of type T.

  Public base classes

   None.

  Members

+------------------------------------------------------------------------------------+
|                Member                |    Where defined    |      Description      |
|--------------------------------------+---------------------+-----------------------|
|raw_storage_iterator(ForwardIterator  |raw_storage_iterator |See below.             |
|x)                                    |                     |                       |
|--------------------------------------+---------------------+-----------------------|
|raw_storage_iterator(const            ||stl-TrivialIterator||The copy constructor   |
|raw_storage_iterator&)                |                     |                       |
|--------------------------------------+---------------------+-----------------------|
|raw_storage_iterator& operator=(const ||stl-TrivialIterator||The assignment operator|
|raw_storage_iterator&)                |                     |                       |
|--------------------------------------+---------------------+-----------------------|
|raw_storage_iterator& operator*()     ||stl-OutputIterator| |Used to implement the  |
|                                      |                     ||stl-OutputIterator|   |
|                                      |                     |expression *i = x.     |
|                                      |                     |[5][2]                 |
|--------------------------------------+---------------------+-----------------------|
|raw_storage_iterator& operator=(const ||stl-OutputIterator| |Used to implement the  |
|Sequence::value_type&)                |                     ||stl-OutputIterator|   |
|                                      |                     |expression *i = x.     |
|                                      |                     |[6][2]                 |
|--------------------------------------+---------------------+-----------------------|
|raw_storage_iterator& operator++()    ||stl-OutputIterator| |Preincrement.          |
|--------------------------------------+---------------------+-----------------------|
|raw_storage_iterator& operator++(int) ||stl-OutputIterator| |Postincrement.         |
|--------------------------------------+---------------------+-----------------------|
|output_iterator_tag                   ||stl-iterator_tags|  |Returns the iterator's |
|iterator_category(const               |                     |category. This is a    |
|raw_storage_iterator&)                |                     |global function, not a |
|                                      |                     |member.                |
+------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-OutputIterator| requirements,
   but are specific to raw_storage_iterator.

   +------------------------------------------------------------------------+
   |                 Function                 |         Description         |
   |------------------------------------------+-----------------------------|
   | raw_storage_iterator(ForwardIterator i)  | Creates a                   |
   |                                          | raw_storage_iterator whose  |
   |                                          | underlying iterator is i.   |
   |------------------------------------------+-----------------------------|
   | raw_storage_iterator& operator=(const T& | Constructs an object of     |
   | val)                                     | ForwardIterator's value     |
   |                                          | type at the location        |
   |                                          | pointed to by the iterator, |
   |                                          | using val as the            |
   |                                          | constructor's argument.     |
   +------------------------------------------------------------------------+

  Notes

   [1] In particular, this sort of low-level memory management is used in the
   implementation of some container classes.

   [2] Note how assignment through a raw_storage_iterator is implemented. In
   general, unary operator* must be defined so that it returns a proxy
   object, where the proxy object defines operator= to perform the insert
   operation. In this case, for the sake of simplicity, the proxy object is
   the raw_storage_iterator itself. That is, *i returns i, and *i = t is
   equivalent to i = t. You should not, however, rely on this behavior. It is
   an implementation detail, and it is not guaranteed to remain the same in
   future versions.

  See also

   |stl-Allocators|, |stl-construct|, |stl-destroy|, |stl-uninitialized_copy|
   |stl-uninitialized_fill|, |stl-uninitialized_fill_n|,

*stl-sequence_buffer*

                       sequence_buffer<Container, buf_sz>

   Categories: iterators, adaptors                       Component type: type

  Description

   Sequence_buffer is similar to |stl-back_insert_iterator|: it is an
   |stl-OutputIterator| adaptor that appends elements to the end of a
   container.

   The main difference between sequence_buffer and |stl-back_insert_iterator|
   is that |stl-back_insert_iterator| inserts elements into a sequence one
   element at a time; sequence_buffer, however, as the "buffer" part of the
   name suggests, accumulates elements into a buffer and appends the entire
   buffer in a single operation.

   Specifically, the expression *it = v adds v to the end of it's internal
   buffer. The buffer is automatically flushed when it gets full, or when it
   is destroyed; flushing the buffer means emptying it and appending its
   contents to it's underlying container. (It is also possible to flush the
   buffer manually, by invoking the flush() member function.)

   This difference has two implications. First, sequence_buffer is only
   useful if appending an array of N elements is much more efficient than
   inserting a single element N times. Second, sequence_buffer assumes that
   it can insert elements at the end of a container using an append member
   function. This member function is not part of the |stl-Container| or
   |stl-Sequence| requirements. The sequence_buffer adaptor can be used with
   |stl-Rope|, but not with any of the other containers in the library. (This
   is the reason why sequence_buffer is defined in the file |stl-rope|.h,
   instead of in |stl-iterator|.h.)

   If you want to build up a string one character at a time, it is much more
   efficient to use sequence_buffer than to repeatedly add single characters
   to the end of a rope.

*stl-sequence_buffer-example*

 int main()
 {
   const char* const s = "this is a test";
   const int N = strlen(s);

   crope r;
   transform(s, s + N,
             sequence_buffer<crope>(r),
             toupper);
   cout << "r = " << r << endl;
 }

  Definition

   Defined in the header |stl-rope|, and in the backward-compatibility header
   |stl-rope|.h. The sequence_buffer class, and the |stl-rope| header, are SGI
   extensions; they are not part of the C++ standard.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | Container | The type of the underlying container that        |         |
   |           | elements are being written to. [7][1]            |         |
   |-----------+--------------------------------------------------+---------|
   | buf_sz    | Number of elements in the buffer. This is a      | 100     |
   |           | number, not a type. buf_sz has type size_t.      |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-OutputIterator|.

  Type requirements

     * Container is a variable-sized |stl-ForwardContainer|
     * Container's value type T is a model of |stl-DefaultConstructible|, as
       well as |stl-Assignable|.
     * Container has a member function that appends a range. Specifically: If
       x is an object of type Container and f and l are of type T*, then
       x.append(f, l) appends the range [f, l) to x. [8][1]

  Public base classes

   output_iterator

  Members

+--------------------------------------------------------------------------------+
|           Member           |       Where defined       |      Description      |
|----------------------------+---------------------------+-----------------------|
|value_type                  |sequence_buffer            |The underlying         |
|                            |                           |container's value type.|
|----------------------------+---------------------------+-----------------------|
|sequence_buffer(Container&  |sequence_buffer            |Create a               |
|C)                          |                           |sequence_buffer whose  |
|                            |                           |underlying container is|
|                            |                           |C.                     |
|----------------------------+---------------------------+-----------------------|
|sequence_buffer()           ||stl-DefaultConstructible| |The default            |
|                            |                           |constructor. The       |
|                            |                           |resulting iterator is  |
|                            |                           |singular.              |
|----------------------------+---------------------------+-----------------------|
|sequence_buffer(const       ||stl-Assignable|           |Copy constructor.      |
|sequence_buffer&)           |                           |                       |
|----------------------------+---------------------------+-----------------------|
|sequence_buffer&            ||stl-Assignable|           |Assignment operator.   |
|operator=(const             |                           |                       |
|sequence_buffer& s)         |                           |                       |
|----------------------------+---------------------------+-----------------------|
|sequence_buffer&            ||stl-Assignable|           |Faster version of      |
|operator=(sequence_buffer&  |                           |assignment operator.   |
|s)                          |                           |                       |
|----------------------------+---------------------------+-----------------------|
|sequence_buffer&            ||stl-OutputIterator|       |Used to implement the  |
|operator=(const value_type&)|                           ||stl-OutputIterator|   |
|                            |                           |requirement *i = t.    |
|                            |                           |[9][2]                 |
|----------------------------+---------------------------+-----------------------|
|sequence_buffer& operator*()||stl-OutputIterator|       |Used to implement the  |
|                            |                           ||stl-OutputIterator|   |
|                            |                           |requirement *i = t.    |
|                            |                           |[10][2]                |
|----------------------------+---------------------------+-----------------------|
|sequence_buffer&            ||stl-OutputIterator|       |Preincrement           |
|operator++()                |                           |                       |
|----------------------------+---------------------------+-----------------------|
|sequence_buffer&            ||stl-OutputIterator|       |Postincrement          |
|operator++(int)             |                           |                       |
|----------------------------+---------------------------+-----------------------|
|void flush()                |sequence_buffer            |Flush the buffer.      |
|----------------------------+---------------------------+-----------------------|
|void push_back(value_type)  |sequence_buffer            |i.push_back(x) is      |
|                            |                           |equivalent to *i = x.  |
|----------------------------+---------------------------+-----------------------|
|void append(value_type* s,  |sequence_buffer            |Append multiple values.|
|size_t len)                 |                           |                       |
+--------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-OutputIterator| requirements,
   but are specific to sequence_buffer.

   +------------------------------------------------------------------------+
   |            Function            |              Description              |
   |--------------------------------+---------------------------------------|
   | value_type                     | The underlying container's value      |
   |                                | type. That is, typename               |
   |                                | Container::value_type.                |
   |--------------------------------+---------------------------------------|
   | sequence_buffer(Container& C)  | Create a sequence_buffer whose        |
   |                                | underlying container is C. Elements   |
   |                                | appended to the sequence_buffer will  |
   |                                | be appended to C whenever the         |
   |                                | sequence_buffer is flushed.           |
   |--------------------------------+---------------------------------------|
   | void flush()                   | Append all elements in the buffer to  |
   |                                | the underlying container, and empty   |
   |                                | the buffer. That is, make the         |
   |                                | underlying container consistent with  |
   |                                | the sequence_buffer. Note that flush  |
   |                                | is called automatically whenever the  |
   |                                | buffer is full, and also by           |
   |                                | sequence_buffer's destructor.         |
   |                                | Sometimes, however, it is useful to   |
   |                                | be sure that the buffer is flushed at |
   |                                | a particular time.                    |
   |--------------------------------+---------------------------------------|
   | void push_back(value_type x)   | Append x to the sequence_buffer. Note |
   |                                | that this member function is strictly |
   |                                | unnecessary: i.push_back(x) is just   |
   |                                | alternate syntax for *i = x.          |
   |--------------------------------+---------------------------------------|
   | void append(value_type* s,     | Append the range [s, s + len) to the  |
   | size_t len)                    | sequence_buffer. Note that            |
   |                                | i.append(s, n) is just the same as    |
   |                                | |stl-copy|(s, s + n, i). The append   |
   |                                | member function, however, is faster.  |
   +------------------------------------------------------------------------+

  Notes

   [1] Despite the name "sequence_buffer", this adaptor cannot actually be
   used with arbitrary sequences: it requires that the template argument
   Container have an append member function that can insert multiple elements
   at the end of the container. This member function is not part of the
   |stl-Sequence| requirements. This means that sequence_buffer can be used
   with |stl-Rope|, but not with any of the other predefined container
   classes.

   [2] Note how assignment through a sequence_buffer is implemented. In
   general, unary operator* must be defined so that it returns a proxy
   object, where the proxy object defines operator= to perform the output
   operation. In this case, for the sake of simplicity, the proxy object is
   the sequence_buffer itself. That is, *i simply returns i, and *i = t is
   equivalent to i = t. You should not, however, rely on this behavior. It is
   an implementation detail, and it is not guaranteed to remain the same in
   future versions.

  See also

   |stl-OutputIterator|, |stl-Rope|, |stl-front_insert_iterator|,
   |stl-back_insert_iterator|, |stl-insert_iterator|






********************************************************************************
                                  Algorithms
********************************************************************************



    ----------------------------------------------------------------------------
                             Non-mutating algorithms
    ----------------------------------------------------------------------------
*stl-for_each*

                                    for_each

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-InputIterator|, class |stl-UnaryFunction|>
 UnaryFunction for_each(InputIterator first, InputIterator last, UnaryFunction f);

  Description

   For_each applies the |stl-functors| f to each element in the range [first,
   last); f's return value, if any, is ignored. Applications are performed in
   forward order, i.e. from first to last. For_each returns the function
   object after it has been applied to each element. [2][1]

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

     * InputIterator is a model of |stl-InputIterator|
     * UnaryFunction is a model of |stl-UnaryFunction|
     * UnaryFunction does not apply any non-constant operation through its
       argument.
     * InputIterator's value type is convertible to UnaryFunction's argument
       type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear. Exactly last - first applications of UnaryFunction.

*stl-for_each-example*

 template<class T> struct print : public |stl-unary_function|<T, void>
 {
   print(ostream& out) : os(out), count(0) {}
   void operator() (T x) { os << x << ' '; ++count; }
   ostream& os;
   int count;
 };

 int main()
 {
   int A[] = {1, 4, 2, 8, 5, 7};
   const int N = sizeof(A) / sizeof(int);

   print<int> P = for_each(A, A + N, print<int>(cout));
   cout << endl << P.count << " objects printed." << endl;
 }

  Notes

   [1] This return value is sometimes useful, since a function object may
   have local state. It might, for example, count the number of times that it
   is called, or it might have a status flag to indicate whether or not a
   call succeeded.

  See also

   The |stl-functors|, |stl-count|, |stl-copy|

*stl-find*

                                      find

   Category: algorithms                              Component type: function

  Prototype

 template<class |stl-InputIterator|, class |stl-EqualityComparable|>
 InputIterator find(InputIterator first, InputIterator last,
                    const EqualityComparable& value);

  Description

   Returns the first iterator i in the range [first, last) such that *i ==
   value. Returns last if no such iterator exists.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

     * EqualityComparable is a model of |stl-EqualityComparable|.
     * InputIterator is a model of |stl-InputIterator|.
     * Equality is defined between objects of type EqualityComparable and
       objects of InputIterator's value type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear: at most last - first comparisons for equality.

*stl-find-example*

 |stl-List|<int> L;
 L.push_back(3);
 L.push_back(1);
 L.push_back(7);

 |stl-List|<int>::iterator result = find(L.begin(), L.end(), 7);
 assert(result == L.end() || *result == 7);

  See also

   |stl-find_if|.

*stl-find_if*

                                    find_if

   Category: algorithms                              Component type: function

  Prototype

 template<class |stl-InputIterator|, class |stl-Predicate|>
 InputIterator find_if(InputIterator first, InputIterator last,
                       Predicate pred);

  Description

   Returns the first iterator i in the range [first, last) such that pred(*i)
   is true. Returns last if no such iterator exists.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

     * Predicate is a model of |stl-Predicate|.
     * InputIterator is a model of |stl-InputIterator|.
     * The value type of InputIterator is convertible to the argument type of
       Predicate.

  Preconditions

     * [first, last) is a valid range.
     * For each iterator i in the range [first, last), *i is in the domain of
       Predicate.

  Complexity

   Linear: at most last - first applications of Pred.

*stl-find_if-example*

 |stl-List|<int> L;
 L.push_back(-3);
 L.push_back(0);
 L.push_back(3);
 L.push_back(-2);

 |stl-List|<int>::iterator result = find_if(L.begin(), L.end(),
                                      bind2nd(greater<int>(), 0));
 assert(result == L.end() || *result > 0);

  See also

   |stl-find|.

*stl-adjacent_find*

                                 adjacent_find

   Category: algorithms                              Component type: function

  Prototype

   Adjacent_find is an overloaded name; there are actually two adjacent_find
   functions.

 template <class |stl-ForwardIterator|>
 ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last);

 template <class |stl-ForwardIterator|, class |stl-BinaryPredicate|>
 ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last,
                               BinaryPredicate binary_pred);

  Description

   The first version of adjacent_find returns the first iterator i such that
   i and i+1 are both valid iterators in [first, last), and such that *i ==
   *(i+1). It returns last if no such iterator exists.

   The second version of adjacent_find returns the first iterator i such that
   i and i+1 are both valid iterators in [first, last), and such that
   binary_pred(*i, *(i+1)) is true. It returns last if no such iterator
   exists.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

   For the first version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * ForwardIterator's value type is |stl-EqualityComparable|.

   For the second version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * ForwardIterator's value type is convertible to BinaryPredicate's first
       argument type and to its second argument type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear. If first == last then no comparison are performed; otherwise, at
   most (last - first) - 1 comparisons.

*stl-adjacent_find-example*

   Find the first element that is greater than its successor.

 int A[] = {1, 2, 3, 4, 6, 5, 7, 8};
 const int N = sizeof(A) / sizeof(int);

 const int* p = adjacent_find(A, A + N, |stl-greater|<int>());

 cout << "Element " << p - A << " is out of order: "
      << *p << " > " << *(p + 1) << "." << endl;

  See also

   |stl-find|, |stl-mismatch|, |stl-equal|, |stl-search|

*stl-find_first_of*

                                 find_first_of

   Category: algorithms                              Component type: function

  Prototype

   find_first_of is an overloaded name; there are actually two find_first_of
   functions.

 template <class |stl-InputIterator|, class |stl-ForwardIterator|>
 InputIterator find_first_of(InputIterator first1, InputIterator last1,
                             ForwardIterator first2, ForwardIterator last2);

 template <class InputIterator, class ForwardIterator, class BinaryPredicate>
 InputIterator find_first_of(InputIterator first1, InputIterator last1,
                             ForwardIterator first2, ForwardIterator last2,
                             BinaryPredicate comp);

  Description

   Find_first_of is similar to |stl-find|, in that it performs linear seach
   through a range of |stl-InputIterator|. The difference is that while
   |stl-find| searches for one particular value, find_first_of searches for
   any of several values. Specifically, find_first_of searches for the first
   occurrance in the range [first1, last1) of any of the elements in [first2,
   last2). (Note that this behavior is reminiscent of the function strpbrk
   from the standard C library.)

   The two versions of find_first_of differ in how they compare elements for
   equality. The first uses operator==, and the second uses and arbitrary
   user-supplied |stl-functors| comp. The first version returns the first
   iterator i in [first1, last1) such that, for some iterator j in [first2,
   last2), *i == *j. The second returns the first iterator i in [first1,
   last1) such that, for some iterator j in [first2, last2), comp(*i, *j) is
   true. As usual, both versions return last1 if no such iterator i exists.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

   For the first version:

     * InputIterator is a model of |stl-InputIterator|.
     * ForwardIterator is a model of |stl-ForwardIterator|.
     * InputIterator's value type is |stl-EqualityComparable|, and can be
       compared for equality with |stl-ForwardIterator|'s value type.

   For the second version:

     * InputIterator is a model of |stl-InputIterator|.
     * ForwardIterator is a model of |stl-ForwardIterator|.
     * BinaryPredicate is a model of |stl-BinaryPredicate|.
     * InputIterator's value type is convertible to BinaryPredicate's first
       argument type.
     * ForwardIterator's value type is convertible to BinaryPredicate's
       second argument type.

  Preconditions

     * [first1, last1) is a valid range.
     * [first2, last2) is a valid range.

  Complexity

   At most (last1 - first1) * (last2 - first2) comparisons.

*stl-find_first_of-example*

   Like strpbrk, one use for find_first_of is finding whitespace in a string;
   space, tab, and newline are all whitespace characters.

 int main()
 {
   const char* WS = "\t\n ";
   const int n_WS = strlen(WS);

   char* s1 = "This sentence contains five words.";
   char* s2 = "OneWord";


   char* end1 = find_first_of(s1, s1 + strlen(s1),
                              WS, WS + n_WS);
   char* end2 = find_first_of(s2, s2 + strlen(s2),
                              WS, WS + n_WS);

   printf("First word of s1: %.*s\n", end1 - s1, s1);
   printf("First word of s2: %.*s\n", end2 - s2, s2);
 }

  See also

   |stl-find|, |stl-find_if|, |stl-search|

*stl-count*

                                     count

   Category: algorithms                              Component type: function

  Prototype

   Count is an overloaded name: there are two count functions.

 template <class |stl-InputIterator|, class |stl-EqualityComparable|>
 |stl-iterator_traits|<InputIterator>::difference_type
 count(InputIterator first, InputIterator last,
       const EqualityComparable& value);

 template <class |stl-InputIterator|, class |stl-EqualityComparable|, class Size>
 void count(InputIterator first, InputIterator last,
            const EqualityComparable& value,
            Size& n);

  Description

   Count finds the number of elements in [first, last) that are equal to
   value. More precisely, the first version of count returns the number of
   iterators i in [first, last) such that *i == value. The second version of
   count adds to n the number of iterators i in [first, last) such that *i ==
   value.

   The second version of count was the one defined in the original STL, and
   the first version is the one defined in the draft C++ standard; the
   definition was changed because the older interface was clumsy and
   error-prone. The older interface required the use of a temporary variable,
   which had to be initialized to 0 before the call to count.

   Both interfaces are currently supported [2][1], for reasons of backward
   compatibility, but eventually the older version will be removed.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

   For the first version, which takes three arguments:

     * InputIterator is a model of |stl-InputIterator|.
     * EqualityComparable is a model of |stl-EqualityComparable|.
     * InputIterator's value type is a model of |stl-EqualityComparable|.
     * An object of InputIterator's value type can be compared for equality
       with an object of type EqualityComparable.

   For the second version, which takes four arguments:

     * InputIterator is a model of |stl-InputIterator|.
     * EqualityComparable is a model of |stl-EqualityComparable|.
     * Size is an integral type that can hold values of InputIterator's
       distance type.
     * InputIterator's value type is a model of |stl-EqualityComparable|.
     * An object of InputIterator's value type can be compared for equality
       with an object of type EqualityComparable.

  Preconditions

     * [first, last) is a valid range.

   For the second version:

     * [first, last) is a valid range.
     * n plus the number of elements equal to value does not exceed the
       maximum value of type Size.

  Complexity

   Linear. Exactly last - first comparisons.

*stl-count-example*

 int main() {
   int A[] = { 2, 0, 4, 6, 0, 3, 1, -7 };
   const int N = sizeof(A) / sizeof(int);

   cout << "Number of zeros: "
        << count(A, A + N, 0)
        << endl;
 }

  Notes

   [1] The new count interface uses the |stl-iterator_traits| class, which
   relies on a C++ feature known as partial specialization. Many of today's
   compilers don't implement the complete standard; in particular, many
   compilers do not support partial specialization. If your compiler does not
   support partial specialization, then you will not be able to use the newer
   version of count, or any other STL components that involve
   |stl-iterator_traits|.

  See also

   |stl-count_if|, |stl-find|, |stl-find_if|

*stl-count_if*

                                    count_if

   Category: algorithms                              Component type: function

  Prototype

   Count_if is an overloaded name: there are two count_if functions.

 template <class InputIterator, class Predicate>
 iterator_traits<InputIterator>::difference_type
 count_if(InputIterator first, InputIterator last, Predicate pred);

 template <class |stl-InputIterator|, class |stl-Predicate|, class Size>
 void count_if(InputIterator first, InputIterator last,
               Predicate pred,
               Size& n);

  Description

   Count_if finds the number of elements in [first, last) that satisfy the
   predicate pred. More precisely, the first version of count_if returns the
   number of iterators i in [first, last) such that pred(*i) is true. The
   second version of count adds to n the number of iterators i in [first,
   last) such that pred(*i) is true.

   The second version of count_if was the one defined in the original STL,
   and the first version is the one defined in the draft C++ standard; the
   definition was changed because the older interface was clumsy and
   error-prone. The older interface required the use of a temporary variable,
   which had to be initialized to 0 before the call to count_if.

   Both interfaces are currently supported [2][1], for reasons of backward
   compatibility, but eventually the older version will be removed.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

   For the first version, which takes three arguments:

     * InputIterator is a model of |stl-InputIterator|.
     * Predicate is a model of |stl-Predicate|.
     * InputIterator's value type is convertible to Predicate's argument
       type.

   For the second version, which takes four arguments:

     * InputIterator is a model of |stl-InputIterator|.
     * Predicate is a model of |stl-Predicate|.
     * Size is an integral type that can hold values of InputIterator's
       distance type.
     * InputIterator's value type is convertible to Predicate's argument
       type.

  Preconditions

   For the first version:

     * [first, last) is a valid range.

   For the second version:

     * [first, last) is a valid range.
     * n plus the number of elements that satisfy pred does not exceed the
       maximum value of type Size.

  Complexity

   Linear. Exactly last - first applications of pred.

*stl-count_if-example*

 int main() {
   int A[] = { 2, 0, 4, 6, 0, 3, 1, -7 };
   const int N = sizeof(A) / sizeof(int);

   cout << "Number of even elements: "
        << count_if(A, A + N,
                    |stl-unary_compose|(|stl-binder2nd|(|stl-equal_to|<int>(), 0),
                             |stl-binder2nd|(|stl-modulus|<int>(), 2)))
        << endl;
 }

  Notes

   [1] The new count interface uses the |stl-iterator_traits| class, which
   relies on a C++ feature known as partial specialization. Many of today's
   compilers don't implement the complete standard; in particular, many
   compilers do not support partial specialization. If your compiler does not
   support partial specialization, then you will not be able to use the newer
   version of count, or any other STL components that involve
   |stl-iterator_traits|.

  See also

   |stl-count|, |stl-find|, |stl-find_if|

*stl-mismatch*

                                    mismatch

   Category: algorithms                              Component type: function

  Prototype

   Mismatch is an overloaded name; there are actually two mismatch functions.

 template <class |stl-InputIterator|1, class |stl-InputIterator|2>
 |stl-pair|<InputIterator1, InputIterator2>
 mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);

 template <class |stl-InputIterator|1, class |stl-InputIterator|2,
           class |stl-BinaryPredicate|>
 |stl-pair|<InputIterator1, InputIterator2>
 mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,
          BinaryPredicate binary_pred);

  Description

   Mismatch finds the first position where the two ranges [first1, last1) and
   [first2, first2 + (last1 - first1)) differ. The two versions of mismatch
   use different tests for whether elements differ.

   The first version of mismatch finds the first iterator i in [first1,
   last1) such that *i != *(first2 + (i - first1)). The return value is a
   pair whose first element is i and whose second element is *(first2 + (i -
   first1)). If no such iterator i exists, the return value is a pair whose
   first element is last1 and whose second element is *(first2 + (last1 -
   first1)).

   The second version of mismatch finds the first iterator i in [first1,
   last1) such that binary_pred(*i, *(first2 + (i - first1)) is false. The
   return value is a pair whose first element is i and whose second element
   is *(first2 + (i - first1)). If no such iterator i exists, the return
   value is a pair whose first element is last1 and whose second element is
   *(first2 + (last1 - first1)).

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

   For the first version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * InputIterator1's value type is a model of |stl-EqualityComparable|.
     * InputIterator2's value type is a model of |stl-EqualityComparable|.
     * InputIterator1's value type can be compared for equality with
       InputIterator2's value type.

   For the second version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * BinaryPredicate is a model of |stl-BinaryPredicate|.
     * InputIterator1's value type is convertible to BinaryPredicate's first
       argument type.
     * InputIterator2's value type is convertible to BinaryPredicate's second
       argument type.

  Preconditions

     * [first1, last1) is a valid range.
     * [first2, first2 + (last2 - last1)) is a valid range.

  Complexity

   Linear. At most last1 - first1 comparisons.

*stl-mismatch-example*

 int A1[] = { 3, 1, 4, 1, 5, 9, 3 };
 int A2[] = { 3, 1, 4, 2, 8, 5, 7 };
 const int N = sizeof(A1) / sizeof(int);

 |stl-pair|<int*, int*> result = mismatch(A1, A1 + N, A2);
 cout << "The first mismatch is in position " << result.first - A1 << endl;
 cout << "Values are: " << *(result.first) << ", " << *(result.second) << endl;

  See also

   |stl-equal|, |stl-search|, |stl-find|, |stl-find_if|

*stl-equal*

                                     equal

   Category: algorithms                              Component type: function

  Prototype

   Equal is an overloaded name; there are actually two equal functions.

 template <class |stl-InputIterator|1, class |stl-InputIterator|2>
 bool equal(InputIterator1 first1, InputIterator1 last1,
            InputIterator2 first2);

 template <class |stl-InputIterator|1, class |stl-InputIterator|2,
           class |stl-BinaryPredicate|>
 bool equal(InputIterator1 first1, InputIterator1 last1,
            InputIterator2 first2, BinaryPredicate binary_pred);

  Description

   Equal returns true if the two ranges [first1, last1) and [first2, first2 +
   (last1 - first1)) are identical when compared element-by-element, and
   otherwise returns false. [2][1]

   The first version of equal returns true if and only if for every iterator
   i in [first1, last1), *i == *(first2 + (i - first1)). The second version
   of equal returns true if and only if for every iterator i in [first1,
   last1), binary_pred(*i, *(first2 + (i - first1)) is true.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

   For the first version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * InputIterator1's value type is a model of |stl-EqualityComparable|.
     * InputIterator2's value type is a model of |stl-EqualityComparable|.
     * InputIterator1's value type can be compared for equality with
       InputIterator2's value type.

   For the second version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * BinaryPredicate is a model of |stl-BinaryPredicate|.
     * InputIterator1's value type is convertible to BinaryPredicate's first
       argument type.
     * InputIterator2's value type is convertible to BinaryPredicate's second
       argument type.

  Preconditions

     * [first1, last1) is a valid range.
     * [first2, first2 + (last2 - last1)) is a valid range.

  Complexity

   Linear. At most last1 - first1 comparisons.

*stl-equal-example*

 int A1[] = { 3, 1, 4, 1, 5, 9, 3 };
 int A2[] = { 3, 1, 4, 2, 8, 5, 7 };
 const int N = sizeof(A1) / sizeof(int);

 cout << "Result of comparison: " << equal(A1, A1 + N, A2) << endl;

  Notes

   [1] Note that this is very similar to the behavior of |stl-mismatch|: The
   only real difference is that while equal will simply return false if the
   two ranges differ, |stl-mismatch| returns the first location where they do
   differ. The expression equal(f1, l1, f2) is precisely equivalent to the
   expression mismatch(f1, l1, f2).first == l1, and this is in fact how equal
   could be implemented.

  See also

   |stl-mismatch|, |stl-search|, |stl-find|, |stl-find_if|

*stl-search*

                                     search

   Category: algorithms                              Component type: function

  Prototype

   Search is an overloaded name; there are actually two search functions.

 template <class |stl-ForwardIterator|1, class |stl-ForwardIterator|2>
 ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1,
                         ForwardIterator2 first2, ForwardIterator2 last2);

 template <class |stl-ForwardIterator|1, class |stl-ForwardIterator|2, class |stl-BinaryPredicate|>
 ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1,
                         ForwardIterator2 first2, ForwardIterator2 last2,
                         BinaryPredicate binary_pred);

  Description

   Search finds a subsequence within the range [first1, last1) that is
   identical to [first2, last2) when compared element-by-element. It returns
   an iterator pointing to the beginning of that subsequence, or else last1
   if no such subsequence exists. The two versions of search differ in how
   they determine whether two elements are the same: the first uses
   operator==, and the second uses the user-supplied |stl-functors|
   binary_pred.

   The first version of search returns the first iterator i in the range
   [first1, last1 - (last2 - first2)) [2][1] such that, for every iterator j
   in the range [first2, last2), *(i + (j - first2)) == *j. The second
   version returns the first iterator i in [first1, last1 - (last2 - first2))
   such that, for every iterator j in [first2, last2), binary_pred(*(i + (j -
   first2)), *j) is true. These conditions simply mean that every element in
   the subrange beginning with i must be the same as the corresponding
   element in [first2, last2).

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

   For the first version:

     * ForwardIterator1 is a model of |stl-ForwardIterator|.
     * ForwardIterator2 is a model of |stl-ForwardIterator|.
     * ForwardIterator1's value type is a model of |stl-EqualityComparable|.
     * ForwardIterator2's value type is a model of |stl-EqualityComparable|.
     * Objects of ForwardIterator1's value type can be compared for equality
       with Objects of ForwardIterator2's value type.

   For the second version:

     * ForwardIterator1 is a model of |stl-ForwardIterator|.
     * ForwardIterator2 is a model of |stl-ForwardIterator|.
     * BinaryPredicate is a model of |stl-BinaryPredicate|.
     * ForwardIterator1's value type is convertible to BinaryPredicate's
       first argument type.
     * ForwardIterator2's value type is convertible to BinaryPredicate's
       second argument type.

  Preconditions

     * [first1, last1) is a valid range.
     * [first2, last2) is a valid range.

  Complexity

   Worst case behavior is quadratic: at most (last1 - first1) * (last2 -
   first2) comparisons. This worst case, however, is rare. Average complexity
   is linear.

*stl-search-example*

   const char S1[] = "Hello, world!";
   const char S2[] = "world";
   const int N1 = sizeof(S1) - 1;
   const int N2 = sizeof(S2) - 1;

   const char* p = search(S1, S1 + N1, S2, S2 + N2);
   printf("Found subsequence \"%s\" at character %d of sequence \"%s\".\n",
          S2, p - S1, S1);

  Notes

   [1] The reason that this range is [first1, last1 - (last2 - first2)),
   instead of simply [first1, last1), is that we are looking for a
   subsequence that is equal to the complete sequence [first2, last2). An
   iterator i can't be the beginning of such a subsequence unless last1 - i
   is greater than or equal to last2 - first2. Note the implication of this:
   you may call search with arguments such that last1 - first1 is less than
   last2 - first2, but such a search will always fail.

  See also

   |stl-find|, |stl-find_if|, |stl-find_end|, |stl-search_n|, |stl-mismatch|,
   |stl-equal|

*stl-search_n*

                                    search_n

   Category: algorithms                              Component type: function

  Prototype

   Search_n is an overloaded name; there are actually two search_n functions.

 template <class |stl-ForwardIterator|, class Integer, class T>
 ForwardIterator search_n(ForwardIterator first, ForwardIterator last,
                          Integer count, const T& value);

 template <class |stl-ForwardIterator|, class Integer,
           class T, class |stl-BinaryPredicate|>
 ForwardIterator search_n(ForwardIterator first, ForwardIterator last,
                          Integer count, const T& value,
                          BinaryPredicate binary_pred);

  Description

   Search_n searches for a subsequence of count consecutive elements in the
   range [first, last), all of which are equal to value. [2][1] It returns an
   iterator pointing to the beginning of that subsequence, or else last if no
   such subsequence exists. The two versions of search_n differ in how they
   determine whether two elements are the same: the first uses operator==,
   and the second uses the user-supplied |stl-functors| binary_pred.

   The first version of search returns the first iterator i in the range
   [first, last - count) [3][2] such that, for every iterator j in the range
   [i, i + count), *j == value. The second version returns the first iterator
   i in the range [first, last - count) such that, for every iterator j in
   the range [i, i + count), binary_pred(*j, value) is true.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [5]algo.h.

  Requirements on types

   For the first version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * Integer is an integral type.
     * T is a model of |stl-EqualityComparable|.
     * ForwardIterator's value type is a model of |stl-EqualityComparable|.
     * Objects of ForwardIterator's value type can be compared for equality
       with Objects of type T.

   For the first version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * Integer is an integral type.
     * T is a model of |stl-EqualityComparable|.
     * BinaryPredicate is a model of |stl-BinaryPredicate|.
     * ForwardIterator's value type is convertible to BinaryPredicate's first
       argument type.
     * T is convertible to BinaryPredicate's second argument type.

  Preconditions

     * [first, last) is a valid range.
     * count is non-negative [6][1].

  Complexity

   Linear. Search_n performs at most last - first comparisons.

   (The C++ standard permits the complexity to be O(n (last - first)), but
   this is unnecessarily lax. There is no reason for search_n to examine any
   element more than once.)

*stl-search_n-example*

 bool eq_nosign(int x, int y) { return abs(x) == abs(y); }

 void lookup(int* first, int* last, size_t count, int val) {
   cout << "Searching for a sequence of "
        << count
        << " '" << val << "'"
        << (count != 1 ? "s: " : ":  ");
   int* result = search_n(first, last, count, val);
   if (result == last)
     cout << "Not found" << endl;
   else
     cout << "Index = " << result - first << endl;
 }

 void lookup_nosign(int* first, int* last, size_t count, int val) {
   cout << "Searching for a (sign-insensitive) sequence of "
        << count
        << " '" << val << "'"
        << (count != 1 ? "s: " : ":  ");
   int* result = search_n(first, last, count, val, eq_nosign);
   if (result == last)
     cout << "Not found" << endl;
   else
     cout << "Index = " << result - first << endl;
 }

 int main() {
   const int N = 10;
   int A[N] = {1, 2, 1, 1, 3, -3, 1, 1, 1, 1};

   lookup(A, A+N, 1, 4);
   lookup(A, A+N, 0, 4);
   lookup(A, A+N, 1, 1);
   lookup(A, A+N, 2, 1);
   lookup(A, A+N, 3, 1);
   lookup(A, A+N, 4, 1);

   lookup(A, A+N, 1, 3);
   lookup(A, A+N, 2, 3);
   lookup_nosign(A, A+N, 1, 3);
   lookup_nosign(A, A+N, 2, 3);
 }

   The output is

 Searching for a sequence of 1 '4':  Not found
 Searching for a sequence of 0 '4's: Index = 0
 Searching for a sequence of 1 '1':  Index = 0
 Searching for a sequence of 2 '1's: Index = 2
 Searching for a sequence of 3 '1's: Index = 6
 Searching for a sequence of 4 '1's: Index = 6
 Searching for a sequence of 1 '3':  Index = 4
 Searching for a sequence of 2 '3's: Not found
 Searching for a (sign-insensitive) sequence of 1 '3':  Index = 4
 Searching for a (sign-insensitive) sequence of 2 '3's: Index = 4

  Notes

   [1] Note that count is permitted to be zero: a subsequence of zero
   elements is well defined. If you call search_n with count equal to zero,
   then the search will always succeed: no matter what value is, every range
   contains a subrange of zero consecutive elements that are equal to value.
   When search_n is called with count equal to zero, the return value is
   always first.

   [2] The reason that this range is [first, last - count), rather than just
   [first, last), is that we are looking for a subsequence whose length is
   count; an iterator i can't be the beginning of such a subsequence unless
   last - count is greater than or equal to count. Note the implication of
   this: you may call search_n with arguments such that last - first is less
   than count, but such a search will always fail.

  See also

   |stl-search|, |stl-find_end|, |stl-find|, |stl-find_if|

*stl-find_end*

                                    find_end

   Category: algorithms                              Component type: function

  Prototype

   find_end is an overloaded name; there are actually two find_end functions.

 template <class ForwardIterator1, class ForwardIterator2>
 ForwardIterator1
 find_end(ForwardIterator1 first1, ForwardIterator1 last1,
          ForwardIterator2 first2, ForwardIterator2 last2);

 template <class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
 ForwardIterator1
 find_end(ForwardIterator1 first1, ForwardIterator1 last1,
          ForwardIterator2 first2, ForwardIterator2 last2,
          BinaryPredicate comp);

  Description

   Find_end is misnamed: it is much more similar to |stl-search| than to
   |stl-find|, and a more accurate name would have been search_end.

   Like search, find_end attempts to find a subsequence within the range
   [first1, last1) that is identical to [first2, last2). The difference is
   that while search finds the first such subsequence, find_end finds the
   last such subsequence. Find_end returns an iterator pointing to the
   beginning of that subsequence; if no such subsequence exists, it returns
   last1.

   The two versions of find_end differ in how they determine whether two
   elements are the same: the first uses operator==, and the second uses the
   user-supplied |stl-functors| comp.

   The first version of find_end returns the last iterator i in the range
   [first1, last1 - (last2 - first2)) such that, for every iterator j in the
   range [first2, last2), *(i + (j - first2)) == *j. The second version of
   find_end returns the last iterator i in [first1, last1 - (last2 - first2))
   such that, for every iterator j in [first2, last2), binary_pred(*(i + (j -
   first2)), *j) is true. These conditions simply mean that every element in
   the subrange beginning with i must be the same as the corresponding
   element in [first2, last2).

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

   For the first version:

     * ForwardIterator1 is a model of |stl-ForwardIterator|.
     * ForwardIterator2 is a model of |stl-ForwardIterator|.
     * ForwardIterator1's value type is a model of |stl-EqualityComparable|.
     * ForwardIterator2's value type is a model of |stl-EqualityComparable|.
     * Objects of ForwardIterator1's value type can be compared for equality
       with Objects of ForwardIterator2's value type.

   For the second version:

     * ForwardIterator1 is a model of |stl-ForwardIterator|.
     * ForwardIterator2 is a model of |stl-ForwardIterator|.
     * BinaryPredicate is a model of |stl-BinaryPredicate|.
     * ForwardIterator1's value type is convertible to BinaryPredicate's
       first argument type.
     * ForwardIterator2's value type is convertible to BinaryPredicate's
       second argument type.

  Preconditions

     * [first1, last1) is a valid range.
     * [first2, last2) is a valid range.

  Complexity

   The number of comparisons is proportional to (last1 - first1) * (last2 -
   first2). If both ForwardIterator1 and ForwardIterator2 are models of
   |stl-BidirectionalIterator|, then the average complexity is linear and the
   worst case is at most (last1 - first1) * (last2 - first2) comparisons.

*stl-find_end-example*

 int main()
 {
   char* s = "executable.exe";
   char* suffix = "exe";

   const int N = strlen(s);
   const int N_suf = strlen(suffix);

   char* location = find_end(s, s + N,
                             suffix, suffix + N_suf);

   if (location != s + N) {
     cout << "Found a match for " << suffix << " within " << s << endl;
     cout << s << endl;

     int i;
     for (i = 0; i < (location - s); ++i)
       cout << ' ';
     for (i = 0; i < N_suf; ++i)
       cout << '^';
     cout << endl;
   }
   else
     cout << "No match for " << suffix << " within " << s << endl;
 }

  Notes

   [1] The reason that this range is [first1, last1 - (last2 - first2)),
   instead of simply [first1, last1), is that we are looking for a
   subsequence that is equal to the complete sequence [first2, last2). An
   iterator i can't be the beginning of such a subsequence unless last1 - i
   is greater than or equal to last2 - first2. Note the implication of this:
   you may call find_end with arguments such that last1 - first1 is less than
   last2 - first2, but such a search will always fail.

  See also

   |stl-search|



    ----------------------------------------------------------------------------
                               Mutating algorithms
    ----------------------------------------------------------------------------
*stl-copy*

                                      copy

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-InputIterator|, class |stl-OutputIterator|>
 OutputIterator copy(InputIterator first, InputIterator last,
                     OutputIterator result);

  Description

   Copy copies elements from the range [first, last) to the range [result,
   result + (last - first)). That is, it performs the assignments *result =
   *first, *(result + 1) = *(first + 1), and so on. [2][1] Generally, for
   every integer n from 0 to last - first, copy performs the assignment
   *(result + n) = *(first + n). Assignments are performed in forward order,
   i.e. in order of increasing n. [3][2]

   The return value is result + (last - first)

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [5]algo.h.

  Requirements on types

     * InputIterator is a model of |stl-InputIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * InputIterator's value type is convertible to a type in
       OutputIterator's set of value types.

  Preconditions

     * [first, last) is a valid range.
     * result is not an iterator within the range [first, last).
     * There is enough space to hold all of the elements being copied. More
       formally, the requirement is that [result, result + (last - first)) is
       a valid range. [6][1]

  Complexity

   Linear. Exactly last - first assignments are performed.

*stl-copy-example*

 |stl-Vector|<int> V(5);
 |stl-iota|(V.begin(), V.end(), 1);

 |stl-List|<int> L(V.size());
 copy(V.begin(), V.end(), L.begin());
 assert(|stl-equal|(V.begin(), V.end(), L.begin()));

  Notes

   [1] Note the implications of this. Copy cannot be used to insert elements
   into an empty |stl-Container|: it overwrites elements, rather than
   inserting elements. If you want to insert elements into a |stl-Sequence|,
   you can either use its insert member function explicitly, or else you can
   use copy along with an |stl-insert_iterator| adaptor.

   [2] The order of assignments matters in the case where the input and
   output ranges overlap: copy may not be used if result is in the range
   [first, last). That is, it may not be used if the beginning of the output
   range overlaps with the input range, but it may be used if the end of the
   output range overlaps with the input range; |stl-copy_backward| has
   opposite restrictions. If the two ranges are completely nonoverlapping, of
   course, then either algorithm may be used. The order of assignments also
   matters if result is an |stl-ostream_iterator|, or some other iterator
   whose semantics depends on the order or assignments.

  See also

   |stl-copy_backward|, |stl-copy_n|

*stl-copy_n*

                                     copy_n

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-InputIterator|, class Size, class |stl-OutputIterator|>
 OutputIterator copy_n(InputIterator first, Size count,
                       OutputIterator result);

  Description

   Copy_n copies elements from the range [first, first + n) to the range
   [result, result + n). That is, it performs the assignments *result =
   *first, *(result + 1) = *(first + 1), and so on. Generally, for every
   integer i from 0 up to (but not including) n, copy_n performs the
   assignment *(result + i) = *(first + i). Assignments are performed in
   forward order, i.e. in order of increasing n. [2][1]

   The return value is result + n.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h. This function is an SGI
   extension; it is not part of the C++ standard.

  Requirements on types

     * InputIterator is a model of |stl-InputIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * Size is an integral type.
     * InputIterator's value type is convertible to a type in
       OutputIterator's set of value types.

  Preconditions

     * n >= 0.
     * [first, first + n) is a valid range.
     * result is not an iterator within the range [first, first + n).
     * [result, result + n) is a valid range.

  Complexity

   Linear. Exactly n assignments are performed.

*stl-copy_n-example*

 |stl-Vector|<int> V(5);
 |stl-iota|(V.begin(), V.end(), 1);

 |stl-List|<int> L(V.size());
 copy_n(V.begin(), V.size(), L.begin());
 assert(|stl-equal|(V.begin(), V.end(), L.begin()));

  Notes

   [1] Copy_n is almost, but not quite, redundant. If first is an
   |stl-InputIterator|, as opposed to a |stl-ForwardIterator|, then the
   copy_n operation can't be expressed in terms of |stl-copy|.

  See also

   |stl-copy|, |stl-copy_backward|

*stl-copy_backward*

                                 copy_backward

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-BidirectionalIterator|1, class |stl-BidirectionalIterator|2>
 BidirectionalIterator2 copy_backward(BidirectionalIterator1 first,
                                      BidirectionalIterator1 last,
                                      BidirectionalIterator2 result);

  Description

   Copy_backward copies elements from the range [first, last) to the range
   [result - (last - first), result) [2][1]. That is, it performs the
   assignments *(result - 1) = *(last - 1), *(result - 2) = *(last - 2), and
   so on. Generally, for every integer n from 0 to last - first,
   copy_backward performs the assignment *(result - n - 1) = *(last - n - 1).
   Assignments are performed from the end of the input sequence to the
   beginning, i.e. in order of increasing n. [3][2]

   The return value is result - (last - first)

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [5]algo.h.

  Requirements on types

     * BidirectionalIterator1 and BidirectionalIterator2 are models of
       |stl-BidirectionalIterator|.
     * BidirectionalIterator1's value type is convertible to
       BidirectionalIterator2's value type.

  Preconditions

     * [first, last) is a valid range.
     * result is not an iterator within the range [first, last).
     * There is enough space to hold all of the elements being copied. More
       formally, the requirement is that [result - (last - first), result) is
       a valid range.

  Complexity

   Linear. Exactly last - first assignments are performed.

*stl-copy_backward-example*

 |stl-Vector|<int> V(15);
 |stl-iota|(V.begin(), V.end(), 1);
 copy_backward(V.begin(), V.begin() + 10, V.begin() + 15);

  Notes

   [1] Result is an iterator that points to the end of the output range. This
   is highly unusual: in all other STL algorithms that denote an output range
   by a single iterator, that iterator points to the beginning of the range.

   [2] The order of assignments matters in the case where the input and
   output ranges overlap: copy_backward may not be used if result is in the
   range [first, last). That is, it may not be used if the end of the output
   range overlaps with the input range, but it may be used if the beginning
   of the output range overlaps with the input range; |stl-copy| has opposite
   restrictions. If the two ranges are completely nonoverlapping, of course,
   then either algorithm may be used.

  See also

   |stl-copy|, |stl-copy_n|

        ________________________________________________________________________
                                         Swap
*stl-swap*

                                      swap

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-Assignable|>
 void swap(Assignable& a, Assignable& b);

  Description

   Assigns the contents of a to b and the contents of b to a. This is used as
   a primitive operation by many other algorithms.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

     * Assignable is a model of |stl-Assignable|.

  Preconditions

   None.

  Complexity

   Amortized constant time. [4][1] [5][2]

*stl-swap-example*

 int x = 1;
 int y = 2;
 assert(x == 1 && y == 2);
 swap(x, y);
 assert(x == 2 && y == 1);

  Notes

   [1] The time required to swap two objects of type T will obviously depend
   on the type; "constant time" does not mean that performance will be the
   same for an 8-bit char as for a 128-bit complex<double>.

   [2] This implementation of swap makes one call to a copy constructor and
   two calls to an assignment operator; roughly, then, it should be expected
   to take about the same amount of time as three assignments. In many cases,
   however, it is possible to write a specialized version of swap that is far
   more efficient. Consider, for example, swapping two |stl-Vector|<double>s
   each of which has N elements. The unspecialized version requires 3*N
   assignments of double, but a specialized version requires only nine
   pointer assignments. This is important because swap is used as a primitive
   operation in many other STL algorithms, and because containers of
   containers (|stl-List|<|stl-Vector|<char> >, for example) are very common.
   The STL includes specialized versions of swap for all container classes.
   User-defined types should also provide specialized versions of swap
   whenever it is possible to write one that is more efficient than the
   general version.

  See also

   |stl-iter_swap|, |stl-swap_ranges|

*stl-iter_swap*

                                   iter_swap

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-ForwardIterator|1, class |stl-ForwardIterator|2>
 inline void iter_swap(ForwardIterator1 a, ForwardIterator2 b);

  Description

   Equivalent to |stl-swap|(*a, *b). [2][1]

  Definition

   Declared in [3]algo.h. The implementation is in [4]algobase.h.

  Requirements on types

     * ForwardIterator1 and ForwardIterator2 are models of
       |stl-ForwardIterator|.
     * ForwardIterator1 and ForwardIterator2 are mutable.
     * ForwardIterator1 and ForwardIterator2 have the same value type.

  Preconditions

     * ForwardIterator1 and ForwardIterator2 are dereferenceable.

  Complexity

   See |stl-swap| for a discussion.

*stl-iter_swap-example*

 int x = 1;
 int y = 2;
 assert(x == 1 && y == 2);
 iter_swap(&x, &y);
 assert(x == 2 && y == 1);

  Notes

   [1] Strictly speaking, iter_swap is redundant. It exists only for
   technical reasons: in some circumstances, some compilers have difficulty
   performing the type deduction required to interpret swap(*a, *b).

  See also

   |stl-swap|, |stl-swap_ranges|

*stl-swap_ranges*

                                  swap_ranges

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-ForwardIterator|1, class |stl-ForwardIterator|2>
 ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,
                              ForwardIterator2 first2);

  Description

   Swap_ranges swaps each of the elements in the range [first1, last1) with
   the corresponding element in the range [first2, first2 + (last1 -
   first1)). That is, for each integer n such that 0 <= n < (last1 - first1),
   it swaps *(first1 + n) and *(first2 + n). The return value is first2 +
   (last1 - first1).

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

   ForwardIterator1 and ForwardIterator2 must both be models of
   |stl-ForwardIterator|. The value types of ForwardIterator1 and
   ForwardIterator2 must be convertible to each other.

  Preconditions

     * [first1, last1) is a valid range.
     * [first2, first2 + (last1 - first1)) is a valid range.
     * The two ranges [first1, last1) and [first2, first2 + (last1 - first1))
       do not overlap.

  Complexity

   Linear. Exactly last1 - first1 swaps are performed.

*stl-swap_ranges-example*

 |stl-Vector|<int> V1, V2;
 V1.push_back(1);
 V1.push_back(2);
 V2.push_back(3);
 V2.push_back(4);

 assert(V1[0] == 1 && V1[1] == 2 && V2[0] == 3 && V2[1] == 4);
 swap_ranges(V1.begin(), V1.end(), V2.begin());
 assert(V1[0] == 3 && V1[1] == 4 && V2[0] == 1 && V2[1] == 2);

  See also

   |stl-swap|, |stl-iter_swap|.


        ________________________________________________________________________
                                      Transform
*stl-transform*

                                   transform

   Category: algorithms                              Component type: function

  Prototype

   Transform is an overloaded name; there are actually two transform
   functions.

 template <class |stl-InputIterator|, class |stl-OutputIterator|, class |stl-UnaryFunction|>
 OutputIterator transform(InputIterator first, InputIterator last,
                          OutputIterator result, UnaryFunction op);


 template <class |stl-InputIterator|1, class |stl-InputIterator|2, class |stl-OutputIterator|,
           class |stl-BinaryFunction|>
 OutputIterator transform(InputIterator1 first1, InputIterator1 last1,
                          InputIterator2 first2, OutputIterator result,
                          BinaryFunction binary_op);

  Description

   Transform performs an operation on objects; there are two versions of
   transform, one of which uses a single range of |stl-InputIterator| and one
   of which uses two ranges of |stl-InputIterator|.

   The first version of transform performs the operation op(*i) for each
   iterator i in the range [first, last), and assigns the result of that
   operation to *o, where o is the corresponding output iterator. That is,
   for each n such that 0 <= n < last - first, it performs the assignment
   *(result + n) = op(*(first + n)). The return value is result + (last -
   first).

   The second version of transform is very similar, except that it uses a
   |stl-BinaryFunction| instead of a |stl-UnaryFunction|: it performs the
   operation op(*i1, *i2) for each iterator i1 in the range [first1, last1)
   and assigns the result to *o, where i2 is the corresponding iterator in
   the second input range and where o is the corresponding output iterator.
   That is, for each n such that 0 <= n < last1 - first1, it performs the
   assignment *(result + n) = op(*(first1 + n), *(first2 + n). The return
   value is result + (last1 - first1).

   Note that transform may be used to modify a sequence "in place": it is
   permissible for the iterators first and result to be the same. [2][1]

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

   For the first (unary) version:

     * InputIterator must be a model of |stl-InputIterator|.
     * OutputIterator must be a model of |stl-OutputIterator|.
     * UnaryFunction must be a model of |stl-UnaryFunction|.
     * InputIterator's value type must be convertible to UnaryFunction's
       argument type.
     * UnaryFunction's result type must be convertible to a type in
       OutputIterator's set of value types.

   For the second (binary) version:

     * InputIterator1 and InputIterator2 must be models of
       |stl-InputIterator|.
     * OutputIterator must be a model of |stl-OutputIterator|.
     * BinaryFunction must be a model of |stl-BinaryFunction|.
     * InputIterator1's and InputIterator2's value types must be convertible,
       respectively, to BinaryFunction's first and second argument types.
     * UnaryFunction's result type must be convertible to a type in
       OutputIterator's set of value types.

  Preconditions

   For the first (unary) version:

     * [first, last) is a valid range.
     * result is not an iterator within the range [first+1, last). [5][1]
     * There is enough space to hold all of the elements being copied. More
       formally, the requirement is that [result, result + (last - first)) is
       a valid range.

   For the second (binary) version:

     * [first1, last1) is a valid range.
     * [first2, first2 + (last1 - first1)) is a valid range.
     * result is not an iterator within the range [first1+1, last1) or
       [first2 + 1, first2 + (last1 - first1)).
     * There is enough space to hold all of the elements being copied. More
       formally, the requirement is that [result, result + (last1 - first1))
       is a valid range.

  Complexity

   Linear. The operation is applied exactly last - first times in the case of
   the unary version, or last1 - first1 in the case of the binary version.

*stl-transform-example*

   Replace every number in an array with its negative.

 const int N = 1000;
 double A[N];
 |stl-iota|(A, A+N, 1);

 transform(A, A+N, A, |stl-negate|<double>());

   Calculate the sum of two vectors, storing the result in a third vector.

 const int N = 1000;
 |stl-Vector|<int> V1(N);
 |stl-Vector|<int> V2(N);
 |stl-Vector|<int> V3(N);

 |stl-iota|(V1.begin(), V1.end(), 1);
 |stl-fill|(V2.begin(), V2.end(), 75);

 assert(V2.size() >= V1.size() && V3.size() >= V1.size());
 transform(V1.begin(), V1.end(), V2.begin(), V3.begin(),
           |stl-plus|<int>());

  Notes

   [1] The |stl-OutputIterator| result is not permitted to be the same as any
   of the |stl-InputIterator| in the range [first, last), with the exception
   of first itself. That is: transform(V.begin(), V.end(), V.begin(), fabs)
   is valid, but transform(V.begin(), V.end(), V.begin() + 1, fabs) is not.

  See also

   The |stl-functors|, |stl-copy|, |stl-generate|, |stl-fill|


        ________________________________________________________________________
                                       Replace
*stl-replace*

                                    replace

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-ForwardIterator|, class T>
 void replace(ForwardIterator first, ForwardIterator last, const T& old_value,
              const T& new_value)

  Description

   Replace replaces every element in the range [first, last) equal to
   old_value with new_value. That is: for every iterator i, if *i ==
   old_value then it performs the assignment *i = new_value.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * ForwardIterator is mutable.
     * T is convertible to ForwardIterator's value type.
     * T is |stl-Assignable|.
     * T is |stl-EqualityComparable|, and may be compared for equality with
       objects of ForwardIterator's value type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear. Replace performs exactly last - first comparisons for equality,
   and at most last - first assignments.

*stl-replace-example*

 |stl-Vector|<int> V;
 V.push_back(1);
 V.push_back(2);
 V.push_back(3);
 V.push_back(1);

 replace(V.begin(), V.end(), 1, 99);
 assert(V[0] == 99 && V[3] == 99);

  See also

   |stl-replace_if|, |stl-replace_copy|, |stl-replace_copy_if|

*stl-replace_if*

                                   replace_if

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-ForwardIterator|, class |stl-Predicate|, class T>
 void replace_if(ForwardIterator first, ForwardIterator last, Predicate pred
                 const T& new_value)

  Description

   Replace_if replaces every element in the range [first, last) for which
   pred returns true with new_value. That is: for every iterator i, if
   pred(*i) is true then it performs the assignment *i = new_value.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * ForwardIterator is mutable.
     * Predicate is a model of |stl-Predicate|.
     * ForwardIterator's value type is convertible to Predicate's argument
       type.
     * T is convertible to Forward Iterator's value type.
     * T is |stl-Assignable|.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear. Replace_if performs exactly last - first applications of pred, and
   at most last - first assignments.

*stl-replace_if-example*

   Replace every negative number with 0.

 |stl-Vector|<int> V;
 V.push_back(1);
 V.push_back(-3);
 V.push_back(2);
 V.push_back(-1);

 replace_if(V.begin(), V.end(), |stl-binder2nd|(|stl-less|<int>(), 0), -1);
 assert(V[1] == 0 && V[3] == 0);

  See also

   |stl-replace|, |stl-replace_copy|, |stl-replace_copy_if|

*stl-replace_copy*

                                  replace_copy

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-InputIterator|, class OutputIterator, class T>
 OutputIterator replace_copy(InputIterator first, InputIterator last,
                             OutputIterator result, const T& old_value,
                             const T& new_value);

  Description

   Replace_copy copies elements from the range [first, last) to the range
   [result, result + (last-first)), except that any element equal to
   old_value is not copied; new_value is copied instead. More precisely, for
   every integer n such that 0 <= n < last-first, replace_copy performs the
   assignment *(result+n) = new_value if *(first+n) == old_value, and
   *(result+n) = *(first+n) otherwise.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

     * InputIterator is a model of |stl-InputIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * T is |stl-EqualityComparable|, and may be compared for equality with
       objects of InputIterator's value type.
     * T is |stl-Assignable|.
     * T is convertible to a type in OutputIterator's set of value types.

  Preconditions

     * [first, last) is a valid range.
     * There is enough space in the output range to store the copied values.
       That is, [result, result + (last-first)) is a valid range.
     * result is not an iterator within the range [first, last).

  Complexity

   Linear. Replace_copy performs exactly last - first comparisons for
   equality and exactly last - first assignments.

*stl-replace_copy-example*

 |stl-Vector|<int> V1;
 V1.push_back(1);
 V1.push_back(2);
 V1.push_back(3);
 V1.push_back(1);

 |stl-Vector|<int> V2(4);

 replace_copy(V1.begin(), V1.end(), V2.begin(), 1, 99);
 assert(V[0] == 99 && V[1] == 2 && V[2] == 3 && V[3] == 99);

  See also

   |stl-copy|, |stl-replace|, |stl-replace_if|, |stl-replace_copy_if|

*stl-replace_copy_if*

                                replace_copy_if

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-InputIterator|, class |stl-OutputIterator|, class |stl-Predicate|, class T>
 OutputIterator replace_copy_if(InputIterator first, InputIterator last,
                                OutputIterator result, Predicate pred,
                                const T& new_value)

  Description

   Replace_copy_if copies elements from the range [first, last) to the range
   [result, result + (last-first)), except that any element for which pred is
   true is not copied; new_value is copied instead. More precisely, for every
   integer n such that 0 <= n < last-first, replace_copy_if performs the
   assignment *(result+n) = new_value if pred(*(first+n)), and *(result+n) =
   *(first+n) otherwise.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

     * InputIterator is a model of |stl-InputIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * Predicate is a model of |stl-Predicate|.
     * T is convertible to Predicate's argument type.
     * T is |stl-Assignable|.
     * T is convertible to a type in OutputIterator's set of value types.

  Preconditions

     * [first, last) is a valid range.
     * There is enough space in the output range to store the copied values.
       That is, [result, result + (last-first)) is a valid range.
     * result is not an iterator within the range [first, last).

  Complexity

   Linear. Replace_copy performs exactly last - first applications of pred
   and exactly last - first assignments.

*stl-replace_copy_if-example*

   Copy elements from one |stl-Vector| to another, replacing all negative
   numbers with 0.

 |stl-Vector|<int> V1;
 V1.push_back(1);
 V1.push_back(-1);
 V1.push_back(-5);
 V1.push_back(2);

 |stl-Vector|<int> V2(4);

 replace_copy_if(V1.begin(), V1.end(), V2.begin(),
                 |stl-binder2nd|(|stl-less|<int>(), 0),
                 0);
 assert(V[0] == 1 && V[1] == 0 && V[2] == 0 && V[3] == 2);

  See also

   |stl-copy|, |stl-replace|, |stl-replace_if|, |stl-replace_copy|


*stl-fill*

                                      fill

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-ForwardIterator|, class T>
 void fill(ForwardIterator first, ForwardIterator last, const T& value);

  Description

   Fill assigns the value value to every element in the range [first, last).
   That is, for every iterator i in [first, last), it performs the assignment
   *i = value.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

     * ForwardIterator is a model of |stl-ForwardIterator|. [4][1]
     * ForwardIterator is mutable.
     * T is a model of |stl-Assignable|.
     * T is convertible to |stl-ForwardIterator|'s value type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear. Fill performs exactly last - first assignments.

*stl-fill-example*

 |stl-Vector|<double> V(4);
 fill(V.begin(), V.end(), 137);
 assert(V[0] == 137 && V[1] == 137 && V[2] == 137 && V[3] == 137);

  Notes

   [1] The reason that fill requires its argument to be a mutable
   |stl-ForwardIterator|, rather than merely an |stl-OutputIterator|, is that
   it uses a range [first, last) of iterators. There is no sensible way to
   describe a range of |stl-OutputIterator|, because it is impossible to
   compare two |stl-OutputIterator| for equality. The |stl-fill_n| algorithm
   does have an interface that permits use of an |stl-OutputIterator|.

  See also

   |stl-copy|, |stl-fill_n|, |stl-generate|, |stl-generate_n|, |stl-iota|

*stl-fill_n*

                                     fill_n

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-OutputIterator|, class Size, class T>
 OutputIterator fill_n(OutputIterator first, Size n, const T& value);

  Description

   Fill_n assigns the value value to every element in the range [first,
   first+n). That is, for every iterator i in [first, first+n), it performs
   the assignment *i = value. The return value is first + n.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

     * OutputIterator is a model of |stl-OutputIterator|.
     * Size is an integral type (either signed or unsigned).
     * T is a model of |stl-Assignable|.
     * T is convertible to a type in OutputIterator's set of value types.

  Preconditions

     * n >= 0.
     * There is enough space to hold n values. That is, [first, first+n) is a
       valid range.

  Complexity

   Linear. Fill_n performs exactly n assignments.

*stl-fill_n-example*

 |stl-Vector|<double> V;
 fill_n(back_inserter(V), 4, 137);
 assert(V.size() == 4 && V[0] == 42 && V[1] == 42 && V[2] == 42 && V[3] == 42);

  See also

   |stl-copy|, |stl-fill|, |stl-generate|, |stl-generate_n|, |stl-iota|

*stl-generate*

                                    generate

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-ForwardIterator|, class |stl-Generator|>
 void generate(ForwardIterator first, ForwardIterator last, Generator gen);

  Description

   Generate assigns the result of invoking gen, a |stl-functors| that takes
   no arguments, to each element in the range [first, last). [2][1]

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

     * ForwardIterator is a model of |stl-ForwardIterator|. [5][2]
     * ForwardIterator is mutable.
     * Generator is a model of |stl-Generator|.
     * Generator's result type is convertible to ForwardIterator's value
       type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear. Exactly last - first invocations of gen. [6][1]

*stl-generate-example*

   Fill a vector with random numbers, using the standard C library function
   rand.

 vector<int> V;
 ...
 generate(V.begin(), V.end(), rand);

  Notes

   [1] The |stl-functors| gen is invoked for each iterator in the range
   [first, last), as opposed to just being invoked a single time outside the
   loop. This distinction is important because a |stl-Generator| need not
   return the same result each time it is invoked; it is permitted to read
   from a file, refer to and modify local state, and so on.

   [2] The reason that generate requires its argument to be a mutable
   |stl-ForwardIterator|, rather than just an |stl-OutputIterator|, is that
   it uses a range [first, last) of iterators. There is no sensible way to
   describe a range of |stl-OutputIterator|, because it is impossible to
   compare two |stl-OutputIterator| for equality. The |stl-generate_n|
   algorithm does have an interface that permits use of an
   |stl-OutputIterator|.

  See also

   |stl-copy|, |stl-fill|, |stl-fill_n|, |stl-generate_n|, |stl-iota|

*stl-generate_n*

                                   generate_n

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-OutputIterator|, class Size, class |stl-Generator|>
 OutputIterator generate_n(OutputIterator first, Size n, Generator gen);

  Description

   Generate_n assigns the result of invoking gen, a |stl-functors| that takes
   no arguments, to each element in the range [first, first+n). [2][1] The
   return value is first + n.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

     * OutputIterator is a model of |stl-OutputIterator|.
     * Size is an integral type (either signed or unsigned).
     * Generator is a model of |stl-Generator|.
     * Generator's result type is convertible to a type in OutputIterator's
       set of value types.

  Preconditions

     * n >= 0.
     * There is enough space to hold n values. That is, [first, first+n) is a
       valid range.

  Complexity

   Linear. Exactly n invocations of gen. [5][1]

*stl-generate_n-example*

   Print 100 random numbers, using the C standard library function rand.

 generate_n(|stl-ostream_iterator|<int>(cout, "\n"), 100, rand);

  Notes

   [1] The |stl-functors| gen is invoked n times (once for each iterator in
   the range [first, first+n)), as opposed to just being invoked a single
   time outside the loop. This distinction is important because a
   |stl-Generator| need not return the same result each time it is invoked;
   it is permitted to read from a file, refer to and modify local state, and
   so on.

  See also

   |stl-copy|, |stl-fill|, |stl-fill_n|, |stl-generate|, |stl-iota|

        ________________________________________________________________________
                                        Remove
*stl-remove*

                                     remove

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-ForwardIterator|, class T>
 ForwardIterator remove(ForwardIterator first, ForwardIterator last,
                        const T& value);

  Description

   Remove removes from the range [first, last) all elements that are equal to
   value. That is, remove returns an iterator new_last such that the range
   [first, new_last) contains no elements equal to value. [2][1] The
   iterators in the range [new_last, last) are all still dereferenceable, but
   the elements that they point to are unspecified. Remove is stable, meaning
   that the relative order of elements that are not equal to value is
   unchanged.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * ForwardIterator is mutable.
     * T is a model of |stl-EqualityComparable|.
     * Objects of type T can be compared for equality with objects of
       ForwardIterator's value type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear. Remove performs exactly last - first comparisons for equality.

*stl-remove-example*

 |stl-Vector|<int> V;
 V.push_back(3);
 V.push_back(1);
 V.push_back(4);
 V.push_back(1);
 V.push_back(5);
 V.push_back(9);

 |stl-copy|(V.begin(), V.end(), |stl-ostream_iterator|<int>(cout, " "));
     // The output is "3 1 4 1 5 9".

 vector<int>::iterator new_end = remove(V.begin(), V.end(), 1);
 |stl-copy|(V.begin(), new_end, |stl-ostream_iterator|<int>(cout, " "));
     // The output is "3 4 5 9".

  Notes

   [1] The meaning of "removal" is somewhat subtle. Remove does not destroy
   any iterators, and does not change the distance between first and last.
   (There's no way that it could do anything of the sort.) So, for example,
   if V is a |stl-Vector|, remove(V.begin(), V.end(), 0) does not change
   V.size(): V will contain just as many elements as it did before. Remove
   returns an iterator that points to the end of the resulting range after
   elements have been removed from it; it follows that the elements after
   that iterator are of no interest, and may be discarded. If you are
   removing elements from a |stl-Sequence|, you may simply erase them. That
   is, a reasonable way of removing elements from a |stl-Sequence| is
   S.erase(remove(S.begin(), S.end(), x), S.end()).

  See also

   |stl-remove_if|, |stl-remove_copy|, |stl-remove_copy_if|, |stl-unique|,
   |stl-unique_copy|.

*stl-remove_if*

                                   remove_if

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-ForwardIterator|, class |stl-Predicate|>
 ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,
                           Predicate pred);

  Description

   Remove_if removes from the range [first, last) every element x such that
   pred(x) is true. That is, remove_if returns an iterator new_last such that
   the range [first, new_last) contains no elements for which pred is true.
   [2][1] The iterators in the range [new_last, last) are all still
   dereferenceable, but the elements that they point to are unspecified.
   Remove_if is stable, meaning that the relative order of elements that are
   not removed is unchanged.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * ForwardIterator is mutable.
     * Predicate is a model of |stl-Predicate|.
     * ForwardIterator's value type is convertible to Predicate's argument
       type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear. Remove_if performs exactly last - first applications of pred.

*stl-remove_if-example*

   Remove all even numbers from a vector.

 |stl-Vector|<int> V;
 V.push_back(1);
 V.push_back(4);
 V.push_back(2);
 V.push_back(8);
 V.push_back(5);
 V.push_back(7);

 |stl-copy|(V.begin(), V.end(), |stl-ostream_iterator|<int>(cout, " "));
     // The output is "1 4 2 8 5 7"

 |stl-Vector|<int>::iterator new_end =
         remove_if(V.begin(), V.end(),
                   |stl-unary_compose|(|stl-binder2nd|(|stl-equal_to|<int>(), 0),
                            |stl-binder2nd|(|stl-modulus|<int>(), 2)));
 V.erase(new_end, V.end()); [5][1]

 |stl-copy|(V.begin(), V.end(), |stl-ostream_iterator|<int>(cout, " "));
     // The output is "1 5 7".

  Notes

   [1] The meaning of "removal" is somewhat subtle. Remove_if does not
   destroy any iterators, and does not change the distance between first and
   last. (There's no way that it could do anything of the sort.) So, for
   example, if V is a |stl-Vector|, remove_if(V.begin(), V.end(), pred) does
   not change V.size(): V will contain just as many elements as it did
   before. Remove_if returns an iterator that points to the end of the
   resulting range after elements have been removed from it; it follows that
   the elements after that iterator are of no interest, and may be discarded.
   If you are removing elements from a |stl-Sequence|, you may simply erase
   them. That is, a reasonable way of removing elements from a |stl-Sequence|
   is S.erase(remove_if(S.begin(), S.end(), pred), S.end()).

  See also

   |stl-remove|, |stl-remove_copy|, |stl-remove_copy_if|, |stl-unique|,
   |stl-unique_copy|.

*stl-remove_copy*

                                  remove_copy

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-InputIterator|, class |stl-OutputIterator|, class T>
 OutputIterator remove_copy(InputIterator first, InputIterator last,
                            OutputIterator result, const T& value);

  Description

   Remove_copy copies elements that are not equal to value from the range
   [first, last) to a range beginning at result. The return value is the end
   of the resulting range. This operation is stable, meaning that the
   relative order of the elements that are copied is the same as in the range
   [first, last).

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

     * InputIterator is a model of |stl-InputIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * InputIterator's value type is convertible to a type in
       OutputIterator's set of value types.
     * T is a model of |stl-EqualityComparable|.
     * Objects of type T can be compared for equality with objects of
       InputIterator's value type.

  Preconditions

     * [first, last) is a valid range.
     * There is enough space in the output range to store the copied values.
       That is, if there are n elements in [first, last) that are not equal
       to value, then [result, result+n) is a valid range.
     * result is not an iterator in the range [first, last).

  Complexity

   Linear. Exactly last - first comparisons for equality, and at most last -
   first assignments.

*stl-remove_copy-example*

   Print all nonzero elements of a vector on the standard output.

 |stl-Vector|<int> V;
 V.push_back(-2);
 V.push_back(0);
 V.push_back(-1);
 V.push_back(0);
 V.push_back(1);
 V.push_back(2);

 remove_copy(V.begin(), V.end(),
             |stl-ostream_iterator|<int>(cout, "\n"),
             0);

  See also

   |stl-copy|, |stl-remove|, |stl-remove_if|, |stl-remove_copy_if|,
   |stl-unique|, |stl-unique_copy|.

*stl-remove_copy_if*

                                 remove_copy_if

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-InputIterator|, class |stl-OutputIterator|, class |stl-Predicate|>
 OutputIterator remove_copy_if(InputIterator first, InputIterator last,
                               OutputIterator result, Predicate pred);

  Description

   Remove_copy_if copies elements from the range [first, last) to a range
   beginning at result, except that elements for which pred is true are not
   copied. The return value is the end of the resulting range. This operation
   is stable, meaning that the relative order of the elements that are copied
   is the same as in the range [first, last).

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

     * InputIterator is a model of |stl-InputIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * InputIterator's value type is convertible to a type in
       OutputIterator's set of value types.
     * Predicate is a model of |stl-Predicate|.
     * InputIterator's value type is convertible to Predicate's argument
       type.

  Preconditions

     * [first, last) is a valid range.
     * There is enough space in the output range to store the copied values.
       That is, if there are n elements in [first, last) that do not satisfy
       pred, then [result, result+n) is a valid range.
     * result is not an iterator in the range [first, last).

  Complexity

   Linear. Exactly last - first applications of pred, and at most last -
   first assignments.

*stl-remove_copy_if-example*

   Fill a vector with the nonnegative elements of another vector.

 |stl-Vector|<int> V1;
 V.push_back(-2);
 V.push_back(0);
 V.push_back(-1);
 V.push_back(0);
 V.push_back(1);
 V.push_back(2);

 |stl-Vector|<int> V2;
 remove_copy_if(V1.begin(), V1.end(),
                |stl-back_insert_iterator|(V2),
                |stl-binder2nd|(|stl-less|<int>(), 0));


  See also

   |stl-copy|, |stl-remove|, |stl-remove_if|, |stl-remove_copy|,
   |stl-unique|, |stl-unique_copy|.


*stl-unique*

                                     unique

   Category: algorithms                              Component type: function

  Prototype

   Unique is an overloaded name; there are actually two unique functions.

 template <class |stl-ForwardIterator|>
 ForwardIterator unique(ForwardIterator first, ForwardIterator last);

 template <class |stl-ForwardIterator|, class |stl-BinaryPredicate|>
 ForwardIterator unique(ForwardIterator first, ForwardIterator last,
                        BinaryPredicate binary_pred);

  Description

   Every time a consecutive group of duplicate elements appears in the range
   [first, last), the algorithm unique removes all but the first element.
   That is, unique returns an iterator new_last such that the range [first,
   new_last) contains no two consecutive elements that are duplicates. [2][1]
   The iterators in the range [new_last, last) are all still dereferenceable,
   but the elements that they point to are unspecified. Unique is stable,
   meaning that the relative order of elements that are not removed is
   unchanged.

   The reason there are two different versions of unique is that there are
   two different definitions of what it means for a consecutive group of
   elements to be duplicates. In the first version, the test is simple
   equality: the elements in a range [f, l) are duplicates if, for every
   iterator i in the range, either i == f or else *i == *(i-1). In the
   second, the test is an arbitrary |stl-BinaryPredicate| binary_pred: the
   elements in [f, l) are duplicates if, for every iterator i in the range,
   either i == f or else binary_pred(*i, *(i-1)) is true. [3][2]

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [5]algo.h.

  Requirements on types

   For the first version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * ForwardIterator is mutable.
     * ForwardIterator's value type is |stl-EqualityComparable|.

   For the second version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * ForwardIterator is mutable.
     * BinaryPredicate is a model of |stl-BinaryPredicate|. [6][3]
     * ForwardIterator's value type is convertible to BinaryPredicate's first
       argument type and to BinaryPredicate's second argument type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear. Exactly (last - first) - 1 applications of operator== (in the case
   of the first version of unique) or of binary_pred (in the case of the
   second version).

*stl-unique-example*

   Remove duplicates from consecutive groups of equal ints.

 |stl-Vector|<int> V;
 V.push_back(1);
 V.push_back(3);
 V.push_back(3);
 V.push_back(3);
 V.push_back(2);
 V.push_back(2);
 V.push_back(1);

 |stl-Vector|<int>::iterator new_end = unique(V.begin(), V.end());
 |stl-copy|(V.begin(), new_end, |stl-ostream_iterator|<int>(cout, " "));
     // The output it "1 3 2 1".

   Remove all duplicates from a vector of chars, ignoring case. First sort
   the vector, then remove duplicates from consecutive groups.

 inline bool eq_nocase(char c1, char c2) { return tolower(c1) == tolower(c2); }
 inline bool lt_nocase(char c1, char c2) { return tolower(c1) < tolower(c2); }

 int main()
 {
   const char init[] = "The Standard Template Library";
   |stl-Vector|<char> V(init, init + sizeof(init));
   |stl-sort|(V.begin(), V.end(), lt_nocase);
   |stl-copy|(V.begin(), V.end(), |stl-ostream_iterator|<char>(cout));
   cout << endl;
   |stl-Vector|<char>::iterator new_end = unique(V.begin(), V.end(), eq_nocase);
   |stl-copy|(V.begin(), new_end, |stl-ostream_iterator|<char>(cout));
   cout << endl;
 }
 // The output is:
 //    aaaabddeeehiLlmnprrrStTtTy
 //  abdehiLmnprSty

  Notes

   [1] Note that the meaning of "removal" is somewhat subtle. Unique, like
   |stl-remove|, does not destroy any iterators and does not change the
   distance between first and last. (There's no way that it could do anything
   of the sort.) So, for example, if V is a |stl-Vector|, remove(V.begin(),
   V.end(), 0) does not change V.size(): V will contain just as many elements
   as it did before. Unique returns an iterator that points to the end of the
   resulting range after elements have been removed from it; it follows that
   the elements after that iterator are of no interest. If you are operating
   on a |stl-Sequence|, you may wish to use the |stl-Sequence|'s erase member
   function to discard those elements entirely.

   [2] Strictly speaking, the first version of unique is redundant: you can
   achieve the same functionality by using an object of class |stl-equal_to|
   as the |stl-BinaryPredicate| argument. The first version is provided
   strictly for the sake of convenience: testing for equality is an important
   special case.

   [3] BinaryPredicate is not required to be an equivalence relation. You
   should be cautious, though, about using unique with a
   |stl-BinaryPredicate| that is not an equivalence relation: you could
   easily get unexpected results.

  See also

   |stl-BinaryPredicate|, |stl-remove|, |stl-remove_if|, |stl-unique_copy|,
   |stl-adjacent_find|,

*stl-unique_copy*

                                  unique_copy

   Category: algorithms                              Component type: function

  Prototype

   Unique_copy is an overloaded name; there are actually two unique_copy
   functions.

 template <class |stl-InputIterator|, class |stl-OutputIterator|>
 OutputIterator unique_copy(InputIterator first, InputIterator last,
                            OutputIterator result);

 template <class |stl-InputIterator|, class |stl-OutputIterator|, class |stl-BinaryPredicate|>
 OutputIterator unique_copy(InputIterator first, InputIterator last,
                            OutputIterator result,
                            BinaryPredicate binary_pred);

  Description

   Unique_copy copies elements from the range [first, last) to a range
   beginning with result, except that in a consecutive group of duplicate
   elements only the first one is copied. The return value is the end of the
   range to which the elements are copied. This behavior is similar to the
   Unix filter uniq.

   The reason there are two different versions of unique_copy is that there
   are two different definitions of what it means for a consecutive group of
   elements to be duplicates. In the first version, the test is simple
   equality: the elements in a range [f, l) are duplicates if, for every
   iterator i in the range, either i == f or else *i == *(i-1). In the
   second, the test is an arbitrary |stl-BinaryPredicate| binary_pred: the
   elements in [f, l) are duplicates if, for every iterator i in the range,
   either i == f or else binary_pred(*i, *(i-1)) is true. [2][1]

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

   For the first version:

     * InputIterator is a model of |stl-InputIterator|.
     * InputIterator's value type is |stl-EqualityComparable|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * InputIterator's value type is convertible to a type in
       OutputIterator's set of value types.

   For the second version:

     * InputIterator is a model of |stl-InputIterator|.
     * BinaryPredicate is a model of |stl-BinaryPredicate|. [5][2]
     * InputIterator's value type is convertible to first argument type and
       to BinaryPredicate's second argument type.
     * OutputIterator is a model of |stl-OutputIterator|.
     * InputIterator's value type is convertible to a type in
       OutputIterator's set of value types.

  Preconditions

     * [first, last) is a valid range.
     * There is enough space to hold all of the elements being copied. More
       formally, if there are n elements in the range [first, last) after
       duplicates are removed from consecutive groups, then [result, result +
       n) must be a valid range.

  Complexity

   Linear. Exactly last - first applications of operator== (in the case of
   the first version of unique) or of binary_pred (in the case of the second
   version), and at most last - first assignments.

*stl-unique_copy-example*

   Print all of the numbers in an array, but only print the first one in a
   consecutive group of identical numbers.

 const int A[] = {2, 7, 7, 7, 1, 1, 8, 8, 8, 2, 8, 8};
 unique_copy(A, A + sizeof(A) / sizeof(int),
             |stl-ostream_iterator|<int>(cout, " "));
 // The output is "2 7 1 8 2 8".

  Notes

   [1] Strictly speaking, the first version of unique_copy is redundant: you
   can achieve the same functionality by using an object of class
   |stl-equal_to| as the |stl-BinaryPredicate| argument. The first version is
   provided strictly for the sake of convenience: testing for equality is an
   important special case.

   [2] BinaryPredicate is not required to be an equivalence relation. You
   should be cautious, though, about using unique_copy with a
   |stl-BinaryPredicate| that is not an equivalence relation: you could
   easily get unexpected results.

  See also

   |stl-BinaryPredicate|, |stl-unique|, |stl-remove_copy|,
   |stl-remove_copy_if|, |stl-adjacent_find|

*stl-reverse*

                                    reverse

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-BidirectionalIterator|>
 void reverse(BidirectionalIterator first, BidirectionalIterator last);

  Description

   Reverse reverses a range. That is: for every i such that 0 <= i <= (last -
   first) / 2), it exchanges *(first + i) and *(last - (i + 1)).

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

     * BidirectionalIterator is a model of |stl-BidirectionalIterator|.
     * BidirectionalIterator is mutable.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear: reverse(first, last) makes (last - first) / 2 calls to |stl-swap|.

*stl-reverse-example*

 |stl-Vector|<int> V;
 V.push_back(0);
 V.push_back(1);
 V.push_back(2);
 |stl-copy|(V.begin(), V.end(), |stl-ostream_iterator|<int>(cout, " "));
                 // Output: 0 1 2
 reverse(V.begin(), V.end());
 |stl-copy|(V.begin(), V.end(), |stl-ostream_iterator|<int>(cout, " "));
                 // Output: 2 1 0

  See also

   |stl-reverse_copy|

*stl-reverse_copy*

                                  reverse_copy

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-BidirectionalIterator|, class |stl-OutputIterator|>
 OutputIterator reverse_copy(BidirectionalIterator first,
                             BidirectionalIterator last,
                             OutputIterator result);

  Description

   Reverse_copy copies elements from the range [first, last) to the range
   [result, result + (last - first)) such that the copy is a reverse of the
   original range. Specifically: for every i such that 0 <= i < (last -
   first), reverse_copy performs the assignment *(result + (last - first) -
   i) = *(first + i).

   The return value is result + (last - first).

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

     * BidirectionalIterator is a model of |stl-BidirectionalIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * The value type of BidirectionalIterator is convertible to a type in
       OutputIterator's set of value types.

  Preconditions

     * [first, last) is a valid range.
     * There is enough space to hold all of the elements being copied. More
       formally, the requirement is that [result, result + (last - first)) is
       a valid range.
     * The ranges [first, last) and [result, result + (last - first)) do not
       overlap.

  Complexity

   Linear: exactly last - first assignments.

*stl-reverse_copy-example*

 |stl-Vector|<int> V;
 V.push_back(0);
 V.push_back(1);
 V.push_back(2);
 |stl-copy|(V.begin(), V.end(), |stl-ostream_iterator|<int>(cout, " "));
                 // Output: 0 1 2
 |stl-List|<int> L(V.size());
 reverse_copy(V.begin(), V.end(), L.begin());
 |stl-copy|(L.begin(), L.end(), |stl-ostream_iterator|<int>(cout, " "));
                 // Output: 2 1 0

  See also

   |stl-reverse|, |stl-copy|

*stl-rotate*

                                     rotate

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-ForwardIterator|>
 inline ForwardIterator rotate(ForwardIterator first, ForwardIterator middle,
                    ForwardIterator last);

  Description

   Rotate rotates the elements in a range. That is, the element pointed to by
   middle is moved to the position first, the element pointed to by middle +
   1 is moved to the position first + 1, and so on. One way to think about
   this operation is that it exchanges the two ranges [first, middle) and
   [middle, last). Formally, for every integer n such that 0 <= n < last -
   first, the element *(first + n) is assigned to *(first + (n + (last -
   middle)) % (last - first)). Rotate returns first + (last - middle).

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * ForwardIterator is mutable.

  Preconditions

     * [first, middle) is a valid range.
     * [middle, last) is a valid range. [4][1]

  Complexity

   Linear. At most last - first swaps are performed. [5][2]

*stl-rotate-example*

 char alpha[] = "abcdefghijklmnopqrstuvwxyz";
 rotate(alpha, alpha + 13, alpha + 26);
 printf("%s\n", alpha);
 // The output is nopqrstuvwxyzabcdefghijklm

  Notes

   [1] It follows from these two requirements that [first, last) is a valid
   range.

   [2] Rotate uses a different algorithm depending on whether its arguments
   are |stl-ForwardIterator|, |stl-BidirectionalIterator|, or
   |stl-RandomAccessIterator|. All three algorithms, however, are linear.

  See also

   |stl-rotate_copy|

*stl-rotate_copy*

                                  rotate_copy

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-ForwardIterator|, class |stl-OutputIterator|>
 OutputIterator rotate_copy(ForwardIterator first, ForwardIterator middle,
                            ForwardIterator last, OutputIterator result);

  Description

   Rotate_copy copies elements from the range [first, last) to the range
   [result, result + (last - first)) such that *middle is copied to *result,
   *(middle + 1) is copied to *(result + 1), and so on. Formally, for every
   integer n such that 0 <= n < last - first, rotate_copy performs the
   assignment *(result + (n + (last - middle)) % (last - first)) = *(first +
   n). Rotate_copy is similar to |stl-copy| followed by |stl-rotate|, but is
   more efficient. The return value is result + (last - first).

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * ForwardIterator's value type is convertible to a type in
       OutputIterator's set of value types.

  Preconditions

     * [first, middle) is a valid range.
     * [middle, last) is a valid range. [4][1]
     * There is enough space to hold all of the elements being copied. More
       formally, the requirement is that [result, result + (last - first)) is
       a valid range.
     * The ranges [first, last) and [result, result + (last - first)) do not
       overlap.

  Complexity

   Linear. Rotate_copy performs exactly last - first assignments.

*stl-rotate_copy-example*

 const char alpha[] = "abcdefghijklmnopqrstuvwxyz";
 rotate_copy(alpha, alpha + 13, alpha + 26, |stl-ostream_iterator|<char>(cout));
 // The output is nopqrstuvwxyzabcdefghijklm

  Notes

   [1] It follows from these two requirements that [first, last) is a valid
   range.

  See also

   |stl-rotate|, |stl-copy|.

*stl-random_shuffle*

                                 random_shuffle

   Category: algorithms                              Component type: function

  Prototype

   Random_shuffle is an overloaded name; there are actually two
   random_shuffle functions.

 template <class |stl-RandomAccessIterator|>
 void random_shuffle(RandomAccessIterator first, RandomAccessIterator last);

 template <class |stl-RandomAccessIterator|, class |stl-RandomNumberGenerator|>
 void random_shuffle(RandomAccessIterator first, RandomAccessIterator last,
                     RandomNumberGenerator& rand)

  Description

   Random_shuffle randomly rearranges the elements in the range [first,
   last): that is, it randomly picks one of the N! possible orderings, where
   N is last - first. [2][1] There are two different versions of
   random_shuffle. The first version uses an internal random number
   generator, and the second uses a |stl-RandomNumberGenerator|, a special
   kind of |stl-functors|, that is explicitly passed as an argument.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

   For the first version:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|

   For the second version:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|
     * RandomNumberGenerator is a model of |stl-RandomNumberGenerator|
     * RandomAccessIterator's distance type is convertible to
       RandomNumberGenerator's argument type.

  Preconditions

     * [first, last) is a valid range.
     * last - first is less than rand's maximum value.

  Complexity

   Linear in last - first. If last != first, exactly (last - first) - 1 swaps
   are performed.

*stl-random_shuffle-example*

 const int N = 8;
 int A[] = {1, 2, 3, 4, 5, 6, 7, 8};
 random_shuffle(A, A + N);
 |stl-copy|(A, A + N, |stl-ostream_iterator|<int>(cout, " "));
 // The printed result might be 7 1 6 3 2 5 4 8,
 //  or any of 40,319 other possibilities.

  Notes

   [1] This algorithm is described in section 3.4.2 of Knuth (D. E. Knuth,
   The Art of Computer Programming. Volume 2: Seminumerical Algorithms,
   second edition. Addison-Wesley, 1981). Knuth credits Moses and Oakford
   (1963) and Durstenfeld (1964). Note that there are N! ways of arranging a
   sequence of N elements. Random_shuffle yields uniformly distributed
   results; that is, the probability of any particular ordering is 1/N!. The
   reason this comment is important is that there are a number of algorithms
   that seem at first sight to implement random shuffling of a sequence, but
   that do not in fact produce a uniform distribution over the N! possible
   orderings. That is, it's easy to get random shuffle wrong.

  See also

   |stl-random_sample|, |stl-random_sample_n|, |stl-next_permutation|,
   |stl-prev_permutation|, |stl-RandomNumberGenerator|

*stl-random_sample*

                                 random_sample

   Category: algorithms                              Component type: function

  Prototype

   Random_sample is an overloaded name; there are actually two random_sample
   functions.

 template <class |stl-InputIterator|, class |stl-RandomAccessIterator|>
 Random AccessIterator
 random_sample(InputIterator first, InputIterator last,
               RandomAccessIterator ofirst, RandomAccessIterator olast)

 template <class |stl-InputIterator|, class |stl-RandomAccessIterator|,
           class |stl-RandomNumberGenerator|>
 random_sample(InputIterator first, InputIterator last,
               RandomAccessIterator ofirst, RandomAccessIterator olast,
               RandomNumberGenerator& rand)

  Description

   Random_sample randomly copies a sample of the elements from the range
   [first, last) into the range [ofirst, olast). Each element in the input
   range appears at most once in the output range, and samples are chosen
   with uniform probability. [2][1] Elements in the output range might appear
   in any order: relative order within the input range is not guaranteed to
   be preserved. [3][2]

   Random_sample copies n elements from [first, last) to [ofirst, olast),
   where n is min(last - first, olast - ofirst). The return value is ofirst +
   n.

   The first version uses an internal random number generator, and the second
   uses a |stl-RandomNumberGenerator|, a special kind of |stl-functors|, that
   is explicitly passed as an argument.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [5]algo.h. This function is an SGI
   extension; it is not part of the C++ standard.

  Requirements on types

   For the first version:

     * InputIterator is a model of |stl-InputIterator|
     * RandomAccessIterator is a model of |stl-RandomAccessIterator|
     * RandomAccessIterator is mutable.
     * InputIterator's value type is convertible to RandomAccessIterator's
       value type.

   For the second version:

     * InputIterator is a model of |stl-InputIterator|
     * RandomAccessIterator is a model of |stl-RandomAccessIterator|
     * RandomAccessIterator is mutable.
     * RandomNumberGenerator is a model of |stl-RandomNumberGenerator|
     * InputIterator's value type is convertible to RandomAccessIterator's
       value type.
     * RandomAccessIterator's distance type is convertible to
       RandomNumberGenerator's argument type.

  Preconditions

     * [first, last) is a valid range.
     * [ofirst, olast) is a valid range.
     * [first, last) and [ofirst, olast) do not overlap.
     * last - first is less than rand's maximum value.

  Complexity

   Linear in last - first. At most last - first elements are copied from the
   input range to the output range.

*stl-random_sample-example*

 int main()
 {
   const int N = 10;
   const int n = 4;
   int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   int B[n];

   random_sample(A, A+N, B, B+n);
   |stl-copy|(B, B + n, |stl-ostream_iterator|<int>(cout, " "));
   // The printed value might be 1 6 3 5,
   //  or any of 5039 other possibilities.
 }

  Notes

   [1] This is "Algorithm R" from section 3.4.2 of Knuth (D. E. Knuth, The
   Art of Computer Programming. Volume 2: Seminumerical Algorithms, second
   edition. Addison-Wesley, 1981). Knuth credits Alan Waterman. Note that
   there are N! / n! / (N - n)! ways of selecting a sample of n elements from
   a range of N elements. Random_sample yields uniformly distributed results;
   that is, the probability of selecting any particular element is n / N, and
   the probability of any particular sampling (not considering order of
   elements) is n! * (N - n)! / N!.

   [2] If preservation of the relative ordering within the input range is
   important for your application, you should use |stl-random_sample_n|
   instead. The main restriction of |stl-random_sample_n| is that the input
   range must consist of |stl-ForwardIterator|, rather than
   |stl-InputIterator|.

  See also

   |stl-random_shuffle|, |stl-random_sample_n|, |stl-RandomNumberGenerator|

*stl-random_sample_n*

                                random_sample_n

   Category: algorithms                              Component type: function

  Prototype

   Random_sample_n is an overloaded name; there are actually two
   random_sample_n functions.

 template <class |stl-ForwardIterator|, class |stl-OutputIterator|, class Distance>
 OutputIterator random_sample_n(ForwardIterator first, ForwardIterator last,
                                OutputIterator out, Distance n)

 template <class |stl-ForwardIterator|, class |stl-OutputIterator|, class Distance,
           class |stl-RandomNumberGenerator|>
 OutputIterator random_sample_n(ForwardIterator first, ForwardIterator last,
                                OutputIterator out, Distance n,
                                RandomNumberGenerator& rand)

  Description

   Random_sample_n randomly copies a sample of the elements from the range
   [first, last) into the range [out, out + n). Each element in the input
   range appears at most once in the output range, and samples are chosen
   with uniform probability. [2][1] Elements in the output range appear in
   the same relative order as their relative order within the input range.
   [3][2]

   Random_sample copies m elements from [first, last) to [out, out + m),
   where m is min(last - first, n). The return value is out + m.

   The first version uses an internal random number generator, and the second
   uses a |stl-RandomNumberGenerator|, a special kind of |stl-functors|, that
   is explicitly passed as an argument.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [5]algo.h. This function is an SGI
   extension; it is not part of the C++ standard.

  Requirements on types

   For the first version:

     * ForwardIterator is a model of |stl-ForwardIterator|
     * OutputIterator is a model of |stl-OutputIterator|
     * ForwardIterator's value type is convertible to a type in
       OutputIterator's set of value types.
     * Distance is an integral type that is large enough to represent the
       value last - first.

   For the second version:

     * ForwardIterator is a model of |stl-ForwardIterator|
     * OutputIterator is a model of |stl-OutputIterator|
     * RandomNumberGenerator is a model of |stl-RandomNumberGenerator|
     * Distance is an integral type that is large enough to represent the
       value last - first.
     * ForwardIterator's value type is convertible to a type in
       OutputIterator's set of value types.
     * Distance is convertible to RandomNumberGenerator's argument type.

  Preconditions

     * [first, last) is a valid range.
     * n is nonnegative.
     * [first, last) and [out, out + n) do not overlap.
     * There is enough space to hold all of the elements being copied. More
       formally, the requirement is that [out, out + min(n, last - first)) is
       a valid range.
     * last - first is less than rand's maximum value.

  Complexity

   Linear in last - first. At most last - first elements from the input range
   are examined, and exactly min(n, last - first) elements are copied to the
   output range.

*stl-random_sample_n-example*

 int main()
 {
   const int N = 10;
   int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

   random_sample_n(A, A+N, ostream_iterator<int>(cout, " "), 4);
   // The printed value might be 3 5 6 10,
   //  or any of 209 other possibilities.
 }

  Notes

   [1] This is "Algorithm S" from section 3.4.2 of Knuth (D. E. Knuth, The
   Art of Computer Programming. Volume 2: Seminumerical Algorithms, second
   edition. Addison-Wesley, 1981). Knuth credits C. T. Fan, M. E. Muller, and
   I. Rezucha (1962) and T. G. Jones (1962). Note that there are N! / n! / (N
   - n)! ways of selecting a sample of n elements from a range of N elements.
   Random_sample_n yields uniformly distributed results; that is, the
   probability of selecting any particular element is n / N, and the
   probability of any particular sampling is n! * (N - n)! / N!.

   [2] In contrast, the |stl-random_sample| algorithm does not preserve
   relative ordering within the input range. The other major distinction
   between the two algorithms is that random_sample_n requires its input
   range to be |stl-ForwardIterator| and only requires its output range to be
   |stl-OutputIterator|, while |stl-random_sample| only requires its input
   range to be |stl-InputIterator| and requires its output range to be
   |stl-RandomAccessIterator|.

  See also

   |stl-random_shuffle|, |stl-random_sample|, |stl-RandomNumberGenerator|

*stl-partition*

                                   partition

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-ForwardIterator|, class |stl-Predicate|>
 ForwardIterator partition(ForwardIterator first,
                           ForwardIterator last, Predicate pred)

  Description

   Partition reorders the elements in the range [first, last) based on the
   |stl-functors| pred, such that the elements that satisfy pred precede the
   elements that fail to satisfy it. The postcondition is that, for some
   iterator middle in the range [first, last), pred(*i) is true for every
   iterator i in the range [first, middle) and false for every iterator i in
   the range [middle, last). [2][1] The return value of partition is middle.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * Predicate is a model of |stl-Predicate|.
     * ForwardIterator's value type is convertible to Predicate's argument
       type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear. Exactly last - first applications of pred, and at most (last -
   first)/2 swaps.

*stl-partition-example*

   Reorder a sequence so that even numbers precede odd numbers.

 int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
 const int N = sizeof(A)/sizeof(int);
 partition(A, A + N,
           |stl-unary_compose|(|stl-binder2nd|(|stl-equal_to|<int>(), 0),
                    |stl-binder2nd|(|stl-modulus|<int>(), 2)));
 |stl-copy|(A, A + N, |stl-ostream_iterator|<int>(cout, " "));
 // The output is "10 2 8 4 6 5 7 3 9 1". [5][1]

  Notes

   [1] The relative order of elements in these two blocks is not necessarily
   the same as it was in the original sequence. A different algorithm,
   |stl-stable_partition|, does guarantee to preserve the relative order.

  See also

   |stl-stable_partition|, |stl-Predicate|, |stl-functors|

*stl-stable_partition*

                                stable_partition

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-ForwardIterator|, class |stl-Predicate|>
 ForwardIterator stable_partition(ForwardIterator first, ForwardIterator last,
                                  Predicate pred);

  Description

   Stable_partition is much like |stl-partition|: it reorders the elements in
   the range [first, last) based on the |stl-functors| pred, such that all of
   the elements that satisfy pred appear before all of the elements that fail
   to satisfy it. The postcondition is that, for some iterator middle in the
   range [first, last), pred(*i) is true for every iterator i in the range
   [first, middle) and false for every iterator i in the range [middle,
   last). The return value of stable_partition is middle.

   Stable_partition differs from |stl-partition| in that stable_partition is
   guaranteed to preserve relative order. That is, if x and y are elements in
   [first, last) such that pred(x) == pred(y), and if x precedes y, then it
   will still be true after stable_partition is true that x precedes y.
   [2][1]

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

     * ForwardIterator is a model of |stl-ForwardIterator|
     * Predicate is a model of |stl-Predicate|
     * ForwardIterator's value type is convertible to Predicate's argument
       type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Stable_partition is an adaptive algorithm: it attempts to allocate a
   temporary memory buffer, and its run-time complexity depends on how much
   memory is available. Worst-case behavior (if no auxiliary memory is
   available) is at most N*log(N) swaps, where N is last - first, and best
   case (if a large enough auxiliary memory buffer is available) is linear in
   N. In either case, pred is applied exactly N times.

*stl-stable_partition-example*

   Reorder a sequence so that even numbers precede odd numbers.

 int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
 const int N = sizeof(A)/sizeof(int);
 stable_partition(A, A + N,
                  |stl-unary_compose|(|stl-binder2nd|(|stl-equal_to|<int>(), 0),
                           |stl-binder2nd|(|stl-modulus|<int>(), 2)));
 |stl-copy|(A, A + N, |stl-ostream_iterator|<int>(cout, " "));
 // The output is "2 4 6 8 10 1 3 5 7 9". [5][1]

  Notes

   [1] Note that the complexity of stable_partition is greater than that of
   |stl-partition|: the guarantee that relative order will be preserved has a
   significant runtime cost. If this guarantee isn't important to you, you
   should use |stl-partition|.

  See also

   |stl-partition|, |stl-Predicate|, |stl-functors|



    ----------------------------------------------------------------------------
                                     Sorting
    ----------------------------------------------------------------------------
        ________________________________________________________________________
                                         Sort
*stl-sort*

                                      sort

   Category: algorithms                              Component type: function

  Prototype

   Sort is an overloaded name; there are actually two sort functions.

 template <class |stl-RandomAccessIterator|>
 void sort(RandomAccessIterator first, RandomAccessIterator last);

 template <class RandomAccessIterator, class |stl-StrictWeakOrdering|>
 void sort(RandomAccessIterator first, RandomAccessIterator last,
           StrictWeakOrdering comp);

  Description

   Sort sorts the elements in [first, last) into ascending order, meaning
   that if i and j are any two valid iterators in [first, last) such that i
   precedes j, then *j is not less than *i. Note: sort is not guaranteed to
   be stable. That is, suppose that *i and *j are equivalent: neither one is
   less than the other. It is not guaranteed that the relative order of these
   two elements will be preserved by sort. [2][1]

   The two versions of sort differ in how they define whether one element is
   less than another. The first version compares objects using operator<, and
   the second compares objects using a |stl-functors| comp.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

   For the first version, the one that takes two arguments:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * RandomAccessIterator is mutable.
     * RandomAccessIterator's value type is |stl-LessThanComparable|.
     * The ordering relation on RandomAccessIterator's value type is a strict
       weak ordering, as defined in the |stl-LessThanComparable|
       requirements.

   For the second version, the one that takes three arguments:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * RandomAccessIterator is mutable.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * RandomAccessIterator's value type is convertible to
       StrictWeakOrdering's argument type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   O(N log(N)) comparisons (both average and worst-case), where N is last -
   first. [5][2]

*stl-sort-example*

 int A[] = {1, 4, 2, 8, 5, 7};
 const int N = sizeof(A) / sizeof(int);
 sort(A, A + N);
 copy(A, A + N, ostream_iterator<int>(cout, " "));
 // The output is " 1 2 4 5 7 8".

  Notes

   [1] Stable sorting is sometimes important if you are sorting records that
   have multiple fields: you might, for example, want to sort a list of
   people by first name and then by last name. The algorithm
   |stl-stable_sort| does guarantee to preserve the relative ordering of
   equivalent elements.

   [2] Earlier versions of sort used the quicksort algorithm (C. A. R. Hoare,
   Comp. J. 5, 1962), using a pivot chosen by median of three (R. C.
   Singleton, CACM 12, 1969). Quicksort has O(N log(N)) average complexity,
   but quadratic worst-case complexity. See section 5.2.2 of Knuth for a
   discussion. (D. E. Knuth, The Art of Computer Programming. Volume 3:
   Sorting and Searching. Addison-Wesley, 1975.) The current implementation
   of sort, however, uses the introsort algorithm (D. R. Musser,
   "Introspective Sorting and Selection Algorithms", Software Practice and
   Experience 27(8):983, 1997.) whose worst case complexity is O(N log(N)).
   Introsort is very similar to median-of-three quicksort, and is at least as
   fast as quicksort on average.

  See also

   |stl-stable_sort|, |stl-partial_sort|, |stl-partial_sort_copy|,
   |stl-sort_heap|, |stl-is_sorted|, |stl-binary_search|, |stl-lower_bound|,
   |stl-upper_bound|, |stl-less|<T>, |stl-StrictWeakOrdering|,
   |stl-LessThanComparable|

*stl-stable_sort*

                                  stable_sort

   Category: algorithms                              Component type: function

  Prototype

   Stable_sort is an overloaded name; there are actually two stable_sort
   functions.

 template <class |stl-RandomAccessIterator|>
 void stable_sort(RandomAccessIterator first, RandomAccessIterator last);

 template <class |stl-RandomAccessIterator|, class |stl-StrictWeakOrdering|>
 void stable_sort(RandomAccessIterator first, RandomAccessIterator last,
                  StrictWeakOrdering comp);

  Description

   Stable_sort is much like |stl-sort|: it sorts the elements in [first,
   last) into ascending order, meaning that if i and j are any two valid
   iterators in [first, last) such that i precedes j, then *j is not less
   than *i. Stable_sort differs from |stl-sort| in two ways. First,
   stable_sort uses an algorithm that has different run-time complexity than
   |stl-sort|. Second, as the name suggests, stable_sort is stable: it
   preserves the relative ordering of equivalent elements. That is, if x and
   y are elements in [first, last) such that x precedes y, and if the two
   elements are equivalent (neither x < y nor y < x) then a postcondition of
   stable_sort is that x still precedes y. [2][1]

   The two versions of stable_sort differ in how they define whether one
   element is less than another. The first version compares objects using
   operator<, and the second compares objects using a |stl-functors| comp.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

   For the first version, the one that takes two arguments:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * RandomAccessIterator is mutable.
     * RandomAccessIterator's value type is |stl-LessThanComparable|.
     * The ordering relation on RandomAccessIterator's value type is a strict
       weak ordering, as defined in the |stl-LessThanComparable|
       requirements.

   For the second version, the one that takes three arguments:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * RandomAccessIterator is mutable.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * RandomAccessIterator's value type is convertible to
       StrictWeakOrdering's argument type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Stable_sort is an adaptive algorithm: it attempts to allocate a temporary
   memory buffer, and its run-time complexity depends on how much memory is
   available. Worst-case behavior (if no auxiliary memory is available) is N
   (log N)^2 comparisons, where N is last - first, and best case (if a large
   enough auxiliary memory buffer is available) is N (log N). [5][2]

*stl-stable_sort-example*

   Sort a sequence of characters, ignoring their case. Note that the relative
   order of characters that differ only by case is preserved.

 inline bool lt_nocase(char c1, char c2) { return tolower(c1) < tolower(c2); }

 int main()
 {
   char A[] = "fdBeACFDbEac";
   const int N = sizeof(A) - 1;
   stable_sort(A, A+N, lt_nocase);
   printf("%s\n", A);
   // The printed result is ""AaBbCcdDeEfF".
 }

  Notes

   [1] Note that two elements may be equivalent without being equal. One
   standard example is sorting a sequence of names by last name: if two
   people have the same last name but different first names, then they are
   equivalent but not equal. This is why stable_sort is sometimes useful: if
   you are sorting a sequence of records that have several different fields,
   then you may want to sort it by one field without completely destroying
   the ordering that you previously obtained from sorting it by a different
   field. You might, for example, sort by first name and then do a stable
   sort by last name.

   [2] Stable_sort uses the merge sort algorithm; see section 5.2.4 of Knuth.
   (D. E. Knuth, The Art of Computer Programming. Volume 3: Sorting and
   Searching. Addison-Wesley, 1975.)

  See also

   |stl-sort|, |stl-partial_sort|, |stl-partial_sort_copy|,
   |stl-binary_search|, |stl-lower_bound|, |stl-upper_bound|, |stl-less|<T>,
   |stl-StrictWeakOrdering|, |stl-LessThanComparable|

*stl-partial_sort*

                                  partial_sort

   Category: algorithms                              Component type: function

  Prototype

   Partial_sort is an overloaded name; there are actually two partial_sort
   functions.

 template <class |stl-RandomAccessIterator|>
 void partial_sort(RandomAccessIterator first,
                   RandomAccessIterator middle,
                   RandomAccessIterator last);

 template <class |stl-RandomAccessIterator|, class |stl-StrictWeakOrdering|>
 void partial_sort(RandomAccessIterator first,
                   RandomAccessIterator middle,
                   RandomAccessIterator last,
                   StrictWeakOrdering comp);

  Description

   Partial_sort rearranges the elements in the range [first, last) so that
   they are partially in ascending order. Specifically, it places the
   smallest middle - first elements, sorted in ascending order, into the
   range [first, middle). The remaining last - middle elements are placed, in
   an unspecified order, into the range [middle, last). [2][1] [3][2]

   The two versions of partial_sort differ in how they define whether one
   element is less than another. The first version compares objects using
   operator<, and the second compares objects using a |stl-functors| comp.

   The postcondition for the first version of partial_sort is as follows. If
   i and j are any two valid iterators in the range [first, middle) such that
   i precedes j, and if k is a valid iterator in the range [middle, last),
   then *j < *i and *k < *i will both be false. The corresponding
   postcondition for the second version of partial_sort is that comp(*j, *i)
   and comp(*k, *i) are both false. Informally, this postcondition means that
   the first middle - first elements are in ascending order and that none of
   the elements in [middle, last) is less than any of the elements in [first,
   middle).

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [5]algo.h.

  Requirements on types

   For the first version:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * RandomAccessIterator is mutable.
     * RandomAccessIterator's value type is |stl-LessThanComparable|.
     * The ordering relation on RandomAccessIterator's value type is a strict
       weak ordering, as defined in the |stl-LessThanComparable|
       requirements.

   For the second version:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * RandomAccessIterator is mutable.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * RandomAccessIterator's value type is convertible to
       StrictWeakOrdering's argument type.

  Preconditions

     * [first, middle) is a valid range.
     * [middle, last) is a valid range.

   (It follows from these two conditions that [first, last) is a valid
   range.)

  Complexity

   Approximately (last - first) * log(middle - first) comparisons.

*stl-partial_sort-example*

 int A[] = {7, 2, 6, 11, 9, 3, 12, 10, 8, 4, 1, 5};
 const int N = sizeof(A) / sizeof(int);

 partial_sort(A, A + 5, A + N);
 copy(A, A + N, ostream_iterator<int>(cout, " "));
 // The printed result is "1 2 3 4 5 11 12 10 9 8 7 6".

  Notes

   [1] Note that the elements in the range [first, middle) will be the same
   (ignoring, for the moment, equivalent elements) as if you had sorted the
   entire range using sort(first, last). The reason for using partial_sort in
   preference to sort is simply efficiency: a partial sort, in general, takes
   less time.

   [2] partial_sort(first, last, last) has the effect of sorting the entire
   range [first, last), just like |stl-sort|(first, last). They use different
   algorithms, however: sort uses the introsort algorithm (a variant of
   quicksort), and partial_sort uses heapsort. See section 5.2.3 of Knuth (D.
   E. Knuth, The Art of Computer Programming. Volume 3: Sorting and
   Searching. Addison-Wesley, 1975.), and J. W. J. Williams (CACM 7, 347,
   1964). Both heapsort and introsort have complexity of order N log(N), but
   introsort is usually faster by a factor of 2 to 5.

  See also

   |stl-partial_sort_copy|, |stl-sort|, |stl-stable_sort|,
   |stl-binary_search|, |stl-lower_bound|, |stl-upper_bound|, |stl-less|<T>,
   |stl-StrictWeakOrdering|, |stl-LessThanComparable|

*stl-partial_sort_copy*

                               partial_sort_copy

   Category: algorithms                              Component type: function

  Prototype

   Partial_sort_copy is an overloaded name; there are actually two
   partial_sort_copy functions.

 template <class |stl-InputIterator|, class |stl-RandomAccessIterator|>
 RandomAccessIterator
 partial_sort_copy(InputIterator first, InputIterator last,
                   RandomAccessIterator result_first,
                   RandomAccessIterator result_last);

 template <class |stl-InputIterator|, class |stl-RandomAccessIterator|,
           class |stl-StrictWeakOrdering|>
 RandomAccessIterator
 partial_sort_copy(InputIterator first, InputIterator last,
                   RandomAccessIterator result_first,
                   RandomAccessIterator result_last, Compare comp);

  Description

   Partial_sort_copy copies the smallest N elements from the range [first,
   last) to the range [result_first, result_first + N), where N is the
   smaller of last - first and result_last - result_first. The elements in
   [result_first, result_first + N) will be in ascending order.

   The two versions of partial_sort_copy differ in how they define whether
   one element is less than another. The first version compares objects using
   operator<, and the second compares objects using a |stl-functors| comp.

   The postcondition for the first version of partial_sort_copy is as
   follows. If i and j are any two valid iterators in the range
   [result_first, result_first + N) such that i precedes j, then *j < *i will
   be false. The corresponding postcondition for the second version is that
   comp(*j, *i) will be false.

   The return value is result_first + N.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

   For the first version:

     * InputIterator is a model of |stl-InputIterator|.
     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * RandomAccessIterator is mutable.
     * The value types of InputIterator and RandomAccessIterator are the
       same.
     * RandomAccessIterator's value type is |stl-LessThanComparable|.
     * The ordering relation on RandomAccessIterator's value type is a strict
       weak ordering, as defined in the |stl-LessThanComparable|
       requirements.

   For the second version:

     * InputIterator is a model of |stl-InputIterator|.
     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * RandomAccessIterator is mutable.
     * The value types of InputIterator and RandomAccessIterator are the
       same.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * RandomAccessIterator's value type is convertible to
       StrictWeakOrdering's argument type.

  Preconditions

     * [first, last) is a valid range.
     * [result_first, result_last) is a valid range.
     * [first, last) and [result_first, result_last) do not overlap.

  Complexity

   Approximately (last - first) * log(N) comparisons, where N is the smaller
   of last - first and result_last - result_first.

*stl-partial_sort_copy-example*

 int A[] = {7, 2, 6, 11, 9, 3, 12, 10, 8, 4, 1, 5};
 const int N = sizeof(A) / sizeof(int);

 vector<int> V(4);
 partial_sort_copy(A, A + N, V.begin(), V.end());
 copy(V.begin(), V.end(), ostream_iterator<int>(cout, " "));
 // The printed result is "1 2 3 4".

  See also

   |stl-partial_sort|, |stl-sort|, |stl-stable_sort|, |stl-binary_search|,
   |stl-lower_bound|, |stl-upper_bound|, |stl-less|<T>,
   |stl-StrictWeakOrdering|, |stl-LessThanComparable|

*stl-is_sorted*

                                   is_sorted

   Category: algorithms                              Component type: function

  Prototype

   Is_sorted is an overloaded name; there are actually two is_sorted
   functions.

 template <class |stl-ForwardIterator|>
 bool is_sorted(ForwardIterator first, ForwardIterator last)

 template <class |stl-ForwardIterator|, class |stl-StrictWeakOrdering|>
 bool is_sorted(ForwardIterator first, ForwardIterator last,
                StrictWeakOrdering comp)

  Description

   Is_sorted returns true if the range [first, last) is sorted in ascending
   order, and false otherwise.

   The two versions of is_sorted differ in how they define whether one
   element is less than another. The first version compares objects using
   operator<, and the second compares objects using the |stl-functors| comp.
   The first version of is_sorted returns true if and only if, for every
   iterator i in the range [first, last - 1), *(i + 1) < *i is false. The
   second version returns true if and only if, for every iterator i in the
   range [first, last - 1), comp(*(i + 1), *i) is false

  Definition

   Defined in [2]algo.h.

  Requirements on types

   For the first version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * ForwardIterator's value type is a model of |stl-LessThanComparable|.
     * The ordering on objects of ForwardIterator's value type is a strict
       weak ordering, as defined in the |stl-LessThanComparable|
       requirements.

   For the second version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * ForwardIterator's value type is convertible to StrictWeakOrdering's
       argument type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear. Zero comparisons if [first, last) is an empty range, otherwise at
   most (last - first) - 1 comparisons.

*stl-is_sorted-example*

 int A[] = {1, 4, 2, 8, 5, 7};
 const int N = sizeof(A) / sizeof(int);

 assert(!is_sorted(A, A + N));
 |stl-sort|(A, A + N);
 assert(is_sorted(A, A + N));

  See also

   |stl-sort|, |stl-stable_sort|, |stl-partial_sort|,
   |stl-partial_sort_copy|, |stl-sort_heap|, |stl-binary_search|,
   |stl-lower_bound|, |stl-upper_bound|, |stl-less|<T>,
   |stl-StrictWeakOrdering|, |stl-LessThanComparable|


        ________________________________________________________________________
                                  |stl-nth_element|
*stl-nth_element*

                                  nth_element

   Category: algorithms                              Component type: function

  Prototype

   Nth_element is an overloaded name; there are actually two nth_element
   functions.

 template <class |stl-RandomAccessIterator|>
 void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                  RandomAccessIterator last);

 template <class |stl-RandomAccessIterator|, class |stl-StrictWeakOrdering|>
 void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                  RandomAccessIterator last, StrictWeakOrdering comp);

  Description

   Nth_element is similar to |stl-partial_sort|, in that it partially orders
   a range of elements: it arranges the range [first, last) such that the
   element pointed to by the iterator nth is the same as the element that
   would be in that position if the entire range [first, last) had been
   sorted. Additionally, none of the elements in the range [nth, last) is
   less than any of the elements in the range [first, nth). [2][1]

   The two versions of nth_element differ in how they define whether one
   element is less than another. The first version compares objects using
   operator<, and the second compares objects using a |stl-functors| comp.

   The postcondition for the first version of nth_element is as follows.
   There exists no iterator i in the range [first, nth) such that *nth < *i,
   and there exists no iterator j in the range [nth + 1, last) such that *j <
   *nth.

   The postcondition for the second version of nth_element is as follows.
   There exists no iterator i in the range [first, nth) such that comp(*nth,
   *i) is true, and there exists no iterator j in the range [nth + 1, last)
   such that comp(*j, *nth) is true.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

   For the first version, the one that takes three arguments:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * RandomAccessIterator is mutable.
     * RandomAccessIterator's value type is |stl-LessThanComparable|.
     * The ordering relation on RandomAccessIterator's value type is a strict
       weak ordering, as defined in the |stl-LessThanComparable|
       requirements.

   For the second version, the one that takes four arguments:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * RandomAccessIterator is mutable.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * RandomAccessIterator's value type is convertible to
       StrictWeakOrdering's argument type.

  Preconditions

     * [first, nth) is a valid range.
     * [nth, last) is a valid range.

   (It follows from these two conditions that [first, last) is a valid
   range.)

  Complexity

   On average, linear in last - first. [5][2]

*stl-nth_element-example*

 int A[] = {7, 2, 6, 11, 9, 3, 12, 10, 8, 4, 1, 5};
 const int N = sizeof(A) / sizeof(int);

 nth_element(A, A + 6, A + N);
 copy(A, A + N, ostream_iterator<int>(cout, " "));
 // The printed result is "5 2 6 1 4 3 7 8 9 10 11 12".

  Notes

   [1] The way in which this differs from |stl-partial_sort| is that neither
   the range [first, nth) nor the range [nth, last) is be sorted: it is
   simply guaranteed that none of the elements in [nth, last) is less than
   any of the elements in [first, nth). In that sense, nth_element is more
   similar to |stl-partition| than to |stl-sort|. Nth_element does less work
   than |stl-partial_sort|, so, reasonably enough, it is faster. That's the
   main reason to use nth_element instead of |stl-partial_sort|.

   [2] Note that this is significantly less than the run-time complexity of
   |stl-partial_sort|.

  See also

   |stl-partial_sort|, |stl-partition|, |stl-sort|, |stl-StrictWeakOrdering|,
   |stl-LessThanComparable|


        ________________________________________________________________________
                                    Binary search
*stl-lower_bound*

                                  lower_bound

   Category: algorithms                              Component type: function

  Prototype

   Lower_bound is an overloaded name; there are actually two lower_bound
   functions.

 template <class |stl-ForwardIterator|, class |stl-LessThanComparable|>
 ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,
                             const LessThanComparable& value);

 template <class |stl-ForwardIterator|, class T, class |stl-StrictWeakOrdering|>
 ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,
                             const T& value, StrictWeakOrdering comp);

  Description

   Lower_bound is a version of binary search: it attempts to find the element
   value in an ordered range [first, last) [2][1]. Specifically, it returns
   the first position where value could be inserted without violating the
   ordering. [3][2] The first version of lower_bound uses operator< for
   comparison, and the second uses the |stl-functors| comp.

   The first version of lower_bound returns the furthermost iterator i in
   [first, last) such that, for every iterator j in [first, i), *j < value.

   The second version of lower_bound returns the furthermost iterator i in
   [first, last) such that, for every iterator j in [first, i), comp(*j,
   value) is true.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [5]algo.h.

  Requirements on types

   For the first version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * LessThanComparable is a model of |stl-LessThanComparable|.
     * The ordering on objects of type LessThanComparable is a strict weak
       ordering, as defined in the |stl-LessThanComparable| requirements.
     * ForwardIterator's value type is the same type as LessThanComparable.

   For the second version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * ForwardIterator's value type is the same type as T.
     * ForwardIterator's value type is convertible to StrictWeakOrdering's
       argument type.

  Preconditions

   For the first version:

     * [first, last) is a valid range.
     * [first, last) is ordered in ascending order according to operator<.
       That is, for every pair of iterators i and j in [first, last) such
       that i precedes j, *j < *i is false.

   For the second version:

     * [first, last) is a valid range.
     * [first, last) is ordered in ascending order according to the
       |stl-functors| comp. That is, for every pair of iterators i and j in
       [first, last) such that i precedes j, comp(*j, *i) is false.

  Complexity

   The number of comparisons is logarithmic: at most log(last - first) + 1.
   If ForwardIterator is a |stl-RandomAccessIterator| then the number of
   steps through the range is also logarithmic; otherwise, the number of
   steps is proportional to last - first. [6][3]

*stl-lower_bound-example*

 int main()
 {
   int A[] = { 1, 2, 3, 3, 3, 5, 8 };
   const int N = sizeof(A) / sizeof(int);

   for (int i = 1; i <= 10; ++i) {
     int* p = lower_bound(A, A + N, i);
     cout << "Searching for " << i << ".  ";
     cout << "Result: index = " << p - A << ", ";
     if (p != A + N)
       cout << "A[" << p - A << "] == " << *p << endl;
     else
       cout << "which is off-the-end." << endl;
   }
 }

   The output is:

 Searching for 1.  Result: index = 0, A[0] == 1
 Searching for 2.  Result: index = 1, A[1] == 2
 Searching for 3.  Result: index = 2, A[2] == 3
 Searching for 4.  Result: index = 5, A[5] == 5
 Searching for 5.  Result: index = 5, A[5] == 5
 Searching for 6.  Result: index = 6, A[6] == 8
 Searching for 7.  Result: index = 6, A[6] == 8
 Searching for 8.  Result: index = 6, A[6] == 8
 Searching for 9.  Result: index = 7, which is off-the-end.
 Searching for 10.  Result: index = 7, which is off-the-end.

  Notes

   [1] Note that you may use an ordering that is a strict weak ordering but
   not a total ordering; that is, there might be values x and y such that x <
   y, x > y, and x == y are all false. (See the |stl-LessThanComparable|
   requirements for a more complete discussion.) Finding value in the range
   [first, last), then, doesn't mean finding an element that is equal to
   value but rather one that is equivalent to value: one that is neither
   greater than nor less than value. If you're using a total ordering,
   however (if you're using strcmp, for example, or if you're using ordinary
   arithmetic comparison on integers), then you can ignore this technical
   distinction: for a total ordering, equality and equivalence are the same.

   [2] If an element that is equivalent to [7][1] value is already present in
   the range [first, last), then the return value of lower_bound will be an
   iterator that points to that element.

   [3] This difference between |stl-RandomAccessIterator| and
   |stl-ForwardIterator| is simply because |stl-advance| is constant time for
   |stl-RandomAccessIterator| and linear time for |stl-ForwardIterator|.

  See also

   |stl-upper_bound|, |stl-equal_range|, |stl-binary_search|

*stl-upper_bound*

                                  upper_bound

   Category: algorithms                              Component type: function

  Prototype

   Upper_bound is an overloaded name; there are actually two upper_bound
   functions.

 template <class |stl-ForwardIterator|, class |stl-LessThanComparable|>
 ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,
                             const LessThanComparable& value);

 template <class |stl-ForwardIterator|, class T, class |stl-StrictWeakOrdering|>
 ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,
                             const T& value, StrictWeakOrdering comp);

  Description

   Upper_bound is a version of binary search: it attempts to find the element
   value in an ordered range [first, last) [2][1]. Specifically, it returns
   the last position where value could be inserted without violating the
   ordering. [3][2] The first version of upper_bound uses operator< for
   comparison, and the second uses the |stl-functors| comp.

   The first version of upper_bound returns the furthermost iterator i in
   [first, last) such that, for every iterator j in [first, i), value < *j is
   false.

   The second version of upper_bound returns the furthermost iterator i in
   [first, last) such that, for every iterator j in [first, i), comp(value,
   *j) is false.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [5]algo.h.

  Requirements on types

   For the first version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * LessThanComparable is a model of |stl-LessThanComparable|.
     * The ordering on objects of type LessThanComparable is a strict weak
       ordering, as defined in the |stl-LessThanComparable| requirements.
     * ForwardIterator's value type is the same type as LessThanComparable.

   For the second version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * ForwardIterator's value type is the same type as T.
     * ForwardIterator's value type is convertible to StrictWeakOrdering's
       argument type.

  Preconditions

   For the first version:

     * [first, last) is a valid range.
     * [first, last) is ordered in ascending order according to operator<.
       That is, for every pair of iterators i and j in [first, last) such
       that i precedes j, *j < *i is false.

   For the second version:

     * [first, last) is a valid range.
     * [first, last) is ordered in ascending order according to the
       |stl-functors| comp. That is, for every pair of iterators i and j in
       [first, last) such that i precedes j, comp(*j, *i) is false.

  Complexity

   The number of comparisons is logarithmic: at most log(last - first) + 1.
   If ForwardIterator is a |stl-RandomAccessIterator| then the number of
   steps through the range is also logarithmic; otherwise, the number of
   steps is proportional to last - first. [6][3]

*stl-upper_bound-example*

 int main()
 {
   int A[] = { 1, 2, 3, 3, 3, 5, 8 };
   const int N = sizeof(A) / sizeof(int);

   for (int i = 1; i <= 10; ++i) {
     int* p = upper_bound(A, A + N, i);
     cout << "Searching for " << i << ".  ";
     cout << "Result: index = " << p - A << ", ";
     if (p != A + N)
       cout << "A[" << p - A << "] == " << *p << endl;
     else
       cout << "which is off-the-end." << endl;
   }
 }

   The output is:

 Searching for 1.  Result: index = 1, A[1] == 2
 Searching for 2.  Result: index = 2, A[2] == 3
 Searching for 3.  Result: index = 5, A[5] == 5
 Searching for 4.  Result: index = 5, A[5] == 5
 Searching for 5.  Result: index = 6, A[6] == 8
 Searching for 6.  Result: index = 6, A[6] == 8
 Searching for 7.  Result: index = 6, A[6] == 8
 Searching for 8.  Result: index = 7, which is off-the-end.
 Searching for 9.  Result: index = 7, which is off-the-end.
 Searching for 10.  Result: index = 7, which is off-the-end.

  Notes

   [1] Note that you may use an ordering that is a strict weak ordering but
   not a total ordering; that is, there might be values x and y such that x <
   y, x > y, and x == y are all false. (See the |stl-LessThanComparable|
   requirements for a more complete discussion.) Finding value in the range
   [first, last), then, doesn't mean finding an element that is equal to
   value but rather one that is equivalent to value: one that is neither
   greater than nor less than value. If you're using a total ordering,
   however (if you're using strcmp, for example, or if you're using ordinary
   arithmetic comparison on integers), then you can ignore this technical
   distinction: for a total ordering, equality and equivalence are the same.

   [2] Note that even if an element that is equivalent to [7][1] value is
   already present in the range [first, last), the return value of
   upper_bound will not point to that element. The return value is either
   last or else an iterator i such that value < *i. If i is not equal to
   first, however, then *(i - 1) is less than or equivalent to value.

   [3] This difference between |stl-RandomAccessIterator| and
   |stl-ForwardIterator| is simply because |stl-advance| is constant time for
   |stl-RandomAccessIterator| and linear time for |stl-ForwardIterator|.

  See also

   |stl-lower_bound|, |stl-equal_range|, |stl-binary_search|

*stl-equal_range*

                                  equal_range

   Category: algorithms                              Component type: function

  Prototype

   Equal_range is an overloaded name; there are actually two equal_range
   functions.

 template <class |stl-ForwardIterator|, class |stl-LessThanComparable|>
 |stl-pair|<ForwardIterator, ForwardIterator>
 equal_range(ForwardIterator first, ForwardIterator last,
             const LessThanComparable& value);

 template <class |stl-ForwardIterator|, class T, class |stl-StrictWeakOrdering|>
 |stl-pair|<ForwardIterator, ForwardIterator>
 equal_range(ForwardIterator first, ForwardIterator last, const T& value,
             StrictWeakOrdering comp);


  Description

   Equal_range is a version of binary search: it attempts to find the element
   value in an ordered range [first, last) [2][1]. The value returned by
   equal_range is essentially a combination of the values returned by
   |stl-lower_bound| and |stl-upper_bound|: it returns a pair of iterators i
   and j such that i is the first position where value could be inserted
   without violating the ordering and j is the last position where value
   could be inserted without violating the ordering. It follows that every
   element in the range [i, j) is equivalent to [3][1] value, and that [i, j)
   is the largest subrange of [first, last) that has this property. The first
   version of equal_range uses operator< for comparison, and the second uses
   the |stl-functors| comp.

   The first version of equal_range returns a pair of iterators [i, j). i is
   the furthermost iterator in [first, last) such that, for every iterator k
   in [first, i), *k < value. j is the furthermost iterator in [first, last)
   such that, for every iterator k in [first, j), value < *k is false. For
   every iterator k in [i, j), neither value < *k nor *k < value is true.
   [4][2]

   The second version of equal_range returns a pair of iterators [i, j). i is
   the furthermost iterator in [first, last) such that, for every iterator k
   in [first, i), comp(*k, value) is true. j is the furthermost iterator in
   [first, last) such that, for every iterator k in [first, j), comp(value,
   *k) is false. For every iterator k in [i, j), neither comp(value, *k) nor
   comp(*k, value) is true. [5][2]

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [7]algo.h.

  Requirements on types

   For the first version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * LessThanComparable is a model of |stl-LessThanComparable|.
     * The ordering on objects of type LessThanComparable is a strict weak
       ordering, as defined in the |stl-LessThanComparable| requirements.
     * ForwardIterator's value type is the same type as LessThanComparable.

   For the second version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * ForwardIterator's value type is the same type as T.
     * ForwardIterator's value type is convertible to StrictWeakOrdering's
       argument type.

  Preconditions

   For the first version:

     * [first, last) is a valid range.
     * [first, last) is ordered in ascending order according to operator<.
       That is, for every pair of iterators i and j in [first, last) such
       that i precedes j, *j < *i is false.

   For the second version:

     * [first, last) is a valid range.
     * [first, last) is ordered in ascending order according to the
       |stl-functors| comp. That is, for every pair of iterators i and j in
       [first, last) such that i precedes j, comp(*j, *i) is false.

  Complexity

   The number of comparisons is logarithmic: at most 2 * log(last - first) +
   1. If ForwardIterator is a |stl-RandomAccessIterator| then the number of
   steps through the range is also logarithmic; otherwise, the number of
   steps is proportional to last - first. [8][3]

*stl-equal_range-example*

 int main()
 {
   int A[] = { 1, 2, 3, 3, 3, 5, 8 };
   const int N = sizeof(A) / sizeof(int);

   for (int i = 2; i <= 4; ++i) {
     pair<int*, int*> result = equal_range(A, A + N, i);

     cout << endl;
     cout << "Searching for " << i << endl;
     cout << "  First position where " << i << " could be inserted: "
          << result.first - A << endl;
     cout << "  Last position where " << i << " could be inserted: "
          << result.second - A << endl;
     if (result.first < A + N)
       cout << "  *result.first = " << *result.first << endl;
     if (result.second < A + N)
       cout << "  *result.second = " << *result.second << endl;
   }
 }

   The output is:

 Searching for 2
   First position where 2 could be inserted: 1
   Last position where 2 could be inserted: 2
   *result.first = 2
   *result.second = 3

 Searching for 3
   First position where 3 could be inserted: 2
   Last position where 3 could be inserted: 5
   *result.first = 3
   *result.second = 5

 Searching for 4
   First position where 4 could be inserted: 5
   Last position where 4 could be inserted: 5
   *result.first = 5
   *result.second = 5

  Notes

   [1] Note that you may use an ordering that is a strict weak ordering but
   not a total ordering; that is, there might be values x and y such that x <
   y, x > y, and x == y are all false. (See the |stl-LessThanComparable|
   requirements for a more complete discussion.) Finding value in the range
   [first, last), then, doesn't mean finding an element that is equal to
   value but rather one that is equivalent to value: one that is neither
   greater than nor less than value. If you're using a total ordering,
   however (if you're using strcmp, for example, or if you're using ordinary
   arithmetic comparison on integers), then you can ignore this technical
   distinction: for a total ordering, equality and equivalence are the same.

   [2] Note that equal_range may return an empty range; that is, it may
   return a pair both of whose elements are the same iterator. Equal_range
   returns an empty range if and only if the range [first, last) contains no
   elements equivalent to value. In this case it follows that there is only
   one position where value could be inserted without violating the range's
   ordering, so the return value is a pair both of whose elements are
   iterators that point to that position.

   [3] This difference between |stl-RandomAccessIterator| and
   |stl-ForwardIterator| is simply because |stl-advance| is constant time for
   |stl-RandomAccessIterator| and linear time for |stl-ForwardIterator|.

  See also

   |stl-lower_bound|, |stl-upper_bound|, |stl-binary_search|

*stl-binary_search*

                                 binary_search

   Category: algorithms                              Component type: function

  Prototype

   Binary_search is an overloaded name; there are actually two binary_search
   functions.

 template <class |stl-ForwardIterator|, class |stl-LessThanComparable|>
 bool binary_search(ForwardIterator first, ForwardIterator last,
                    const LessThanComparable& value);

 template <class |stl-ForwardIterator|, class T, class |stl-StrictWeakOrdering|>
 bool binary_search(ForwardIterator first, ForwardIterator last, const T& value,
                    StrictWeakOrdering comp);

  Description

   Binary_search is a version of binary search: it attempts to find the
   element value in an ordered range [first, last) It returns true if an
   element that is equivalent to [2][1] value is present in [first, last) and
   false if no such element exists. [3][2] The first version of binary_search
   uses operator< for comparison, and the second uses the |stl-functors|
   comp.

   Specifically, the first version returns true if and only if there exists
   an iterator i in [first, last) such that *i < value and value < *i are
   both false. The second version returns true if and only if there exists an
   iterator i in [first, last) such that comp(*i, value) and comp(value, *i)
   are both false.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [5]algo.h.

  Requirements on types

   For the first version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * LessThanComparable is a model of |stl-LessThanComparable|.
     * The ordering on objects of type LessThanComparable is a strict weak
       ordering, as defined in the |stl-LessThanComparable| requirements.
     * ForwardIterator's value type is the same type as LessThanComparable.

   For the second version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * ForwardIterator's value type is the same type as T.
     * ForwardIterator's value type is convertible to StrictWeakOrdering's
       argument type.

  Preconditions

   For the first version:

     * [first, last) is a valid range.
     * [first, last) is ordered in ascending order according to operator<.
       That is, for every pair of iterators i and j in [first, last) such
       that i precedes j, *j < *i is false.

   For the second version:

     * [first, last) is a valid range.
     * [first, last) is ordered in ascending order according to the
       |stl-functors| comp. That is, for every pair of iterators i and j in
       [first, last) such that i precedes j, comp(*j, *i) is false.

  Complexity

   The number of comparisons is logarithmic: at most log(last - first) + 2.
   If ForwardIterator is a |stl-RandomAccessIterator| then the number of
   steps through the range is also logarithmic; otherwise, the number of
   steps is proportional to last - first. [6][3]

*stl-binary_search-example*

 int main()
 {
   int A[] = { 1, 2, 3, 3, 3, 5, 8 };
   const int N = sizeof(A) / sizeof(int);

   for (int i = 1; i <= 10; ++i) {
     cout << "Searching for " << i << ": "
          << (binary_search(A, A + N, i) ? "present" : "not present") << endl;
   }
 }

   The output is:

 Searching for 1: present
 Searching for 2: present
 Searching for 3: present
 Searching for 4: not present
 Searching for 5: present
 Searching for 6: not present
 Searching for 7: not present
 Searching for 8: present
 Searching for 9: not present
 Searching for 10: not present

  Notes

   [1] Note that you may use an ordering that is a strict weak ordering but
   not a total ordering; that is, there might be values x and y such that x <
   y, x > y, and x == y are all false. (See the |stl-LessThanComparable|
   requirements for a more complete discussion.) Finding value in the range
   [first, last), then, doesn't mean finding an element that is equal to
   value but rather one that is equivalent to value: one that is neither
   greater than nor less than value. If you're using a total ordering,
   however (if you're using strcmp, for example, or if you're using ordinary
   arithmetic comparison on integers), then you can ignore this technical
   distinction: for a total ordering, equality and equivalence are the same.

   [2] Note that this is not necessarily the information you are interested
   in! Usually, if you're testing whether an element is present in a range,
   you'd like to know where it is (if it's present), or where it should be
   inserted (if it's not present). The functions |stl-lower_bound|,
   |stl-upper_bound|, and |stl-equal_range| provide this information.

   [3] This difference between |stl-RandomAccessIterator| and
   |stl-ForwardIterator| is simply because |stl-advance| is constant time for
   |stl-RandomAccessIterator| and linear time for |stl-ForwardIterator|.

  See also

   |stl-lower_bound|, |stl-upper_bound|, |stl-equal_range|


*stl-merge*

                                     merge

   Category: algorithms                              Component type: function

  Prototype

   Merge is an overloaded name: there are actually two merge functions.

 template <class |stl-InputIterator|1, class |stl-InputIterator|2, class |stl-OutputIterator|>
 OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                      InputIterator2 first2, InputIterator2 last2,
                      OutputIterator result);

 template <class |stl-InputIterator|1, class |stl-InputIterator|2, class |stl-OutputIterator|,
           class |stl-StrictWeakOrdering|>
 OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                      InputIterator2 first2, InputIterator2 last2,
                      OutputIterator result, StrictWeakOrdering comp);

  Description

   Merge combines two sorted ranges [first1, last1) and [first2, last2) into
   a single sorted range. That is, it copies elements from [first1, last1)
   and [first2, last2) into [result, result + (last1 - first1) + (last2 -
   first2)) such that the resulting range is in ascending order. Merge is
   stable, meaning both that the relative order of elements within each input
   range is preserved, and that for equivalent [2][1] elements in both input
   ranges the element from the first range precedes the element from the
   second. The return value is result + (last1 - first1) + (last2 - first2).

   The two versions of merge differ in how elements are compared. The first
   version uses operator<. That is, the input ranges and the output range
   satisfy the condition that for every pair of iterators i and j such that i
   precedes j, *j < *i is false. The second version uses the |stl-functors|
   comp. That is, the input ranges and the output range satisfy the condition
   that for every pair of iterators i and j such that i precedes j, comp(*j,
   *i) is false.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

   For the first version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * InputIterator1's value type is the same type as InputIterator2's value
       type.
     * InputIterator1's value type is a model of |stl-LessThanComparable|.
     * The ordering on objects of InputIterator1's value type is a strict
       weak ordering, as defined in the |stl-LessThanComparable|
       requirements.
     * InputIterator1's value type is convertible to a type in
       OutputIterator's set of value types.

   For the second version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * InputIterator1's value type is the same type as InputIterator2's value
       type.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * InputIterator1's value type is convertible to StrictWeakOrdering's
       argument type.
     * InputIterator1's value type is convertible to a type in
       OutputIterator's set of value types.

  Preconditions

   For the first version:

     * [first1, last1) is a valid range.
     * [first1, last1) is in ascending order. That is, for every pair of
       iterators i and j in [first1, last1) such that i precedes j, *j < *i
       is false.
     * [first2, last2) is a valid range.
     * [first2, last2) is in ascending order. That is, for every pair of
       iterators i and j in [first2, last2) such that i precedes j, *j < *i
       is false.
     * The ranges [first1, last1) and [result, result + (last1 - first1) +
       (last2 - first2)) do not overlap.
     * The ranges [first2, last2) and [result, result + (last1 - first1) +
       (last2 - first2)) do not overlap.
     * There is enough space to hold all of the elements being copied. More
       formally, the requirement is that [result, result + (last1 - first1) +
       (last2 - first2)) is a valid range.

   For the second version:

     * [first1, last1) is a valid range.
     * [first1, last1) is in ascending order. That is, for every pair of
       iterators i and j in [first1, last1) such that i precedes j, comp(*j,
       *i) is false.
     * [first2, last2) is a valid range.
     * [first2, last2) is in ascending order. That is, for every pair of
       iterators i and j in [first2, last2) such that i precedes j, comp(*j,
       *i) is false.
     * The ranges [first1, last1) and [result, result + (last1 - first1) +
       (last2 - first2)) do not overlap.
     * The ranges [first2, last2) and [result, result + (last1 - first1) +
       (last2 - first2)) do not overlap.
     * There is enough space to hold all of the elements being copied. More
       formally, the requirement is that [result, result + (last1 - first1) +
       (last2 - first2)) is a valid range.

  Complexity

   Linear. No comparisons if both [first1, last1) and [first2, last2) are
   empty ranges, otherwise at most (last1 - first1) + (last2 - first2) - 1
   comparisons.

*stl-merge-example*

 int main()
 {
   int A1[] = { 1, 3, 5, 7 };
   int A2[] = { 2, 4, 6, 8 };
   const int N1 = sizeof(A1) / sizeof(int);
   const int N2 = sizeof(A2) / sizeof(int);

   merge(A1, A1 + N1, A2, A2 + N2,
         |stl-ostream_iterator|<int>(cout, " "));
   // The output is "1 2 3 4 5 6 7 8"
 }

  Notes

   [1] Note that you may use an ordering that is a strict weak ordering but
   not a total ordering; that is, there might be values x and y such that x <
   y, x > y, and x == y are all false. (See the |stl-LessThanComparable|
   requirements for a more complete discussion.) Two elements x and y are
   equivalent if neither x < y nor y < x. If you're using a total ordering,
   however (if you're using strcmp, for example, or if you're using ordinary
   arithmetic comparison on integers), then you can ignore this technical
   distinction: for a total ordering, equality and equivalence are the same.

  See also

   |stl-inplace_merge|, |stl-set_union|, |stl-sort|

*stl-inplace_merge*

                                 inplace_merge

   Category: algorithms                              Component type: function

  Prototype

   Inplace_merge is an overloaded name: there are actually two inplace_merge
   functions.

 template <class |stl-BidirectionalIterator|>
 inline void inplace_merge(BidirectionalIterator first,
                           BidirectionalIterator middle,
                           BidirectionalIterator last);

 template <class |stl-BidirectionalIterator|, class |stl-StrictWeakOrdering|>
 inline void inplace_merge(BidirectionalIterator first,
                           BidirectionalIterator middle,
                           BidirectionalIterator last, StrictWeakOrdering comp);

  Description

   Inplace_merge combines two consecutive sorted ranges [first, middle) and
   [middle, last) into a single sorted range [first, last). That is, it
   starts with a range [first, last) that consists of two pieces each of
   which is in ascending order, and rearranges it so that the entire range is
   in ascending order. Inplace_merge is stable, meaning both that the
   relative order of elements within each input range is preserved, and that
   for equivalent [2][1] elements in both input ranges the element from the
   first range precedes the element from the second.

   The two versions of inplace_merge differ in how elements are compared. The
   first version uses operator<. That is, the input ranges and the output
   range satisfy the condition that for every pair of iterators i and j such
   that i precedes j, *j < *i is false. The second version uses the
   |stl-functors| comp. That is, the input ranges and the output range
   satisfy the condition that for every pair of iterators i and j such that i
   precedes j, comp(*j, *i) is false.

  Definition

   Defined in [3]algo.h.

  Requirements on types

   For the first version:

     * BidirectionalIterator is a model of |stl-BidirectionalIterator|.
     * BidirectionalIterator is mutable.
     * BidirectionalIterator's value type is a model of
       |stl-LessThanComparable|.
     * The ordering on objects of BidirectionalIterator's value type is a
       strict weak ordering, as defined in the |stl-LessThanComparable|
       requirements.

   For the second version:

     * BidirectionalIterator is a model of |stl-BidirectionalIterator|.
     * BidirectionalIterator is mutable.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * BidirectionalIterator's value type is convertible to
       StrictWeakOrdering's argument type.

  Preconditions

   For the first version:

     * [first, middle) is a valid range.
     * [middle, last) is a valid range.
     * [first, middle) is in ascending order. That is, for every pair of
       iterators i and j in [first, middle) such that i precedes j, *j < *i
       is false.
     * [middle, last) is in ascending order. That is, for every pair of
       iterators i and j in [middle, last) such that i precedes j, *j < *i is
       false.

   For the second version:

     * [first, middle) is a valid range.
     * [middle, last) is a valid range.
     * [first, middle) is in ascending order. That is, for every pair of
       iterators i and j in [first, middle) such that i precedes j, comp(*j,
       *i) is false.
     * [middle, last) is in ascending order. That is, for every pair of
       iterators i and j in [middle, last) such that i precedes j, comp(*j,
       *i) is false.

  Complexity

   Inplace_merge is an adaptive algorithm: it attempts to allocate a
   temporary memory buffer, and its run-time complexity depends on how much
   memory is available. Inplace_merge performs no comparisons if [first,
   last) is an empty range. Otherwise, worst-case behavior (if no auxiliary
   memory is available) is O(N log(N)), where N is last - first, and best
   case (if a large enough auxiliary memory buffer is available) is at most
   (last - first) - 1 comparisons.

*stl-inplace_merge-example*

 int main()
 {
   int A[] = { 1, 3, 5, 7, 2, 4, 6, 8 };

   inplace_merge(A, A + 4, A + 8);
   copy(A, A + 8, ostream_iterator<int>(cout, " "));
   // The output is "1 2 3 4 5 6 7 8".
 }

  Notes

   [1] Note that you may use an ordering that is a strict weak ordering but
   not a total ordering; that is, there might be values x and y such that x <
   y, x > y, and x == y are all false. (See the |stl-LessThanComparable|
   requirements for a fuller discussion.) Two elements x and y are equivalent
   if neither x < y nor y < x. If you're using a total ordering, however (if
   you're using strcmp, for example, or if you're using ordinary arithmetic
   comparison on integers), then you can ignore this technical distinction:
   for a total ordering, equality and equivalence are the same.

  See also

   |stl-merge|, |stl-set_union|, |stl-sort|

        ________________________________________________________________________
                           Set operations on sorted ranges
*stl-includes*

                                    includes

   Category: algorithms                              Component type: function

  Prototype

   Includes is an overloaded name; there are actually two includes functions.

 template <class |stl-InputIterator|1, class |stl-InputIterator|2>
 bool includes(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2);

 template <class |stl-InputIterator|1, class |stl-InputIterator|2, class |stl-StrictWeakOrdering|>
 bool includes(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2,
               StrictWeakOrdering comp);

  Description

   Includes tests whether one sorted range includes another sorted range.
   That is, it returns true if and only if, for every element in [first2,
   last2), an equivalent element [2][1] is also present in [first1, last1)
   [3][2]. Both [first1, last1) and [first2, last2) must be sorted in
   ascending order.

   The two versions of includes differ in how they define whether one element
   is less than another. The first version compares objects using operator<,
   and the second compares objects using the |stl-functors| comp.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [5]algo.h.

  Requirements on types

   For the first version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * InputIterator1 and InputIterator2 have the same value type.
     * InputIterator's value type is a model of |stl-LessThanComparable|.
     * The ordering on objects of InputIterator1's value type is a strict
       weak ordering, as defined in the |stl-LessThanComparable|
       requirements.

   For the second version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * InputIterator1 and InputIterator2 have the same value type.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * InputIterator1's value type is convertible to StrictWeakOrdering's
       argument type.

  Preconditions

   For the first version:

     * [first1, last1) is a valid range.
     * [first2, last2) is a valid range.
     * [first1, last1) is ordered in ascending order according to operator<.
       That is, for every pair of iterators i and j in [first1, last1) such
       that i precedes j, *j < *i is false.
     * [first2, last2) is ordered in ascending order according to operator<.
       That is, for every pair of iterators i and j in [first2, last2) such
       that i precedes j, *j < *i is false.

   For the second version:

     * [first1, last1) is a valid range.
     * [first2, last2) is a valid range.
     * [first1, last1) is ordered in ascending order according to comp. That
       is, for every pair of iterators i and j in [first1, last1) such that i
       precedes j, comp(*j, *i) is false.
     * [first2, last2) is ordered in ascending order according to comp. That
       is, for every pair of iterators i and j in [first2, last2) such that i
       precedes j, comp(*j, *i) is false.

  Complexity

   Linear. Zero comparisons if either [first1, last1) or [first2, last2) is
   an empty range, otherwise at most 2 * ((last1 - first1) + (last2 -
   first2)) - 1 comparisons.

*stl-includes-example*

 int A1[] = { 1, 2, 3, 4, 5, 6, 7 };
 int A2[] = { 1, 4, 7 };
 int A3[] = { 2, 7, 9 };
 int A4[] = { 1, 1, 2, 3, 5, 8, 13, 21 };
 int A5[] = { 1, 2, 13, 13 };
 int A6[] = { 1, 1, 3, 21 };

 const int N1 = sizeof(A1) / sizeof(int);
 const int N2 = sizeof(A2) / sizeof(int);
 const int N3 = sizeof(A3) / sizeof(int);
 const int N4 = sizeof(A4) / sizeof(int);
 const int N5 = sizeof(A5) / sizeof(int);
 const int N6 = sizeof(A6) / sizeof(int);

 cout << "A2 contained in A1: "
      << (includes(A1, A1 + N1, A2, A2 + N2) ? "true" : "false") << endl;
 cout << "A3 contained in A1: "
      << (includes(A1, A1 + N2, A3, A3 + N3) ? "true" : "false") << endl;
 cout << "A5 contained in A4: "
      << (includes(A4, A4 + N4, A5, A5 + N5) ? "true" : "false") << endl;
 cout << "A6 contained in A4: "
      << (includes(A4, A4 + N4, A6, A6 + N6) ? "true" : "false") << endl;


   The output is:

 A2 contained in A1: true
 A3 contained in A1: false
 A5 contained in A4: false
 A6 contained in A4: true

  Notes

   [1] This reads "an equivalent element" rather than "the same element"
   because the ordering by which the input ranges are sorted is permitted to
   be a strict weak ordering that is not a total ordering: there might be
   values x and y that are equivalent (that is, neither x < y nor y < x is
   true) but not equal. See the |stl-LessThanComparable| requirements for a
   fuller discussion.) If you're using a total ordering (if you're using
   strcmp, for example, or if you're using ordinary arithmetic comparison on
   integers), then you can ignore this technical distinction: for a total
   ordering, equality and equivalence are the same.

   [2] Note that the range [first2, last2) may contain a consecutive range of
   equivalent elements: there is no requirement that every element in the
   range be unique. In this case, includes will return false unless, for
   every element in [first2, last2), a distinct equivalent element is also
   present in [first1, last1). That is, if a certain value appears n times in
   [first2, last2) and m times in [first1, last1), then includes will return
   false if m < n.

  See also

   |stl-set_union|, |stl-set_intersection|, |stl-set_difference|,
   |stl-set_symmetric_difference|, |stl-sort|

*stl-set_union*

                                   set_union

   Category: algorithms                              Component type: function

  Prototype

   Set_union is an overloaded name; there are actually two set_union
   functions.

 template <class |stl-InputIterator|1, class |stl-InputIterator|2, class |stl-OutputIterator|>
 OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,
                          InputIterator2 first2, InputIterator2 last2,
                          OutputIterator result);

 template <class |stl-InputIterator|1, class |stl-InputIterator|2, class |stl-OutputIterator|,
           class |stl-StrictWeakOrdering|>
 OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,
                          InputIterator2 first2, InputIterator2 last2,
                          OutputIterator result,
                          StrictWeakOrdering comp);

  Description

   Set_union constructs a sorted range that is the union of the sorted ranges
   [first1, last1) and [first2, last2). The return value is the end of the
   output range.

   In the simplest case, set_union performs the "union" operation from set
   theory: the output range contains a copy of every element that is
   contained in [first1, last1), [first2, last2), or both. The general case
   is more complicated, because the input ranges may contain duplicate
   elements. The generalization is that if a value appears m times in
   [first1, last1) and n times in [first2, last2) (where m or n may be zero),
   then it appears max(m,n) times in the output range. [2][1] Set_union is
   stable, meaning both that the relative order of elements within each input
   range is preserved, and that if an element is present in both input ranges
   it is copied from the first range rather than the second.

   The two versions of set_union differ in how they define whether one
   element is less than another. The first version compares objects using
   operator<, and the second compares objects using a |stl-functors| comp.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

   For the first version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * InputIterator1 and InputIterator2 have the same value type.
     * InputIterator's value type is a model of |stl-LessThanComparable|.
     * The ordering on objects of InputIterator1's value type is a strict
       weak ordering, as defined in the |stl-LessThanComparable|
       requirements.
     * InputIterator's value type is convertible to a type in
       OutputIterator's set of value types.

   For the second version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * InputIterator1 and InputIterator2 have the same value type.
     * InputIterator1's value type is convertible to StrictWeakOrdering's
       argument type.
     * InputIterator's value type is convertible to a type in
       OutputIterator's set of value types.

  Preconditions

   For the first version:

     * [first1, last1) is a valid range.
     * [first2, last2) is a valid range.
     * [first1, last1) is ordered in ascending order according to operator<.
       That is, for every pair of iterators i and j in [first1, last1) such
       that i precedes j, *j < *i is false.
     * [first2, last2) is ordered in ascending order according to operator<.
       That is, for every pair of iterators i and j in [first2, last2) such
       that i precedes j, *j < *i is false.
     * There is enough space to hold all of the elements being copied. More
       formally, the requirement is that [result, result + n) is a valid
       range, where n is the number of elements in the union of the two input
       ranges.
     * [first1, last1) and [result, result + n) do not overlap.
     * [first2, last2) and [result, result + n) do not overlap.

   For the second version:

     * [first1, last1) is a valid range.
     * [first2, last2) is a valid range.
     * [first1, last1) is ordered in ascending order according to comp. That
       is, for every pair of iterators i and j in [first1, last1) such that i
       precedes j, comp(*j, *i) is false.
     * [first2, last2) is ordered in ascending order according to comp. That
       is, for every pair of iterators i and j in [first2, last2) such that i
       precedes j, comp(*j, *i) is false.
     * There is enough space to hold all of the elements being copied. More
       formally, the requirement is that [result, result + n) is a valid
       range, where n is the number of elements in the union of the two input
       ranges.
     * [first1, last1) and [result, result + n) do not overlap.
     * [first2, last2) and [result, result + n) do not overlap.

  Complexity

   Linear. Zero comparisons if either [first1, last1) or [first2, last2) is
   empty, otherwise at most 2 * ((last1 - first1) + (last2 - first2)) - 1
   comparisons.

*stl-set_union-example*

 inline bool lt_nocase(char c1, char c2) { return tolower(c1) < tolower(c2); }

 int main()
 {
   int A1[] = {1, 3, 5, 7, 9, 11};
   int A2[] = {1, 1, 2, 3, 5, 8, 13};
   char A3[] = {'a', 'b', 'B', 'B', 'f', 'H'};
   char A4[] = {'A', 'B', 'b', 'C', 'D', 'F', 'F', 'h', 'h'};

   const int N1 = sizeof(A1) / sizeof(int);
   const int N2 = sizeof(A2) / sizeof(int);
   const int N3 = sizeof(A3);
   const int N4 = sizeof(A4);

   cout << "Union of A1 and A2: ";
   set_union(A1, A1 + N1, A2, A2 + N2,
             ostream_iterator<int>(cout, " "));
   cout << endl
        << "Union of A3 and A4: ";
   set_union(A3, A3 + N3, A4, A4 + N4,
             ostream_iterator<char>(cout, " "),
             lt_nocase);
   cout << endl;
 }

   The output is

 Union of A1 and A2: 1 1 2 3 5 7 8 9 11 13
 Union of A3 and A4: a b B B C D f F H h

  Notes

   [1] Even this is not a completely precise description, because the
   ordering by which the input ranges are sorted is permitted to be a strict
   weak ordering that is not a total ordering: there might be values x and y
   that are equivalent (that is, neither x < y nor y < x) but not equal. See
   the |stl-LessThanComparable| requirements for a more complete discussion.
   If the range [first1, last1) contains m elements that are equivalent to
   each other and the range [first2, last2) contains n elements from that
   equivalence class (where either m or n may be zero), then the output range
   contains max(m, n) elements from that equivalence class. Specifically, m
   of these elements will be copied from [first1, last1) and max(n-m, 0) of
   them will be copied from [first2, last2). Note that this precision is only
   important if elements can be equivalent but not equal. If you're using a
   total ordering (if you're using strcmp, for example, or if you're using
   ordinary arithmetic comparison on integers), then you can ignore this
   technical distinction: for a total ordering, equality and equivalence are
   the same.

  See also

   |stl-includes|, |stl-set_intersection|, |stl-set_difference|,
   |stl-set_symmetric_difference|, |stl-sort|, |stl-merge|

*stl-set_intersection*

                                set_intersection

   Category: algorithms                              Component type: function

  Prototype

   Set_intersection is an overloaded name; there are actually two
   set_intersection functions.

 template <class |stl-InputIterator|1, class |stl-InputIterator|2, class |stl-OutputIterator|>
 OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1,
                                 InputIterator2 first2, InputIterator2 last2,
                                 OutputIterator result);

 template <class |stl-InputIterator|1, class |stl-InputIterator|2, class |stl-OutputIterator|,
           class |stl-StrictWeakOrdering|>
 OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1,
                                 InputIterator2 first2, InputIterator2 last2,
                                 OutputIterator result,
                                 StrictWeakOrdering comp);

  Description

   Set_intersection constructs a sorted range that is the intersection of the
   sorted ranges [first1, last1) and [first2, last2). The return value is the
   end of the output range.

   In the simplest case, set_intersection performs the "intersection"
   operation from set theory: the output range contains a copy of every
   element that is contained in both [first1, last1) and [first2, last2). The
   general case is more complicated, because the input ranges may contain
   duplicate elements. The generalization is that if a value appears m times
   in [first1, last1) and n times in [first2, last2) (where m or n may be
   zero), then it appears min(m,n) times in the output range. [2][1]
   Set_intersection is stable, meaning both that elements are copied from the
   first range rather than the second, and that the relative order of
   elements in the output range is the same as in the first input range.

   The two versions of set_intersection differ in how they define whether one
   element is less than another. The first version compares objects using
   operator<, and the second compares objects using a |stl-functors| comp.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

   For the first version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * InputIterator1 and InputIterator2 have the same value type.
     * InputIterator's value type is a model of |stl-LessThanComparable|.
     * The ordering on objects of InputIterator1's value type is a strict
       weak ordering, as defined in the |stl-LessThanComparable|
       requirements.
     * InputIterator's value type is convertible to a type in
       OutputIterator's set of value types.

   For the second version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * InputIterator1 and InputIterator2 have the same value type.
     * InputIterator1's value type is convertible to StrictWeakOrdering's
       argument type.
     * InputIterator's value type is convertible to a type in
       OutputIterator's set of value types.

  Preconditions

   For the first version:

     * [first1, last1) is a valid range.
     * [first2, last2) is a valid range.
     * [first1, last1) is ordered in ascending order according to operator<.
       That is, for every pair of iterators i and j in [first1, last1) such
       that i precedes j, *j < *i is false.
     * [first2, last2) is ordered in ascending order according to operator<.
       That is, for every pair of iterators i and j in [first2, last2) such
       that i precedes j, *j < *i is false.
     * There is enough space to hold all of the elements being copied. More
       formally, the requirement is that [result, result + n) is a valid
       range, where n is the number of elements in the intersection of the
       two input ranges.
     * [first1, last1) and [result, result + n) do not overlap.
     * [first2, last2) and [result, result + n) do not overlap.

   For the second version:

     * [first1, last1) is a valid range.
     * [first2, last2) is a valid range.
     * [first1, last1) is ordered in ascending order according to comp. That
       is, for every pair of iterators i and j in [first1, last1) such that i
       precedes j, comp(*j, *i) is false.
     * [first2, last2) is ordered in ascending order according to comp. That
       is, for every pair of iterators i and j in [first2, last2) such that i
       precedes j, comp(*j, *i) is false.
     * There is enough space to hold all of the elements being copied. More
       formally, the requirement is that [result, result + n) is a valid
       range, where n is the number of elements in the intersection of the
       two input ranges.
     * [first1, last1) and [result, result + n) do not overlap.
     * [first2, last2) and [result, result + n) do not overlap.

  Complexity

   Linear. Zero comparisons if either [first1, last1) or [first2, last2) is
   empty, otherwise at most 2 * ((last1 - first1) + (last2 - first2)) - 1
   comparisons.

*stl-set_intersection-example*

 inline bool lt_nocase(char c1, char c2) { return tolower(c1) < tolower(c2); }

 int main()
 {
   int A1[] = {1, 3, 5, 7, 9, 11};
   int A2[] = {1, 1, 2, 3, 5, 8, 13};
   char A3[] = {'a', 'b', 'b', 'B', 'B', 'f', 'h', 'H'};
   char A4[] = {'A', 'B', 'B', 'C', 'D', 'F', 'F', 'H' };

   const int N1 = sizeof(A1) / sizeof(int);
   const int N2 = sizeof(A2) / sizeof(int);
   const int N3 = sizeof(A3);
   const int N4 = sizeof(A4);

   cout << "Intersection of A1 and A2: ";
   set_intersection(A1, A1 + N1, A2, A2 + N2,
                    ostream_iterator<int>(cout, " "));
   cout << endl
        << "Intersection of A3 and A4: ";
   set_intersection(A3, A3 + N3, A4, A4 + N4,
                    ostream_iterator<char>(cout, " "),
                    lt_nocase);
   cout << endl;
 }

   The output is

 Intersection of A1 and A2: 1 3 5
 Intersection of A3 and A4: a b b f h

  Notes

   [1] Even this is not a completely precise description, because the
   ordering by which the input ranges are sorted is permitted to be a strict
   weak ordering that is not a total ordering: there might be values x and y
   that are equivalent (that is, neither x < y nor y < x) but not equal. See
   the |stl-LessThanComparable| requirements for a fuller discussion. The
   output range consists of those elements from [first1, last1) for which
   equivalent elements exist in [first2, last2). Specifically, if the range
   [first1, last1) contains n elements that are equivalent to each other and
   the range [first1, last1) contains m elements from that equivalence class
   (where either m or n may be zero), then the output range contains the
   first min(m, n) of these elements from [first1, last1). Note that this
   precision is only important if elements can be equivalent but not equal.
   If you're using a total ordering (if you're using strcmp, for example, or
   if you're using ordinary arithmetic comparison on integers), then you can
   ignore this technical distinction: for a total ordering, equality and
   equivalence are the same.

  See also

   |stl-includes|, |stl-set_union|, |stl-set_difference|,
   |stl-set_symmetric_difference|, |stl-sort|

*stl-set_difference*

                                 set_difference

   Category: algorithms                              Component type: function

  Prototype

   Set_difference is an overloaded name; there are actually two
   set_difference functions.

 template <class |stl-InputIterator|1, class |stl-InputIterator|2, class |stl-OutputIterator|>
 OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2, InputIterator2 last2,
                               OutputIterator result);

 template <class |stl-InputIterator|1, class |stl-InputIterator|2, class |stl-OutputIterator|,
           class |stl-StrictWeakOrdering|>
 OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2, InputIterator2 last2,
                               OutputIterator result,
                               StrictWeakOrdering comp);

  Description

   Set_difference constructs a sorted range that is the set difference of the
   sorted ranges [first1, last1) and [first2, last2). The return value is the
   end of the output range.

   In the simplest case, set_difference performs the "difference" operation
   from set theory: the output range contains a copy of every element that is
   contained in [first1, last1) and not contained in [first2, last2). The
   general case is more complicated, because the input ranges may contain
   duplicate elements. The generalization is that if a value appears m times
   in [first1, last1) and n times in [first2, last2) (where m or n may be
   zero), then it appears max(m-n, 0) times in the output range. [2][1]
   Set_difference is stable, meaning both that elements are copied from the
   first range rather than the second, and that the relative order of
   elements in the output range is the same as in the first input range.

   The two versions of set_difference differ in how they define whether one
   element is less than another. The first version compares objects using
   operator<, and the second compares objects using a |stl-functors| comp.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

   For the first version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * InputIterator1 and InputIterator2 have the same value type.
     * InputIterator's value type is a model of |stl-LessThanComparable|.
     * The ordering on objects of InputIterator1's value type is a strict
       weak ordering, as defined in the |stl-LessThanComparable|
       requirements.
     * InputIterator's value type is convertible to a type in
       OutputIterator's set of value types.

   For the second version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * InputIterator1 and InputIterator2 have the same value type.
     * InputIterator1's value type is convertible to StrictWeakOrdering's
       argument type.
     * InputIterator's value type is convertible to a type in
       OutputIterator's set of value types.

  Preconditions

   For the first version:

     * [first1, last1) is a valid range.
     * [first2, last2) is a valid range.
     * [first1, last1) is ordered in ascending order according to operator<.
       That is, for every pair of iterators i and j in [first1, last1) such
       that i precedes j, *j < *i is false.
     * [first2, last2) is ordered in ascending order according to operator<.
       That is, for every pair of iterators i and j in [first2, last2) such
       that i precedes j, *j < *i is false.
     * There is enough space to hold all of the elements being copied. More
       formally, the requirement is that [result, result + n) is a valid
       range, where n is the number of elements in the difference of the two
       input ranges.
     * [first1, last1) and [result, result + n) do not overlap.
     * [first2, last2) and [result, result + n) do not overlap.

   For the second version:

     * [first1, last1) is a valid range.
     * [first2, last2) is a valid range.
     * [first1, last1) is ordered in ascending order according to comp. That
       is, for every pair of iterators i and j in [first1, last1) such that i
       precedes j, comp(*j, *i) is false.
     * [first2, last2) is ordered in ascending order according to comp. That
       is, for every pair of iterators i and j in [first2, last2) such that i
       precedes j, comp(*j, *i) is false.
     * There is enough space to hold all of the elements being copied. More
       formally, the requirement is that [result, result + n) is a valid
       range, where n is the number of elements in the difference of the two
       input ranges.
     * [first1, last1) and [result, result + n) do not overlap.
     * [first2, last2) and [result, result + n) do not overlap.

  Complexity

   Linear. Zero comparisons if either [first1, last1) or [first2, last2) is
   empty, otherwise at most 2 * ((last1 - first1) + (last2 - first2)) - 1
   comparisons.

*stl-set_difference-example*

 inline bool lt_nocase(char c1, char c2) { return tolower(c1) < tolower(c2); }

 int main()
 {
   int A1[] = {1, 3, 5, 7, 9, 11};
   int A2[] = {1, 1, 2, 3, 5, 8, 13};
   char A3[] = {'a', 'b', 'b', 'B', 'B', 'f', 'g', 'h', 'H'};
   char A4[] = {'A', 'B', 'B', 'C', 'D', 'F', 'F', 'H' };

   const int N1 = sizeof(A1) / sizeof(int);
   const int N2 = sizeof(A2) / sizeof(int);
   const int N3 = sizeof(A3);
   const int N4 = sizeof(A4);

   cout << "Difference of A1 and A2: ";
   set_difference(A1, A1 + N1, A2, A2 + N2,
                  ostream_iterator<int>(cout, " "));
   cout << endl
        << "Difference of A3 and A4: ";
   set_difference(A3, A3 + N3, A4, A4 + N4,
                    ostream_iterator<char>(cout, " "),
                    lt_nocase);
   cout << endl;
 }

   The output is

 Difference of A1 and A2: 7 9 11
 Difference of A3 and A4: B B g H

  Notes

   [1] Even this is not a completely precise description, because the
   ordering by which the input ranges are sorted is permitted to be a strict
   weak ordering that is not a total ordering: there might be values x and y
   that are equivalent (that is, neither x < y nor y < x) but not equal. See
   the |stl-LessThanComparable| requirements for a fuller discussion. The
   output range consists of those elements from [first1, last1) for which
   equivalent elements do not exist in [first2, last2). Specifically, if the
   range [first1, last1) contains m elements that are equivalent to each
   other and the range [first2, last2) contains n elements from that
   equivalence class (where either m or n may be zero), then the output range
   contains the last max(m - n, 0) of these elements from [first1, last1).
   Note that this precision is only important if elements can be equivalent
   but not equal. If you're using a total ordering (if you're using strcmp,
   for example, or if you're using ordinary arithmetic comparison on
   integers), then you can ignore this technical distinction: for a total
   ordering, equality and equivalence are the same.

  See also

   |stl-includes|, |stl-set_union|, |stl-set_intersection|,
   |stl-set_symmetric_difference|, |stl-sort|

*stl-set_symmetric_difference*

                            set_symmetric_difference

   Category: algorithms                              Component type: function

  Prototype

   Set_symmetric_difference is an overloaded name; there are actually two
   set_symmetric_difference functions.

 template <class |stl-InputIterator|1, class |stl-InputIterator|2, class |stl-OutputIterator|>
 OutputIterator set_symmetric_difference(InputIterator1 first1,
                                         InputIterator1 last1,
                                         InputIterator2 first2,
                                         InputIterator2 last2,
                                         OutputIterator result);

 template <class |stl-InputIterator|1, class |stl-InputIterator|2, class |stl-OutputIterator|,
           class |stl-StrictWeakOrdering|>
 OutputIterator set_symmetric_difference(InputIterator1 first1,
                                         InputIterator1 last1,
                                         InputIterator2 first2,
                                         InputIterator2 last2,
                                         OutputIterator result,
                                         StrictWeakOrdering comp);

  Description

   Set_symmetric_difference constructs a sorted range that is the set
   symmetric difference of the sorted ranges [first1, last1) and [first2,
   last2). The return value is the end of the output range.

   In the simplest case, set_symmetric_difference performs a set theoretic
   calculation: it constructs the union of the two sets A - B and B - A,
   where A and B are the two input ranges. That is, the output range contains
   a copy of every element that is contained in [first1, last1) but not
   [first2, last2), and a copy of every element that is contained in [first2,
   last2) but not [first1, last1). The general case is more complicated,
   because the input ranges may contain duplicate elements. The
   generalization is that if a value appears m times in [first1, last1) and n
   times in [first2, last2) (where m or n may be zero), then it appears |m-n|
   times in the output range. [2][1] Set_symmetric_difference is stable,
   meaning that the relative order of elements within each input range is
   preserved.

   The two versions of set_symmetric_difference differ in how they define
   whether one element is less than another. The first version compares
   objects using operator<, and the second compares objects using a
   |stl-functors| comp.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

   For the first version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * InputIterator1 and InputIterator2 have the same value type.
     * InputIterator's value type is a model of |stl-LessThanComparable|.
     * The ordering on objects of InputIterator1's value type is a strict
       weak ordering, as defined in the |stl-LessThanComparable|
       requirements.
     * InputIterator's value type is convertible to a type in
       OutputIterator's set of value types.

   For the second version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * InputIterator1 and InputIterator2 have the same value type.
     * InputIterator1's value type is convertible to StrictWeakOrdering's
       argument type.
     * InputIterator's value type is convertible to a type in
       OutputIterator's set of value types.

  Preconditions

   For the first version:

     * [first1, last1) is a valid range.
     * [first2, last2) is a valid range.
     * [first1, last1) is ordered in ascending order according to operator<.
       That is, for every pair of iterators i and j in [first1, last1) such
       that i precedes j, *j < *i is false.
     * [first2, last2) is ordered in ascending order according to operator<.
       That is, for every pair of iterators i and j in [first2, last2) such
       that i precedes j, *j < *i is false.
     * There is enough space to hold all of the elements being copied. More
       formally, the requirement is that [result, result + n) is a valid
       range, where n is the number of elements in the symmetric difference
       of the two input ranges.
     * [first1, last1) and [result, result + n) do not overlap.
     * [first2, last2) and [result, result + n) do not overlap.

   For the second version:

     * [first1, last1) is a valid range.
     * [first2, last2) is a valid range.
     * [first1, last1) is ordered in ascending order according to comp. That
       is, for every pair of iterators i and j in [first1, last1) such that i
       precedes j, comp(*j, *i) is false.
     * [first2, last2) is ordered in ascending order according to comp. That
       is, for every pair of iterators i and j in [first2, last2) such that i
       precedes j, comp(*j, *i) is false.
     * There is enough space to hold all of the elements being copied. More
       formally, the requirement is that [result, result + n) is a valid
       range, where n is the number of elements in the symmetric difference
       of the two input ranges.
     * [first1, last1) and [result, result + n) do not overlap.
     * [first2, last2) and [result, result + n) do not overlap.

  Complexity

   Linear. Zero comparisons if either [first1, last1) or [first2, last2) is
   empty, otherwise at most 2 * ((last1 - first1) + (last2 - first2)) - 1
   comparisons.

*stl-set_symmetric_difference-example*

 inline bool lt_nocase(char c1, char c2) { return tolower(c1) < tolower(c2); }

 int main()
 {
   int A1[] = {1, 3, 5, 7, 9, 11};
   int A2[] = {1, 1, 2, 3, 5, 8, 13};
   char A3[] = {'a', 'b', 'b', 'B', 'B', 'f', 'g', 'h', 'H'};
   char A4[] = {'A', 'B', 'B', 'C', 'D', 'F', 'F', 'H' };

   const int N1 = sizeof(A1) / sizeof(int);
   const int N2 = sizeof(A2) / sizeof(int);
   const int N3 = sizeof(A3);
   const int N4 = sizeof(A4);

   cout << "Symmetric difference of A1 and A2: ";
   set_symmetric_difference(A1, A1 + N1, A2, A2 + N2,
                            ostream_iterator<int>(cout, " "));
   cout << endl
        << "Symmetric difference of A3 and A4: ";
   set_symmetric_difference(A3, A3 + N3, A4, A4 + N4,
                            ostream_iterator<char>(cout, " "),
                            lt_nocase);
   cout << endl;
 }

   The output is

 Symmetric difference of A1 and A2: 1 2 7 8 9 11 13
 Symmetric difference of A3 and A4: B B C D F g H

  Notes

   [1] Even this is not a completely precise description, because the
   ordering by which the input ranges are sorted is permitted to be a strict
   weak ordering that is not a total ordering: there might be values x and y
   that are equivalent (that is, neither x < y nor y < x) but not equal. See
   the |stl-LessThanComparable| requirements for a more complete discussion.
   The output range consists of those elements from [first1, last1) for which
   equivalent elements do not exist in [first2, last2), and those elements
   from [first2, last2) for which equivalent elements do not exist in
   [first1, last1). Specifically, suppose that the range [first1, last1)
   contains m elements that are equivalent to each other and the range
   [first2, last2) contains n elements from that equivalence class (where
   either m or n may be zero). If m > n then the output range contains the
   last m - n of these elements elements from [first1, last1), and if m < n
   then the output range contains the last n - m of these elements elements
   from [first2, last2).

  See also

   |stl-includes|, |stl-set_union|, |stl-set_intersection|,
   |stl-set_difference|, |stl-sort|

        ________________________________________________________________________
                                   Heap operations
*stl-push_heap*

                                   push_heap

   Category: algorithms                              Component type: function

  Prototype

   Push_heap is an overloaded name; there are actually two push_heap
   functions.

 template <class |stl-RandomAccessIterator|>
 void push_heap(RandomAccessIterator first, RandomAccessIterator last);

 template <class |stl-RandomAccessIterator|, class |stl-StrictWeakOrdering|>
 void push_heap(RandomAccessIterator first, RandomAccessIterator last,
                StrictWeakOrdering comp);

  Description

   Push_heap adds an element to a heap [2][1]. It is assumed that [first,
   last - 1) is already a heap; the element to be added to the heap is *(last
   - 1).

   The two versions of push_heap differ in how they define whether one
   element is less than another. The first version compares objects using
   operator<, and the second compares objects using a |stl-functors| comp.
   The postcondition for the first version is that |stl-is_heap|(first, last)
   is true, and the postcondition for the second version is that
   |stl-is_heap|(first, last, comp) is true.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

   For the first version:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * RandomAccessIterator is mutable.
     * RandomAccessIterator's value type is a model of
       |stl-LessThanComparable|.
     * The ordering on objects of RandomAccessIterator's value type is a
       strict weak ordering, as defined in the |stl-LessThanComparable|
       requirements.

   For the second version:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * RandomAccessIterator is mutable.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * RandomAccessIterator's value type is convertible to
       StrictWeakOrdering's argument type.

  Preconditions

   For the first version:

     * [first, last) is a valid range.
     * [first, last - 1) is a valid range. That is, [first, last) is
       nonempty.
     * [first, last - 1) is a heap. That is, |stl-is_heap|(first, last - 1)
       is true.

   For the second version:

     * [first, last) is a valid range.
     * [first, last - 1) is a valid range. That is, [first, last) is
       nonempty.
     * [first, last) is a heap. That is, |stl-is_heap|(first, last - 1, comp)
       is true.

  Complexity

   Logarithmic. At most log(last - first) comparisons.

*stl-push_heap-example*

 int main()
 {
   int A[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

   |stl-make_heap|(A, A + 9);
   cout << "[A, A + 9)  = ";
   |stl-copy|(A, A + 9, |stl-ostream_iterator|<int>(cout, " "));

   push_heap(A, A + 10);
   cout << endl << "[A, A + 10) = ";
   |stl-copy|(A, A + 10, |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;
 }

   The output is

 [A, A + 9)  = 8 7 6 3 4 5 2 1 0
 [A, A + 10) = 9 8 6 3 7 5 2 1 0 4

  Notes

   [1] A heap is a particular way of ordering the elements in a range of
   |stl-RandomAccessIterator| [f, l). The reason heaps are useful (especially
   for sorting, or as priority queues) is that they satisfy two important
   properties. First, *f is the largest element in the heap. Second, it is
   possible to add an element to a heap (using push_heap), or to remove *f,
   in logarithmic time. Internally, a heap is a tree represented as a
   sequential range. The tree is constructed so that that each node is less
   than or equal to its parent node.

  See also

   |stl-make_heap|, |stl-pop_heap|, |stl-sort_heap|, |stl-is_heap|,
   |stl-sort|

*stl-pop_heap*

                                    pop_heap

   Category: algorithms                              Component type: function

  Prototype

   Pop_heap is an overloaded name; there are actually two pop_heap functions.

 template <class |stl-RandomAccessIterator|>
 void pop_heap(RandomAccessIterator first, RandomAccessIterator last);

 template <class |stl-RandomAccessIterator|, class |stl-StrictWeakOrdering|>
 inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last,
                      StrictWeakOrdering comp);

  Description

   Pop_heap removes the largest element (that is, *first) from the heap
   [2][1] [first, last). The two versions of pop_heap differ in how they
   define whether one element is less than another. The first version
   compares objects using operator<, and the second compares objects using a
   |stl-functors| comp.

   The postcondition for the first version of pop_heap is that
   |stl-is_heap|(first, last-1) is true and that *(last - 1) is the element
   that was removed from the heap. The postcondition for the second version
   is that |stl-is_heap|(first, last-1, comp) is true and that *(last - 1) is
   the element that was removed from the heap. [3][2]

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [5]algo.h.

  Requirements on types

   For the first version:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * RandomAccessIterator is mutable.
     * RandomAccessIterator's value type is a model of
       |stl-LessThanComparable|.
     * The ordering on objects of RandomAccessIterator's value type is a
       strict weak ordering, as defined in the |stl-LessThanComparable|
       requirements.

   For the second version:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * RandomAccessIterator is mutable.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * RandomAccessIterator's value type is convertible to
       StrictWeakOrdering's argument type.

  Preconditions

   For the first version:

     * [first, last) is a valid range.
     * [first, last - 1) is a valid range. That is, [first, last) is
       nonempty.
     * [first, last) is a heap. That is, is_heap(first, last) is true.

   For the second version:

     * [first, last) is a valid range.
     * [first, last - 1) is a valid range. That is, [first, last) is
       nonempty.
     * [first, last) is a heap. That is, is_heap(first, last, comp) is true.

  Complexity

   Logarithmic. At most 2 * log(last - first) comparisons.

*stl-pop_heap-example*

 int main()
 {
   int A[] = {1, 2, 3, 4, 5, 6};
   const int N = sizeof(A) / sizeof(int);

   make_heap(A, A+N);
   cout << "Before pop: ";
   copy(A, A+N, ostream_iterator<int>(cout, " "));

   pop_heap(A, A+N);
   cout << endl << "After pop: ";
   copy(A, A+N-1, ostream_iterator<int>(cout, " "));
   cout << endl << "A[N-1] = " << A[N-1] << endl;
 }

   The output is

 Before pop: 6 5 3 4 2 1
 After pop: 5 4 3 1 2
 A[N-1] = 6

  Notes

   [1] A heap is a particular way of ordering the elements in a range of
   |stl-RandomAccessIterator| [f, l). The reason heaps are useful (especially
   for sorting, or as priority queues) is that they satisfy two important
   properties. First, *f is the largest element in the heap. Second, it is
   possible to add an element to a heap (using |stl-push_heap|), or to remove
   *f, in logarithmic time. Internally, a heap is a tree represented as a
   sequential range. The tree is constructed so that that each node is less
   than or equal to its parent node.

   [2] Pop_heap removes the largest element from a heap, and shrinks the
   heap. This means that if you call keep calling pop_heap until only a
   single element is left in the heap, you will end up with a sorted range
   where the heap used to be. This, in fact, is exactly how |stl-sort_heap|
   is implemented.

  See also

   |stl-make_heap|, |stl-push_heap|, |stl-sort_heap|, |stl-is_heap|,
   |stl-sort|

*stl-make_heap*

                                   make_heap

   Category: algorithms                              Component type: function

  Prototype

   Make_heap is an overloaded name; there are actually two make_heap
   functions.

 template <class |stl-RandomAccessIterator|>
 void make_heap(RandomAccessIterator first, RandomAccessIterator last);

 template <class |stl-RandomAccessIterator|, class |stl-StrictWeakOrdering|>
 void make_heap(RandomAccessIterator first, RandomAccessIterator last,
                StrictWeakOrdering comp);

  Description

   Make_heap turns the range [first, last) into a heap [2][1].

   The two versions of make_heap differ in how they define whether one
   element is less than another. The first version compares objects using
   operator<, and the second compares objects using a |stl-functors| comp. In
   the first version the postcondition is that |stl-is_heap|(first, last) is
   true, and in the second version the postcondition is that
   |stl-is_heap|(first, last, comp) is true.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

   For the first version:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * RandomAccessIterator is mutable.
     * RandomAccessIterator's value type is a model of
       |stl-LessThanComparable|.
     * The ordering on objects of RandomAccessIterator's value type is a
       strict weak ordering, as defined in the |stl-LessThanComparable|
       requirements.

   For the second version:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * RandomAccessIterator is mutable.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * RandomAccessIterator's value type is convertible to
       StrictWeakOrdering's argument type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear. At most 3*(last - first) comparisons.

*stl-make_heap-example*

 int main()
 {
   int A[] = {1, 4, 2, 8, 5, 7};
   const int N = sizeof(A) / sizeof(int);

   make_heap(A, A+N);
   |stl-copy|(A, A+N, |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;

   |stl-sort_heap|(A, A+N);
   |stl-copy|(A, A+N, |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;
 }

  Notes

   [1] A heap is a particular way of ordering the elements in a range of
   |stl-RandomAccessIterator| [f, l). The reason heaps are useful (especially
   for sorting, or as priority queues) is that they satisfy two important
   properties. First, *f is the largest element in the heap. Second, it is
   possible to add an element to a heap (using push_heap), or to remove *f,
   in logarithmic time. Internally, a heap is simply a tree represented as a
   sequential range. The tree is constructed so that that each node is less
   than or equal to its parent node.

  See also

   |stl-push_heap|, |stl-pop_heap|, |stl-sort_heap|, |stl-sort|,
   |stl-is_heap|

*stl-sort_heap*

                                   sort_heap

   Category: algorithms                              Component type: function

  Prototype

   Sort_heap is an overloaded name; there are actually two sort_heap
   functions.

 template <class |stl-RandomAccessIterator|>
 void sort_heap(RandomAccessIterator first, RandomAccessIterator last);

 template <class |stl-RandomAccessIterator|, class |stl-StrictWeakOrdering|>
 void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
                StrictWeakOrdering comp);

  Description

   Sort_heap turns a heap [2][1] [first, last) into a sorted range. Note that
   this is not a stable sort: the relative order of equivalent elements is
   not guaranteed to be preserved.

   The two versions of sort_heap differ in how they define whether one
   element is less than another. The first version compares objects using
   operator<, and the second compares objects using a |stl-functors| comp.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

   For the first version, the one that takes two arguments:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * RandomAccessIterator is mutable.
     * RandomAccessIterator's value type is a model of
       |stl-LessThanComparable|.
     * The ordering on objects of RandomAccessIterator's value type is a
       strict weak ordering, as defined in the |stl-LessThanComparable|
       requirements.

   For the second version, the one that takes three arguments:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * RandomAccessIterator is mutable.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * RandomAccessIterator's value type is convertible to
       StrictWeakOrdering's argument type.

  Preconditions

   For the first version, the one that takes two arguments:

     * [first, last) is a valid range.
     * [first, last) is a heap. That is, |stl-is_heap|(first, last) is true.

   For the second version, the one that takes three arguments:

     * [first, last) is a valid range.
     * [first, last) is a heap. That is, |stl-is_heap|(first, last, comp) is
       true.

  Complexity

   At most N * log(N) comparisons, where N is last - first.

*stl-sort_heap-example*

 int main()
 {
   int A[] = {1, 4, 2, 8, 5, 7};
   const int N = sizeof(A) / sizeof(int);

   |stl-make_heap|(A, A+N);
   |stl-copy|(A, A+N, |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;

   sort_heap(A, A+N);
   |stl-copy|(A, A+N, |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;
 }

  Notes

   [1] A heap is a particular way of ordering the elements in a range of
   |stl-RandomAccessIterator| [f, l). The reason heaps are useful (especially
   for sorting, or as priority queues) is that they satisfy two important
   properties. First, *f is the largest element in the heap. Second, it is
   possible to add an element to a heap (using push_heap), or to remove *f,
   in logarithmic time. Internally, a heap is a tree represented as a
   sequential range. The tree is constructed so that that each node is less
   than or equal to its parent node.

  See also

   |stl-push_heap|, |stl-pop_heap|, |stl-make_heap|, |stl-is_heap|,
   |stl-sort|, |stl-stable_sort|, |stl-partial_sort|, |stl-partial_sort_copy|

*stl-is_heap*

                                    is_heap

   Category: algorithms                              Component type: function

  Prototype

   Is_heap is an overloaded name; there are actually two is_heap functions.

 template <class |stl-RandomAccessIterator|>
 bool is_heap(RandomAccessIterator first, RandomAccessIterator last);

 template <class |stl-RandomAccessIterator|, class |stl-StrictWeakOrdering|>
 inline bool is_heap(RandomAccessIterator first, RandomAccessIterator last,
                     StrictWeakOrdering comp)

  Description

   Is_heap returns true if the range [first, last) is a heap [2][1], and
   false otherwise. The two versions differ in how they define whether one
   element is less than another: the first version compares objects using
   operator<, and the second compares objects using a |stl-functors| comp.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [4]algo.h. This function is an SGI
   extension; it is not part of the C++ standard.

  Requirements on types

   For the first version:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * RandomAccessIterator's value type is a model of
       |stl-LessThanComparable|.
     * The ordering on objects of RandomAccessIterator's value type is a
       strict weak ordering, as defined in the |stl-LessThanComparable|
       requirements.

   For the second version:

     * RandomAccessIterator is a model of |stl-RandomAccessIterator|.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * RandomAccessIterator's value type is convertible to
       StrictWeakOrdering's argument type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear. Zero comparisons if [first, last) is an empty range, otherwise at
   most (last - first) - 1 comparisons.

*stl-is_heap-example*

 int A[] = {1, 2, 3, 4, 5, 6, 7};
 const int N = sizeof(A) / sizeof(int);

 assert(!is_heap(A, A+N));
 |stl-make_heap|(A, A+N);
 assert(is_heap(A, A+N));

  Notes

   [1] A heap is a particular way of ordering the elements in a range of
   |stl-RandomAccessIterator| [f, l). The reason heaps are useful (especially
   for sorting, or as priority queues) is that they satisfy two important
   properties. First, *f is the largest element in the heap. Second, it is
   possible to add an element to a heap (using |stl-push_heap|), or to remove
   *f, in logarithmic time. Internally, a heap is a tree represented as a
   sequential range. The tree is constructed so that that each node is less
   than or equal to its parent node.

  See also

   |stl-make_heap|, |stl-push_heap|, |stl-pop_heap|, |stl-sort_heap|


        ________________________________________________________________________
                                 Minimum and maximum
*stl-min*

                                      min

   Categories: algorithms, utilities                 Component type: function

  Prototype

   Min is an overloaded name; there are actually two min functions.

 template <class T> const T& min(const T& a, const T& b);

 template <class T, class |stl-BinaryPredicate|>
 const T& min(const T& a, const T& b, BinaryPredicate comp);

  Description

   Min returns the lesser of its two arguments; it returns the first argument
   if neither is less than the other.

   The two versions of min differ in how they define whether one element is
   less than another. The first version compares objects using operator<, and
   the second compares objects using the |stl-functors| comp.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

   For the first version:

     * T is a model of |stl-LessThanComparable|.

   For the second version:

     * BinaryPredicate is a model of |stl-BinaryPredicate|.
     * T is convertible to BinaryPredicate's first argument type and to its
       second argument type.

  Preconditions

  Complexity

*stl-min-example*

 const int x = min(3, 9);
 assert(x == 3);

  See also

   |stl-max|, |stl-min_element|, |stl-max_element|, |stl-LessThanComparable|

*stl-max*

                                      max

   Categories: algorithms, utilities                 Component type: function

  Prototype

   Max is an overloaded name; there are actually two max functions.

 template <class T> const T& max(const T& a, const T& b);

 template <class T, class |stl-BinaryPredicate|>
 const T& max(const T& a, const T& b, BinaryPredicate comp);

  Description

   Max returns the greater of its two arguments; it returns the first
   argument if neither is greater than the other.

   The two versions of max differ in how they define whether one element is
   less than another. The first version compares objects using operator<, and
   the second compares objects using the |stl-functors| comp.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

   For the first version:

     * T is a model of |stl-LessThanComparable|.

   For the second version:

     * BinaryPredicate is a model of |stl-BinaryPredicate|.
     * T is convertible to BinaryPredicate's first argument type and to its
       second argument type.

  Preconditions

  Complexity

*stl-max-example*

 const int x = max(3, 9);
 assert(x == 9);

  See also

   |stl-min|, |stl-min_element|, |stl-max_element|, |stl-LessThanComparable|

*stl-min_element*

                                  min_element

   Category: algorithms                              Component type: function

  Prototype

   Min_element is an overloaded name; there are actually two min_element
   functions.

 template <class |stl-ForwardIterator|>
 ForwardIterator min_element(ForwardIterator first, ForwardIterator last);

 template <class |stl-ForwardIterator|, class |stl-BinaryPredicate|>
 ForwardIterator min_element(ForwardIterator first, ForwardIterator last,
                             |stl-BinaryPredicate| comp);

  Description

   Min_element finds the smallest element in the range [first, last). It
   returns the first iterator i in [first, last) such that no other iterator
   in [first, last) points to a value smaller than *i. The return value is
   last if and only if [first, last) is an empty range.

   The two versions of min_element differ in how they define whether one
   element is less than another. The first version compares objects using
   operator<, and the second compares objects using a |stl-functors| comp.

   The first version of min_element returns the first iterator i in [first,
   last) such that, for every iterator j in [first, last), *j < *i is false.
   The second version returns the first iterator i in [first, last) such
   that, for every iterator j in [first, last), comp(*j, *i) is false.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

   For the first version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * ForwardIterator's value type is |stl-LessThanComparable|.

   For the second version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * BinaryPredicate is a model of |stl-BinaryPredicate|.
     * ForwardIterator's value type is convertible to BinaryPredicate's first
       argument type and second argument type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear. Zero comparisons if [first, last) is an empty range, otherwise
   exactly (last - first) - 1 comparisons.

*stl-min_element-example*

 int main()
 {
   |stl-List|<int> L;
   |stl-generate_n|(|stl-front_insert_iterator|(L), 1000, rand);

   list<int>::const_iterator it = min_element(L.begin(), L.end());
   cout << "The smallest element is " << *it << endl;
 }

  See also

   |stl-min|, |stl-max|, |stl-max_element|, |stl-LessThanComparable|,
   |stl-sort|, |stl-nth_element|

*stl-max_element*

                                  max_element

   Category: algorithms                              Component type: function

  Prototype

   Max_element is an overloaded name; there are actually two max_element
   functions.

 template <class |stl-ForwardIterator|>
 ForwardIterator max_element(ForwardIterator first, ForwardIterator last);

 template <class |stl-ForwardIterator|, class |stl-BinaryPredicate|>
 ForwardIterator max_element(ForwardIterator first, ForwardIterator last,
                             |stl-BinaryPredicate| comp);

  Description

   Max_element finds the largest element in the range [first, last). It
   returns the first iterator i in [first, last) such that no other iterator
   in [first, last) points to a value greater than *i. The return value is
   last if and only if [first, last) is an empty range.

   The two versions of max_element differ in how they define whether one
   element is less than another. The first version compares objects using
   operator<, and the second compares objects using a |stl-functors| comp.

   The first version of max_element returns the first iterator i in [first,
   last) such that, for every iterator j in [first, last), *i < *j is false.
   The second version returns the first iterator i in [first, last) such
   that, for every iterator j in [first, last), comp(*i, *j) is false.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

   For the first version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * ForwardIterator's value type is |stl-LessThanComparable|.

   For the second version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * BinaryPredicate is a model of |stl-BinaryPredicate|.
     * ForwardIterator's value type is convertible to BinaryPredicate's first
       argument type and second argument type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear. Zero comparisons if [first, last) is an empty range, otherwise
   exactly (last - first) - 1 comparisons.

*stl-max_element-example*

 int main()
 {
   |stl-List|<int> L;
   |stl-generate_n|(|stl-front_insert_iterator|(L), 1000, rand);

   list<int>::const_iterator it = max_element(L.begin(), L.end());
   cout << "The largest element is " << *it << endl;
 }

  See also

   |stl-min|, |stl-max|, |stl-min_element|, |stl-LessThanComparable|,
   |stl-sort|, |stl-nth_element|


*stl-lexicographical_compare*

                            lexicographical_compare

   Category: algorithms                              Component type: function

  Prototype

   Lexicographical_compare is an overloaded name; there are actually two
   lexicographical_compare functions.

 template <class |stl-InputIterator|1, class |stl-InputIterator|2>
 bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                              InputIterator2 first2, InputIterator2 last2);

 template <class |stl-InputIterator|1, class |stl-InputIterator|2, class |stl-BinaryPredicate|>
 bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                              InputIterator2 first2, InputIterator2 last2,
                              BinaryPredicate comp);

  Description

   Lexicographical_compare returns true if the range of elements [first1,
   last1) is lexicographically less than the range of elements [first2,
   last2), and false otherwise. Lexicographical comparison means "dictionary"
   (element-by-element) ordering. That is, [first1, last1) is less than
   [first2, last2) if *first1 is less than *first2, and greater if *first1 is
   greater than *first2. If the two first elements are equivalent then
   lexicographical_compare compares the two second elements, and so on. As
   with ordinary dictionary order, the first range is considered to be less
   than the second if every element in the first range is equal to the
   corresponding element in the second but the second contains more elements.

   The two versions of lexicographical_compare differ in how they define
   whether one element is less than another. The first version compares
   objects using operator<, and the second compares objects using a
   |stl-functors| comp.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [3]algo.h.

  Requirements on types

   For the first version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * InputIterator1's value type is a model of |stl-LessThanComparable|.
     * InputIterator2's value type is a model of |stl-LessThanComparable|.
     * If v1 is an object of InputIterator1's value type and v2 is an object
       of InputIterator2's value type, then both v1 < v2 and v2 < v1 are
       defined.

   For the second version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * BinaryPredicate is a model of |stl-BinaryPredicate|.
     * InputIterator1's value type is convertible to BinaryPredicate's first
       argument type and second argument type.
     * InputIterator2's value type is convertible to BinaryPredicate's first
       argument type and second argument type.

  Preconditions

     * [first1, last1) is a valid range.
     * [first2, last2) is a valid range.

  Complexity

   Linear. At most 2 * min(last1 - first1, last2 - first2) comparisons.

*stl-lexicographical_compare-example*

 int main()
 {
   int A1[] = {3, 1, 4, 1, 5, 9, 3};
   int A2[] = {3, 1, 4, 2, 8, 5, 7};
   int A3[] = {1, 2, 3, 4};
   int A4[] = {1, 2, 3, 4, 5};

   const int N1 = sizeof(A1) / sizeof(int);
   const int N2 = sizeof(A2) / sizeof(int);
   const int N3 = sizeof(A3) / sizeof(int);
   const int N4 = sizeof(A4) / sizeof(int);

   bool C12 = lexicographical_compare(A1, A1 + N1, A2, A2 + N2);
   bool C34 = lexicographical_compare(A3, A3 + N3, A4, A4 + N4);

   cout << "A1[] < A2[]: " << (C12 ? "true" : "false") << endl;
   cout << "A3[] < A4[]: " << (C34 ? "true" : "false") << endl;
 }

  See also

   |stl-equal|, |stl-mismatch|, |stl-lexicographical_compare_3way|,
   |stl-search|, |stl-LessThanComparable|, |stl-StrictWeakOrdering|,
   |stl-sort|

*stl-lexicographical_compare_3way*

                          lexicographical_compare_3way

   Category: algorithms                              Component type: function

  Prototype

 template <class |stl-InputIterator|1, class |stl-InputIterator|2>
 int lexicographical_compare_3way(InputIterator1 first1, InputIterator1 last1,
                                  InputIterator2 first2, InputIterator2 last2);

  Description

   Lexicographical_compare_3way is essentially a generalization of the
   function strcmp from the standard C library: it returns a negative number
   if the range [first1, last1) is lexicographically less than the range
   [first2, last2), a positive number if [first2, last2) is lexicographically
   less than [first1, last1), and zero if neither range is lexicographically
   less than the other. [2][1]

   As with |stl-lexicographical_compare|, lexicographical comparison means
   "dictionary" (element-by-element) ordering. That is,
   lexicographical_compare_3way returns a negative number if *first1 is less
   than *first2, and a positive number if *first1 is greater than *first2. If
   the two first elements are equivalent [3][2] then
   lexicographical_compare_3way compares the two second elements, and so on.
   Lexicographical_compare_3way returns 0 only if the two ranges [first1,
   last1) and [first2, last2) have the same length and if every element in
   the first range is equivalent to its corresponding element in the second.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [5]algo.h. This function is an SGI
   extension; it is not part of the C++ standard.

  Requirements on types

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * InputIterator1's value type is a model of |stl-LessThanComparable|.
     * InputIterator2's value type is a model of |stl-LessThanComparable|.
     * If v1 is an object of InputIterator1's value type and v2 is an object
       of InputIterator2's value type, then both v1 < v2 and v2 < v1 are
       defined.
     * Operator< is a strict weak ordering, as defined in the
       |stl-LessThanComparable| requirements.

  Preconditions

     * [first1, last1) is a valid range.
     * [first2, last2) is a valid range.

  Complexity

   Linear. At most 2 * min(last1 - first1, last2 - first2) comparisons.

*stl-lexicographical_compare_3way-example*

 int main()
 {
   int A1[] = {3, 1, 4, 2, 8, 5, 7};
   int A2[] = {3, 1, 4, 1, 5, 9, 3};
   int A3[] = {1, 2, 3, 4};
   int A4[] = {1, 2, 3, 4, 5};

   const int N1 = sizeof(A1) / sizeof(int);
   const int N2 = sizeof(A2) / sizeof(int);
   const int N3 = sizeof(A3) / sizeof(int);
   const int N4 = sizeof(A4) / sizeof(int);

   int C12 = lexicographical_compare_3way(A1, A1 + N1, A2, A2 + N2);
   int C34 = lexicographical_compare_3way(A3, A3 + N3, A4, A4 + N4);

   cout << "A1[] and A2[]: " << C12 << endl;
   cout << "A3[] and A4[]: " << C34 << endl;
 }

  Notes

   [1] Lexicographical_compare_3way is almost, but not quite, redundant: the
   call lexicographical_compare_3way(f1,l1, f2,l2) could be written as
   |stl-lexicographical_compare|(f1,l1, f2,l2) ? -1 :
   (|stl-lexicographical_compare|(f2,l2, f1,l1) ? 1 : 0). The single call to
   lexicographical_compare_3way, however, is much faster than the two calls
   to |stl-lexicographical_compare|.

   [2] "Equivalent", not "equal", because two equivalent elements (that is,
   two elements with the property that neither one is less than the other)
   are not necessarily equal. Operator< is required to induce a strict weak
   ordering, not necessarily a total ordering. See the
   |stl-LessThanComparable| requirements for a discussion.

  See also

   |stl-lexicographical_compare|, |stl-equal|, |stl-mismatch|, |stl-search|,
   |stl-LessThanComparable|, |stl-StrictWeakOrdering|, |stl-sort|

*stl-next_permutation*

                                next_permutation

   Category: algorithms                              Component type: function

  Prototype

   Next_permutation is an overloaded name; there are actually two
   next_permutation functions.

 template <class |stl-BidirectionalIterator|>
 bool next_permutation(BidirectionalIterator first,
                       BidirectionalIterator last);

 template <class |stl-BidirectionalIterator|, class |stl-StrictWeakOrdering|>
 bool next_permutation(BidirectionalIterator first, BidirectionalIterator last,
                       |stl-StrictWeakOrdering| comp);

  Description

   Next_permutation transforms the range of elements [first, last) into the
   lexicographically next greater permutation of the elements. There is a
   finite number of distinct permutations (at most N! [2][1], where N is last
   - first), so, if the permutations are ordered by
   |stl-lexicographical_compare|, there is an unambiguous definition of which
   permutation is lexicographically next. If such a permutation exists,
   next_permutation transforms [first, last) into that permutation and
   returns true. Otherwise it transforms [first, last) into the
   lexicographically smallest permutation [3][2] and returns false.

   The postcondition is that the new permutation of elements is
   lexicographically greater than the old (as determined by
   |stl-lexicographical_compare|) if and only if the return value is true.

   The two versions of next_permutation differ in how they define whether one
   element is less than another. The first version compares objects using
   operator<, and the second compares objects using a |stl-functors| comp.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [5]algo.h.

  Requirements on types

   For the first version, the one that takes two arguments:

     * BidirectionalIterator is a model of |stl-BidirectionalIterator|.
     * BidirectionalIterator is mutable.
     * BidirectionalIterator's value type is |stl-LessThanComparable|.
     * The ordering relation on BidirectionalIterator's value type is a
       strict weak ordering, as defined in the |stl-LessThanComparable|
       requirements.

   For the second version, the one that takes three arguments:

     * BidirectionalIterator is a model of |stl-BidirectionalIterator|.
     * BidirectionalIterator is mutable.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * BidirectionalIterator's value type is convertible to
       StrictWeakOrdering's argument type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear. At most (last - first) / 2 swaps.

*stl-next_permutation-example*

   This example uses next_permutation to implement the worst known
   deterministic sorting algorithm. Most sorting algorithms are O(N log(N)),
   and even bubble sort is only O(N^2). This algorithm is actually O(N!).

 template <class BidirectionalIterator>
 void snail_sort(BidirectionalIterator first, BidirectionalIterator last)
 {
   while (next_permutation(first, last)) {}
 }

 int main()
 {
   int A[] = {8, 3, 6, 1, 2, 5, 7, 4};
   const int N = sizeof(A) / sizeof(int);

   snail_sort(A, A+N);
   |stl-copy|(A, A+N, |stl-ostream_iterator|<int>(cout, "\n"));
 }

  Notes

   [1] If all of the elements in [first, last) are distinct from each other,
   then there are exactly N! permutations. If some elements are the same as
   each other, though, then there are fewer. There are, for example, only
   three (3!/2!) permutations of the elements 1 1 2.

   [2] Note that the lexicographically smallest permutation is, by
   definition, sorted in nondecreasing order.

  See also

   |stl-prev_permutation|, |stl-lexicographical_compare|,
   |stl-LessThanComparable|, |stl-StrictWeakOrdering|, |stl-sort|

*stl-prev_permutation*

                                prev_permutation

   Category: algorithms                              Component type: function

  Prototype

   Prev_permutation is an overloaded name; there are actually two
   prev_permutation functions.

 template <class |stl-BidirectionalIterator|>
 bool prev_permutation(BidirectionalIterator first,
                       BidirectionalIterator last);

 template <class |stl-BidirectionalIterator|, class |stl-StrictWeakOrdering|>
 bool prev_permutation(BidirectionalIterator first, BidirectionalIterator last,
                       |stl-StrictWeakOrdering| comp);

  Description

   Prev_permutation transforms the range of elements [first, last) into the
   lexicographically next smaller permutation of the elements. There is a
   finite number of distinct permutations (at most N! [2][1], where N is last
   - first), so, if the permutations are ordered by
   |stl-lexicographical_compare|, there is an unambiguous definition of which
   permutation is lexicographically previous. If such a permutation exists,
   prev_permutation transforms [first, last) into that permutation and
   returns true. Otherwise it transforms [first, last) into the
   lexicographically greatest permutation [3][2] and returns false.

   The postcondition is that the new permutation of elements is
   lexicographically less than the old (as determined by
   |stl-lexicographical_compare|) if and only if the return value is true.

   The two versions of prev_permutation differ in how they define whether one
   element is less than another. The first version compares objects using
   operator<, and the second compares objects using a |stl-functors| comp.

  Definition

   Defined in the standard header |stl-algorithm|, and in the nonstandard
   backward-compatibility header [5]algo.h.

  Requirements on types

   For the first version:

     * BidirectionalIterator is a model of |stl-BidirectionalIterator|.
     * BidirectionalIterator is mutable.
     * BidirectionalIterator's value type is |stl-LessThanComparable|.
     * The ordering relation on BidirectionalIterator's value type is a
       strict weak ordering, as defined in the |stl-LessThanComparable|
       requirements.

   For the second version:

     * BidirectionalIterator is a model of |stl-BidirectionalIterator|.
     * BidirectionalIterator is mutable.
     * StrictWeakOrdering is a model of |stl-StrictWeakOrdering|.
     * BidirectionalIterator's value type is convertible to
       StrictWeakOrdering's argument type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear. At most (last - first) / 2 swaps.

*stl-prev_permutation-example*

 int main()
 {
   int A[] = {2, 3, 4, 5, 6, 1};
   const int N = sizeof(A) / sizeof(int);

   cout << "Initially:              ";
   |stl-copy|(A, A+N, |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;

   prev_permutation(A, A+N);
   cout << "After prev_permutation: ";
   |stl-copy|(A, A+N, |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;

   next_permutation(A, A+N);
   cout << "After next_permutation: ";
   |stl-copy|(A, A+N, |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;
 }

  Notes

   [1] If all of the elements in [first, last) are distinct from each other,
   then there are exactly N! permutations. If some elements are the same as
   each other, though, then there are fewer. There are, for example, only
   three (3!/2!) permutations of the elements 1 1 2.

   [2] Note that the lexicographically greatest permutation is, by
   definition, sorted in nonascending order.

  See also

   |stl-next_permutation|, |stl-lexicographical_compare|,
   |stl-LessThanComparable|, |stl-StrictWeakOrdering|, |stl-sort|



    ----------------------------------------------------------------------------
                          Generalized numeric algorithms
    ----------------------------------------------------------------------------
*stl-iota*

                                      iota

   Category: algorithms                              Component type: function

  Prototype

 template <class ForwardIterator, class T>
 void iota(ForwardIterator first, ForwardIterator last, T value);

  Description

   Iota assigns sequentially increasing values to a range. That is, it
   assigns value to *first, value + 1 to *(first + 1) and so on. In general,
   each iterator i in the range [first, last) is assigned value + (i -
   first). [2][1]

  Definition

   Defined in the standard header |stl-numeric|, and in the nonstandard
   backward-compatibility header [4]algo.h. This function is an SGI
   extension; it is not part of the C++ standard.

  Requirements on types

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * ForwardIterator is mutable.
     * T is |stl-Assignable|.
     * If x is an object of type T, then x++ is defined.
     * T is convertible to ForwardIterator's value type.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear. Exactly last - first assignments.

*stl-iota-example*

 int main()
 {
   vector<int> V(10);

   iota(V.begin(), V.end(), 7);
   copy(V.begin(), V.end(), ostream_iterator<int>(cout, " "));
   cout << endl;
 }

  Notes

   [1] The name iota is taken from the programming language APL.

  See also

   |stl-fill|, |stl-generate|, |stl-partial_sum|

*stl-accumulate*

                                   accumulate

   Category: algorithms                              Component type: function

  Prototype

   Accumulate is an overloaded name; there are actually two accumulate
   functions.

 template <class |stl-InputIterator|, class T>
 T accumulate(InputIterator first, InputIterator last, T init);

 template <class |stl-InputIterator|, class T, class |stl-BinaryFunction|>
 T accumulate(InputIterator first, InputIterator last, T init,
              BinaryFunction binary_op);

  Description

   Accumulate is a generalization of summation: it computes the sum (or some
   other binary operation) of init and all of the elements in the range
   [first, last). [2][1]

   The |stl-functors| binary_op is not required to be either commutative or
   associative: the order of all of accumulate's operations is specified. The
   result is first initialized to init. Then, for each iterator i in [first,
   last), in order from beginning to end, it is updated by result = result +
   *i (in the first version) or result = binary_op(result, *i) (in the second
   version).

  Definition

   Defined in the standard header |stl-numeric|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

   For the first version, the one that takes two arguments:

     * InputIterator is a model of |stl-InputIterator|.
     * T is a model of |stl-Assignable|.
     * If x is an object of type T and y is an object of InputIterator's
       value type, then x + y is defined.
     * The return type of x + y is convertible to T.

   For the second version, the one that takes three arguments:

     * InputIterator is a model of |stl-InputIterator|.
     * T is a model of |stl-Assignable|.
     * BinaryFunction is a model of |stl-BinaryFunction|.
     * T is convertible to BinaryFunction's first argument type.
     * The value type of InputIterator is convertible to BinaryFunction's
       second argument type.
     * BinaryFunction's return type is convertible to T.

  Preconditions

     * [first, last) is a valid range.

  Complexity

   Linear. Exactly last - first invocations of the binary operation.

*stl-accumulate-example*

 int main()
 {
   int A[] = {1, 2, 3, 4, 5};
   const int N = sizeof(A) / sizeof(int);

   cout << "The sum of all elements in A is "
        << accumulate(A, A + N, 0)
        << endl;

   cout << "The product of all elements in A is "
        << accumulate(A, A + N, 1, multiplies<int>())
        << endl;
 }

  Notes

   [1] There are several reasons why it is important that accumulate starts
   with the value init. One of the most basic is that this allows accumulate
   to have a well-defined result even if [first, last) is an empty range: if
   it is empty, the return value is init. If you want to find the sum of all
   of the elements in [first, last), you can just pass 0 as init.

  See also

   |stl-inner_product|, |stl-partial_sum|, |stl-adjacent_difference|,
   |stl-count|

*stl-inner_product*

                                 inner_product

   Category: algorithms                              Component type: function

  Prototype

   Inner_product is an overloaded name; there are actually two inner_product
   functions.

 template <class |stl-InputIterator|1, class |stl-InputIterator|2, class T>
 T inner_product(InputIterator1 first1, InputIterator1 last1,
                 InputIterator2 first2, T init);

 template <class |stl-InputIterator|1, class |stl-InputIterator|2, class T,
           class |stl-BinaryFunction|1, class |stl-BinaryFunction|2>
 T inner_product(InputIterator1 first1, InputIterator1 last1,
                 InputIterator2 first2, T init, BinaryFunction1 binary_op1,
                 BinaryFunction2 binary_op2);

  Description

   Inner_product calculates a generalized inner product of the ranges
   [first1, last1) and [first2, last2).

   The first version of inner_product returns init plus the inner product of
   the two ranges [2][1]. That is, it first initializes the result to init
   and then, for each iterator i in [first1, last1), in order from the
   beginning to the end of the range, updates the result by result = result +
   (*i) * *(first2 + (i - first1)).

   The second version of inner_product is identical to the first, except that
   it uses two user-supplied |stl-functors| instead of operator+ and
   operator*. That is, it first initializes the result to init and then, for
   each iterator i in [first1, last1), in order from the beginning to the end
   of the range, updates the result by result = binary_op1(result,
   binary_op2(*i, *(first2 + (i - first1))). [3][2]

  Definition

   Defined in the standard header |stl-numeric|, and in the nonstandard
   backward-compatibility header [5]algo.h.

  Requirements on types

   For the first version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * T is a model of |stl-Assignable|.
     * If x is an object of type T, y is an object of InputIterator1's value
       type, and z is an object of InputIterator2's value type, then x + y *
       z is defined.
     * The type of x + y * z is convertible to T.

   For the second version:

     * InputIterator1 is a model of |stl-InputIterator|.
     * InputIterator2 is a model of |stl-InputIterator|.
     * T is a model of |stl-Assignable|.
     * BinaryFunction1 is a model of |stl-BinaryFunction|.
     * BinaryFunction2 is a model of |stl-BinaryFunction|.
     * InputIterator1's value type is convertible to BinaryFunction2's first
       argument type.
     * InputIterator2's value type is convertible to BinaryFunction2's second
       argument type.
     * T is convertible to BinaryFunction1's first argument type.
     * BinaryFunction2's return type is convertible to BinaryFunction1's
       second argument type.
     * BinaryFunction1's return type is convertible to T.

  Preconditions

     * [first1, last1) is a valid range.
     * [first2, first2 + (last1 - first1)) is a valid range.

  Complexity

   Linear. Exactly last1 - first1 applications of each binary operation.

*stl-inner_product-example*

 int main()
 {
   int A1[] = {1, 2, 3};
   int A2[] = {4, 1, -2};
   const int N1 = sizeof(A1) / sizeof(int);

   cout << "The inner product of A1 and A2 is "
        << inner_product(A1, A1 + N1, A2, 0)
        << endl;
 }

  Notes

   [1] There are several reasons why it is important that inner_product
   starts with the value init. One of the most basic is that this allows
   inner_product to have a well-defined result even if [first1, last1) is an
   empty range: if it is empty, the return value is init. The ordinary inner
   product corresponds to setting init to 0.

   [2] Neither binary operation is required to be either associative or
   commutative: the order of all operations is specified.

  See also

   |stl-accumulate|, |stl-partial_sum|, |stl-adjacent_difference|,
   |stl-count|

*stl-partial_sum*

                                  partial_sum

   Category: algorithms                              Component type: function

  Prototype

   Partial_sum is an overloaded name; there are actually two partial_sum
   functions.

 template <class InputIterator, class OutputIterator>
 OutputIterator partial_sum(InputIterator first, InputIterator last,
                            OutputIterator result);

 template <class InputIterator, class OutputIterator, class BinaryOperation>
 OutputIterator partial_sum(InputIterator first, InputIterator last,
                            OutputIterator result, BinaryOperation binary_op);

  Description

   Partial_sum calculates a generalized partial sum: *first is assigned to
   *result, the sum of *first and *(first + 1) is assigned to *(result + 1),
   and so on. [2][1]

   More precisely, a running sum is first initialized to *first and assigned
   to *result. For each iterator i in [first + 1, last), in order from
   beginning to end, the sum is updated by sum = sum + *i (in the first
   version) or sum = binary_op(sum, *i) (in the second version) and is
   assigned to *(result + (i - first)). [3][2]

  Definition

   Defined in the standard header |stl-numeric|, and in the nonstandard
   backward-compatibility header [5]algo.h.

  Requirements on types

   For the first version:

     * InputIterator is a model of |stl-InputIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * If x and y are objects of InputIterator's value type, then x + y is
       defined.
     * The return type of x + y is convertible to InputIterator's value type.
     * InputIterator's value type is convertible to a type in
       OutputIterator's set of value types.

   For the second version:

     * InputIterator is a model of |stl-InputIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * BinaryFunction is a model of |stl-BinaryFunction|.
     * InputIterator's value type is convertible to BinaryFunction's first
       argument type and second argument type.
     * BinaryFunction's result type is convertible to InputIterator's value
       type.
     * InputIterator's value type is convertible to a type in
       OutputIterator's set of value types.

  Preconditions

     * [first, last) is a valid range.
     * [result, result + (last - first)) is a valid range.

  Complexity

   Linear. Zero applications of the binary operation if [first, last) is a
   empty range, otherwise exactly (last - first) - 1 applications.

*stl-partial_sum-example*

 int main()
 {
   const int N = 10;
   int A[N];

   fill(A, A+N, 1);
   cout << "A:                 ";
   |stl-copy|(A, A+N, |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;

   cout << "Partial sums of A: ";
   |stl-partial_sum|(A, A+N, |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;
 }

  Notes

   [1] Note that result is permitted to be the same iterator as first. This
   is useful for computing partial sums "in place".

   [2] The binary operation is not required to be either associative or
   commutative: the order of all operations is specified.

  See also

   |stl-adjacent_difference|, |stl-accumulate|, |stl-inner_product|,
   |stl-count|

*stl-adjacent_difference*

                              adjacent_difference

   Category: algorithms                              Component type: function

  Prototype

   Adjacent_difference is an overloaded name; there are actually two
   adjacent_difference functions.

 template <class |stl-InputIterator|, class |stl-OutputIterator|>
 OutputIterator adjacent_difference(InputIterator first, InputIterator last,
                                    OutputIterator result);

 template <class |stl-InputIterator|, class |stl-OutputIterator|, class |stl-BinaryFunction|>
 OutputIterator adjacent_difference(InputIterator first, InputIterator last,
                                    OutputIterator result,
                                    BinaryFunction binary_op);

  Description

   Adjacent_difference calculates the differences of adjacent elements in the
   range [first, last). This is, *first is assigned to *result [2][1], and,
   for each iterator i in the range [first + 1, last), the difference of *i
   and *(i - 1) is assigned to *(result + (i - first)). [3][2]

   The first version of adjacent_difference uses operator- to calculate
   differences, and the second version uses a user-supplied
   |stl-BinaryFunction|. In the first version, for each iterator i in the
   range [first + 1, last), *i - *(i - 1) is assigned to *(result + (i -
   first)). In the second version, the value that is assigned to *(result +
   1) is instead binary_op(*i, *(i - 1)).

  Definition

   Defined in the standard header |stl-numeric|, and in the nonstandard
   backward-compatibility header [5]algo.h.

  Requirements on types

   For the first version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * If x and y are objects of ForwardIterator's value type, then x - y is
       defined.
     * InputIterators value type is convertible to a type in OutputIterator's
       set of value types.
     * The return type of x - y is convertible to a type in OutputIterator's
       set of value types.

   For the second version:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * OutputIterator is a model of |stl-OutputIterator|.
     * BinaryFunction is a model of |stl-BinaryFunction|.
     * InputIterator's value type is convertible to a BinaryFunction's first
       argument type and second argument type.
     * InputIterators value type is convertible to a type in OutputIterator's
       set of value types.
     * BinaryFunction's result type is convertible to a type in
       OutputIterator's set of value types.

  Preconditions

     * [first, last) is a valid range.
     * [result, result + (last - first)) is a valid range.

  Complexity

   Linear. Zero applications of the binary operation if [first, last) is an
   empty range, otherwise exactly (last - first) - 1 applications.

*stl-adjacent_difference-example*

 int main()
 {
   int A[] = {1, 4, 9, 16, 25, 36, 49, 64, 81, 100};
   const int N = sizeof(A) / sizeof(int);
   int B[N];

   cout << "A[]:         ";
   |stl-copy|(A, A + N, |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;

   adjacent_difference(A, A + N, B);
   cout << "Differences: ";
   |stl-copy|(B, B + N, |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;

   cout << "Reconstruct: ";
   partial_sum(B, B + N, |stl-ostream_iterator|<int>(cout, " "));
   cout << endl;
 }

  Notes

   [1] The reason it is useful to store the value of the first element, as
   well as simply storing the differences, is that this provides enough
   information to reconstruct the input range. In particular, if addition and
   subtraction have the usual arithmetic definitions, then
   adjacent_difference and |stl-partial_sum| are inverses of each other.

   [2] Note that result is permitted to be the same iterator as first. This
   is useful for computing differences "in place".

  See also

   |stl-partial_sum|, |stl-accumulate|, |stl-inner_product|, |stl-count|

*stl-power*

                                     power

   Category: algorithms                              Component type: function

  Prototype

   Power is an overloaded name; there are actually two power functions.

 template <class T, class Integer>
 inline T power(T x, Integer n);

 template <class T, class Integer, class |stl-MonoidOperation|>
 T power(T x, Integer n, MonoidOperation op);

  Description

   Power is generalized exponentiation: it raises the value x to the power n,
   where n is a non-negative integer.

   The first version of power returns x raised to the nth power; that is, it
   returns x * x ... * x, where x is repeated n times. [2][1] If n == 0, then
   it returns |stl-MonoidOperation|(|stl-multiplies|<T>()).

   The second version of power is just like the first except that it uses an
   arbitrary |stl-MonoidOperation| instead of |stl-multiplies|<T>, returning
   |stl-MonoidOperation|(op) when n == 0.

   Important note: power does not assume that multiplication is commutative,
   but it does rely crucially on the fact that multiplication is associative.
   If you have defined * or |stl-MonoidOperation| to be a non-associative
   operation, then power will give you the wrong answer. [3][2]

  Definition

   Defined in the standard header |stl-numeric|, and in the nonstandard
   backward-compatibility header [5]algo.h. This function is an SGI
   extension; it is not part of the C++ standard.

  Requirements on types

   For the first version:

     * |stl-multiplies|<T> is a model of |stl-MonoidOperation|.
     * Integer is an integral type.

   For the second version:

     * MonoidOperation is a model of |stl-MonoidOperation|.
     * T is MonoidOperation's argument type.
     * n is an integral type.

  Preconditions

     * n >= 0.

  Complexity

   The number of multiplications (or, in the case of the second version, the
   number of applications of MonoidOperation) is lg(n) + nu(n) where lg is
   the base 2 logarithm and nu(n) is the number of 1s in the binary
   representation of n. [6][3]

*stl-power-example*

 int main() {
   cout << "2 ** 30 = " << power(2, 30) << endl;
 }

  Notes

   [1] This is a conceptual description of what power's return value is; it
   is not how power is actually implemented. If power were implemented that
   way then it would require n-1 multiplications, which would be grossly
   inefficient. Power is implemented using the "Russian peasant algorithm",
   which requires only O(log n) multiplications. See section 4.6.3 of Knuth
   (D. E. Knuth, The Art of Computer Programming. Volume 2: Seminumerical
   Algorithms, Addison-Wesley, 1981) for a discussion.

   [2] See the |stl-MonoidOperation| requirements for a discussion of
   associativity.

   [3] This is in fact not the minimum possible number of multiplications: it
   is possible to compute the fifteenth power of x using only five
   multiplications, but power(x, 15) uses six.

  See also

   |stl-MonoidOperation|, |stl-multiplies|, |stl-plus|

    ----------------------------------------------------------------------------

    ----------------------------------------------------------------------------
********************************************************************************
                               Function Objects
********************************************************************************



    ----------------------------------------------------------------------------
                           Function Object Introduction
    ----------------------------------------------------------------------------
*stl-functors*

                                Function Objects

   Category: functors                                Component type: overview

  Summary

   A Function Object, or Functor (the two terms are synonymous) is simply any
   object that can be called as if it is a function. An ordinary function is
   a function object, and so is a function pointer; more generally, so is an
   object of a class that defines operator().

  Description

   The basic function object concepts are |stl-Generator|,
   |stl-UnaryFunction|, and |stl-BinaryFunction|: these describe,
   respectively, objects that can be called as f(), f(x), and f(x,y). (This
   list could obviously be extended to ternary function and beyond, but, in
   practice, no STL algorithms require function objects of more than two
   arguments.) All other function object concepts defined by the STL are
   refinements of these three.

   Function objects that return bool are an important special case. A
   |stl-UnaryFunction| whose return type is bool is called a |stl-Predicate|,
   and a |stl-BinaryFunction| whose return type is bool is called a
   |stl-BinaryPredicate|.

   There is an important distinction, but a somewhat subtle one, between
   function objects and adaptable function objects. [2][1] In general, a
   function object has restrictions on the type of its argument. The type
   restrictions need not be simple, though: operator() may be overloaded, or
   may be a member template, or both. Similarly, there need be no way for a
   program to determine what those restrictions are. An adaptable function
   object, however, does specify what the argument and return types are, and
   provides nested typedefs so that those types can be named and used in
   programs. If a type F0 is a model of |stl-AdaptableGenerator|, then it
   must define F0::result_type. Similarly, if F1 is a model of
   |stl-AdaptableUnaryFunction| then it must define F1::argument_type and
   F1::result_type, and if F2 is a model of |stl-AdaptableBinaryFunction|
   then it must define F2::first_argument_type, F2::second_argument_type, and
   F2::result_type. The STL provides base classes |stl-unary_function| and
   |stl-binary_function| to simplify the definition of
   |stl-AdaptableUnaryFunction| and |stl-AdaptableBinaryFunction|. [3][2]

   Adaptable function objects are important because they can be used by
   function object adaptors: function objects that transform or manipulate
   other function objects. The STL provides many different function object
   adaptors, including |stl-unary_negate| (which returns the logical
   complement of the value returned by a particular
   |stl-AdaptablePredicate|), and |stl-unary_compose| and
   |stl-binary_compose|, which perform composition of function object.

   Finally, the STL includes many different predefined function objects,
   including arithmetic operations (|stl-plus|, |stl-minus|, |stl-multiplies|,
   |stl-divides|, |stl-modulus|, and |stl-negate|), comparisons
   (|stl-equal_to|, |stl-not_equal_to| |stl-greater|, |stl-less|,
   |stl-greater_equal|, and |stl-less_equal|), and logical operations
   (|stl-logical_and|, |stl-logical_or|, and |stl-logical_not|). It is
   possible to perform very sophisticated operations without actually writing
   a new function object, simply by combining predefined function objects and
   function object adaptors.

*stl-functors-example*

   Fill a |stl-Vector| with random numbers. In this example, the function
   object is simply a function pointer.

     |stl-Vector|<int> V(100);
     |stl-generate|(V.begin(), V.end(), rand);

   Sort a |stl-Vector| of double by magnitude, i.e. ignoring the elements'
   signs. In this example, the function object is an object of a user-defined
   class.

     struct less_mag : public |stl-binary_function|<double, double, bool> {
         bool operator()(double x, double y) { return fabs(x) < fabs(y); }
     };

     |stl-Vector|<double> V;
     ...
     |stl-sort|(V.begin(), V.end(), less_mag());

   Find the sum of elements in a |stl-Vector|. In this example, the function
   object is of a user-defined class that has local state.

     struct adder : public |stl-unary_function|<double, void>
     {
       adder() : sum(0) {}
       double sum;
       void operator()(double x) { sum += x; }
     };

     |stl-Vector|<double> V;
     ...
     adder result = |stl-for_each|(V.begin(), V.end(), adder()); [4][3]
     cout << "The sum is " << result.sum << endl;

   Remove all elements from a |stl-List| that are greater than 100 and less
   than 1000.

     |stl-List|<int> L;
     ...
     |stl-List|<int>::iterator new_end =
          |stl-remove_if|(L.begin(), L.end(),
                    |stl-binary_compose|(|stl-logical_and|<bool>(),
                             |stl-binder2nd|(|stl-greater|<int>(), 100),
                             |stl-binder2nd|(|stl-less|<int>(), 1000)));
     L.erase(new_end, L.end());

  Concepts

     * |stl-Generator|
     * |stl-UnaryFunction|
     * |stl-BinaryFunction|

     * |stl-Predicate|
     * |stl-BinaryPredicate|

     * |stl-AdaptableGenerator|
     * |stl-AdaptableUnaryFunction|
     * |stl-AdaptableBinaryFunction|
     * |stl-AdaptablePredicate|
     * |stl-AdaptableBinaryPredicate|

  Types

     * |stl-plus|
     * |stl-minus|
     * |stl-multiplies|
     * |stl-divides|
     * |stl-modulus|
     * |stl-negate|
     * |stl-equal_to|
     * |stl-not_equal_to|
     * |stl-greater|
     * |stl-less|
     * |stl-greater_equal|
     * |stl-less_equal|
     * |stl-logical_and|
     * |stl-logical_or|
     * |stl-logical_not|
     * |stl-subtractive_rng|

     * |stl-identity|
     * |stl-project1st|
     * |stl-project2nd|
     * |stl-select1st|
     * |stl-select2nd|

     * |stl-unary_function|
     * |stl-binary_function|

     * |stl-unary_compose|
     * |stl-binary_compose|
     * |stl-unary_negate|
     * |stl-binary_negate|
     * |stl-binder1st|
     * |stl-binder2nd|
     * |stl-pointer_to_unary_function|
     * |stl-pointer_to_binary_function|

  Functions

     * |stl-unary_compose|
     * |stl-binary_compose|
     * |stl-unary_negate|
     * |stl-binary_negate|
     * |stl-binder1st|
     * |stl-binder2nd|
     * |stl-ptr_fun|

  Notes

   [1] The reason for the name "adaptable function object" is that adaptable
   function objects may be used by function object adaptors.

   [2] The |stl-unary_function| and |stl-binary_function| bases are similar
   to the |stl-input_iterator|, |stl-output_iterator|,
   |stl-forward_iterator|, |stl-bidirectional_iterator|, and
   |stl-random_access_iterator| bases: they are completely empty, and serve
   only to provide type information.

   [3] This is an example of how to use function objects; it is not the
   recommended way of calculating the sum of elements in a vector. The
   |stl-accumulate| algorithm is a better way of calculating a sum.

  See also



    ----------------------------------------------------------------------------
                                     Concepts
    ----------------------------------------------------------------------------
*stl-Generator*

                                   Generator

   Category: functors                                 Component type: concept

  Description

   A Generator is a kind of |stl-functors|: an object that is called as if it
   were an ordinary C++ function. A Generator is called with no arguments.

  Refinement of

   |stl-Assignable|

  Associated types

   +--------------------------------------------------------------+
   | Result type | The type returned when the Generator is called |
   +--------------------------------------------------------------+

  Notation

   F      A type that is a model of Generator
   Result The result type of F
   f      Object of type F

  Definitions

   The range of a Generator is the set of all possible value that it may
   return.

  Valid expressions

   +--------------------------------------------------------------+
   |     Name      | Expression | Type requirements | Return type |
   |---------------+------------+-------------------+-------------|
   | Function call | f()        |                   | Result      |
   +--------------------------------------------------------------+

  Expression semantics

   +------------------------------------------------------------------------+
   |   Name   | Expression | Precondition |   Semantics   |  Postcondition  |
   |----------+------------+--------------+---------------+-----------------|
   | Function | f()        |              | Returns some  | The return      |
   | call     |            |              | value of type | value is in f's |
   |          |            |              | Result [2][1] | range.          |
   +------------------------------------------------------------------------+

  Complexity guarantees

  Invariants

  Models

     * Result (*)()

  Notes

   [1] Two different invocations of f may return different results: a
   Generator may refer to local state, perform I/O, and so on. The expression
   f() is permitted to change f's state; f might, for example, represent a
   pseudo-random number generator.

  See also

   |stl-functors|, |stl-UnaryFunction|, |stl-BinaryFunction|,
   |stl-AdaptableGenerator|

*stl-UnaryFunction*

                                 Unary Function

   Category: functors                                 Component type: concept

  Description

   A Unary Function is a kind of |stl-functors|: an object that is called as
   if it were an ordinary C++ function. A Unary Function is called with a
   single argument.

  Refinement of

   |stl-Assignable|

  Associated types

   +---------------------------------------------------------------------+
   | Argument type | The type of the Unary Function's argument.          |
   |---------------+-----------------------------------------------------|
   | Result type   | The type returned when the Unary Function is called |
   +---------------------------------------------------------------------+

  Notation

   F      A type that is a model of Unary Function
   X      The argument type of F
   Result The result type of F
   f      Object of type F
   x      Object of type X

  Definitions

   The domain of a Unary Function is the set of all permissible values for
   its argument.

   The range of a Unary Function is the set of all possible values that it
   may return.

  Valid expressions

   +--------------------------------------------------------------+
   |     Name      | Expression | Type requirements | Return type |
   |---------------+------------+-------------------+-------------|
   | Function call | f(x)       |                   | Result      |
   +--------------------------------------------------------------+

  Expression semantics

   +------------------------------------------------------------------------+
   |   Name   | Expression | Precondition  |   Semantics   | Postcondition  |
   |----------+------------+---------------+---------------+----------------|
   | Function | f(x)       | x is in f's   | Calls f with  | The return     |
   | call     |            | domain        | x as an       | value is in    |
   |          |            |               | argument, and | f's range      |
   |          |            |               | returns a     |                |
   |          |            |               | value of type |                |
   |          |            |               | Result [2][1] |                |
   +------------------------------------------------------------------------+

  Complexity guarantees

  Invariants

  Models

     * Result (*)(X)

  Notes

   [1] Two different invocations of f may return different results, even if f
   is called with the same arguments both times. A Unary Function may refer
   to local state, perform I/O, and so on. The expression f(x) is permitted
   to change f's state.

  See also

   |stl-functors|, |stl-Generator|, |stl-BinaryFunction|
   |stl-AdaptableUnaryFunction|

*stl-BinaryFunction*

                                Binary Function

   Category: functors                                 Component type: concept

  Description

   A Binary Function is a kind of |stl-functors|: an object that is called as
   if it were an ordinary C++ function. A Binary Function is called with two
   arguments.

  Refinement of

   |stl-Assignable|

  Associated types

   +------------------------------------------------------------------------+
   | First argument type  | The type of the Binary Function's first         |
   |                      | argument.                                       |
   |----------------------+-------------------------------------------------|
   | Second argument type | The type of the Binary Function's second        |
   |                      | argument.                                       |
   |----------------------+-------------------------------------------------|
   | Result type          | The type returned when the Binary Function is   |
   |                      | called                                          |
   +------------------------------------------------------------------------+

  Notation

   F      A type that is a model of BinaryFunction
   X      The first argument type of F
   Y      The second argument type of F
   Result The result type of F
   f      Object of type F
   x      Object of type X
   y      Object of type Y

  Definitions

   The domain of a Binary Function is the set of all ordered pairs (x, y)
   that are permissible values for its arguments.

   The range of a Binary Function is the set of all possible value that it
   may return.

  Valid expressions

   +--------------------------------------------------------------+
   |     Name      | Expression | Type requirements | Return type |
   |---------------+------------+-------------------+-------------|
   | Function call | f(x,y)     |                   | Result      |
   +--------------------------------------------------------------+

  Expression semantics

   +------------------------------------------------------------------------+
   |   Name   | Expression | Precondition  |   Semantics   | Postcondition  |
   |----------+------------+---------------+---------------+----------------|
   | Function | f(x,y)     | The ordered   | Calls f with  | The return     |
   | call     |            | pair (x,y) is | x and y as    | value is in    |
   |          |            | in f's domain | arguments,    | f's range      |
   |          |            |               | and returns a |                |
   |          |            |               | value of type |                |
   |          |            |               | Result [2][1] |                |
   +------------------------------------------------------------------------+

  Complexity guarantees

  Invariants

  Models

     * Result (*)(X,Y)

  Notes

   [1] Two different invocations of f may return different results, even if f
   is called with the same arguments both times. A Binary Function may refer
   to local state, perform I/O, and so on. The expression f(x,y) is permitted
   to change f's state.

  See also

   |stl-functors|, |stl-Generator|, |stl-UnaryFunction|
   |stl-AdaptableBinaryFunction|

*stl-AdaptableGenerator*

                              Adaptable Generator

   Category: functors                                 Component type: concept

  Description

   An Adaptable Generator is a |stl-Generator| with a nested typedef that
   defines its result type. [2][1] This nested typedef makes it possible to
   use function object adaptors.

  Refinement of

   |stl-Generator|

  Associated types

   +------------------------------------------------------------------------+
   | Result type | F::result_type | The type returned when the Generator is |
   |             |                | called                                  |
   +------------------------------------------------------------------------+

  Notation

   F A type that is a model of Adaptable Generator

  Definitions

  Valid expressions

   None, except for those defined by |stl-Generator|

  Expression semantics

  Complexity guarantees

  Invariants

  Models

   The STL does not include any types that are models of Adaptable Generator.
   An example of a user-defined Adaptable Generator is as follows.

 struct counter
 {
   typedef int result_type;

   counter() : n(0) {}
   result_type operator()() { return n++; }

   result_type n;
 };

  Notes

   [1] Note the implication of this: a function pointer T (*f)() is a
   |stl-Generator|, but not an Adaptable Generator: the expression
   f::result_type is nonsensical.

  See also

   |stl-Generator|, |stl-AdaptableUnaryFunction|,
   |stl-AdaptableBinaryFunction|

*stl-AdaptableUnaryFunction*

                            Adaptable Unary Function

   Category: functors                                 Component type: concept

  Description

   An Adaptable Unary Function is a |stl-UnaryFunction| with nested typedefs
   that define its argument type and result type. [2][1] [3][2] These nested
   typedef make it possible to use function object adaptors.

  Refinement of

   |stl-UnaryFunction|

  Associated types

   +------------------------------------------------------------------------+
   | Argument type | F::argument_type | The type of F's argument            |
   |---------------+------------------+-------------------------------------|
   | Result type   | F::result_type   | The type returned when the Unary    |
   |               |                  | Function is called                  |
   +------------------------------------------------------------------------+

  Notation

   F A type that is a model of Unary Function

  Definitions

  Valid expressions

   None, except for those defined by |stl-UnaryFunction|

  Expression semantics

  Complexity guarantees

  Invariants

  Models

     * |stl-negate|
     * |stl-identity|
     * |stl-pointer_to_unary_function|

  Notes

   [1] Note the implication of this: a function pointer T (*f)(X) is a
   |stl-UnaryFunction|, but not an Adaptable Unary Function: the expressions
   f::argument_type and f::result_type are nonsensical.

   [2] When you define a class that is a model of Adaptable Unary Function,
   you must provide these typedefs. The easiest way to do this is to derive
   the class from the base class |stl-unary_function|. This is an empty
   class, with no member functions or member variables; the only reason it
   exists is to make defining Adaptable Unary Functions more convenient.
   |stl-unary_function| is very similar to the base classes used by the
   |stl-iterator_tags| functions.

  See also

   |stl-UnaryFunction|, |stl-AdaptableGenerator|,
   |stl-AdaptableBinaryFunction|

*stl-AdaptableBinaryFunction*

                           Adaptable Binary Function

   Category: functors                                 Component type: concept

  Description

   An Adaptable Binary Function is a |stl-BinaryFunction| with nested
   typedefs that define its argument types and result type. [2][1] [3][2]
   These nested typedefs make it possible to use function object adaptors.

  Refinement of

   |stl-BinaryFunction|

  Associated types

   +------------------------------------------------------------------------+
   | First argument  | F::first_argument_type  | The type of F's first      |
   | type            |                         | argument                   |
   |-----------------+-------------------------+----------------------------|
   | Second argument | F::second_argument_type | The type of F's second     |
   | type            |                         | argument                   |
   |-----------------+-------------------------+----------------------------|
   | Result type     | F::result_type          | The type returned when the |
   |                 |                         | Binary Function is called  |
   +------------------------------------------------------------------------+

  Notation

   F A type that is a model of Binary Function

  Definitions

  Valid expressions

   None, except for those defined by |stl-BinaryFunction|

  Expression semantics

  Complexity guarantees

  Invariants

  Models

     * |stl-plus|
     * |stl-project1st|
     * |stl-pointer_to_binary_function|

  Notes

   [1] Note the implication of this: a function pointer T (*f)(X,Y) is a
   |stl-BinaryFunction|, but not an Adaptable Binary Function: the
   expressions f::first_argument_type, f::second_argument_type, and
   f::result_type are nonsensical.

   [2] When you define a class that is a model of Adaptable Binary Function,
   you must provide these typedefs. The easiest way to do this is to derive
   the class from the base class |stl-binary_function|. This is an empty
   class, with no member functions or member variables; the only reason it
   exists is to make defining Adaptable Binary Functions more convenient.
   |stl-binary_function| is very similar to the base classes used by the
   |stl-iterator_tags| functions.

  See also

   |stl-BinaryFunction|, |stl-AdaptableGenerator|,
   |stl-AdaptableUnaryFunction|

        ________________________________________________________________________
                                      Predicates
*stl-Predicate*

                                   Predicate

   Category: functors                                 Component type: concept

  Description

   A Predicate is a |stl-UnaryFunction| whose result represents the truth or
   falsehood of some condition. A Predicate might, for example, be a function
   that takes an argument of type int and returns true if the argument is
   positive.

  Refinement of

   |stl-UnaryFunction|

  Associated types

   +------------------------------------------------------------------------+
   | Result type | The type returned when the Predicate is called. The      |
   |             | result type must be convertible to bool.                 |
   +------------------------------------------------------------------------+

  Notation

   F A type that is a model of Predicate
   X The argument type of F
   f Object of type F
   x Object of type X

  Valid expressions

   +----------------------------------------------------------------------+
   |     Name      | Expression | Type requirements |     Return type     |
   |---------------+------------+-------------------+---------------------|
   | Function call | f(x)       |                   | Convertible to bool |
   +----------------------------------------------------------------------+

  Expression semantics

   +------------------------------------------------------------------------+
   |   Name   | Expression | Precondition  |   Semantics   | Postcondition  |
   |----------+------------+---------------+---------------+----------------|
   | Function | f(x)       | x is in the   | Returns true  | The result is  |
   | call     |            | domain of f.  | if the        | either true or |
   |          |            |               | condition is  | false.         |
   |          |            |               | satisfied,    |                |
   |          |            |               | false if it   |                |
   |          |            |               | is not.       |                |
   +------------------------------------------------------------------------+

  Complexity guarantees

  Invariants

  Models

     * bool (*)(int)

  See also

   |stl-AdaptablePredicate|, |stl-BinaryPredicate|,
   |stl-AdaptableBinaryPredicate|

*stl-BinaryPredicate*

                                Binary Predicate

   Category: functors                                 Component type: concept

  Description

   A Binary Predicate is a |stl-BinaryFunction| whose result represents the
   truth or falsehood of some condition. A Binary Predicate might, for
   example, be a function that takes two arguments and tests whether they are
   equal.

  Refinement of

   |stl-BinaryFunction|

  Associated types

   +------------------------------------------------------------------------+
   | Result type | The type returned when the Binary Predicate is called.   |
   |             | The result type must be convertible to bool.             |
   +------------------------------------------------------------------------+

  Notation

   F A type that is a model of Binary Predicate
   X The first argument type of F
   Y The second argument type of F
   f Object of type F
   x Object of type X
   y Object of type Y

  Valid expressions

   +----------------------------------------------------------------------+
   |     Name      | Expression | Type requirements |     Return type     |
   |---------------+------------+-------------------+---------------------|
   | Function call | f(x,y)     |                   | Convertible to bool |
   +----------------------------------------------------------------------+

  Expression semantics

   +------------------------------------------------------------------------+
   |   Name   | Expression | Precondition  |   Semantics   | Postcondition  |
   |----------+------------+---------------+---------------+----------------|
   | Function | f(x,y)     | The ordered   | Returns true  | The result is  |
   | call     |            | pair (x,y) is | if the        | either true or |
   |          |            | in the domain | condition is  | false.         |
   |          |            | of f.         | satisfied,    |                |
   |          |            |               | false if it   |                |
   |          |            |               | is not.       |                |
   +------------------------------------------------------------------------+

  Complexity guarantees

  Invariants

  Models

     * bool (*)(int,int)
     * |stl-equal_to|

  See also

   |stl-Predicate|, |stl-AdaptablePredicate|, |stl-AdaptableBinaryPredicate|

*stl-AdaptablePredicate*

                              Adaptable Predicate

   Category: functors                                 Component type: concept

  Description

   An Adaptable Predicate is a |stl-Predicate| that is also an
   |stl-AdaptableUnaryFunction|. That is, it is a |stl-UnaryFunction| whose
   return type is bool, and that includes nested typedefs that define its
   argument type and return type.

  Refinement of

   |stl-Predicate|, |stl-AdaptableUnaryFunction|

  Associated types

   None, except for those associated with |stl-Predicate| and
   |stl-AdaptableUnaryFunction|.

  Notation

  Definitions

  Valid expressions

   None, except for those defined by the |stl-Predicate| and
   |stl-AdaptableUnaryFunction| requirements.

  Expression semantics

  Complexity guarantees

  Invariants

  Models

     * |stl-logical_not|
     * |stl-unary_negate|

  See also

   |stl-Predicate|, |stl-BinaryPredicate|, |stl-AdaptableBinaryPredicate|

*stl-AdaptableBinaryPredicate*

                           Adaptable Binary Predicate

   Category: functors                                 Component type: concept

  Description

   An Adaptable Binary Predicate is a |stl-BinaryPredicate| that is also an
   |stl-AdaptableBinaryFunction|. That is, it is a |stl-BinaryFunction| whose
   return type is bool, and that includes nested typedefs that define its
   argument types and return type.

  Refinement of

   |stl-Predicate|, |stl-AdaptableBinaryFunction|

  Associated types

   None, except for those associated with |stl-Predicate| and
   |stl-AdaptableBinaryFunction|.

  Notation

  Definitions

  Valid expressions

   None, except for those defined by the |stl-Predicate| and
   |stl-AdaptableBinaryFunction| requirements.

  Expression semantics

  Complexity guarantees

  Invariants

  Models

     * |stl-less|
     * |stl-equal_to|
     * |stl-logical_and|
     * |stl-logical_or|
     * |stl-binary_negate|

  See also

   |stl-BinaryPredicate|, |stl-Predicate|, |stl-AdaptablePredicate|

*stl-StrictWeakOrdering*

                              Strict Weak Ordering

   Category: functors                                 Component type: concept

  Description

   A Strict Weak Ordering is a |stl-BinaryPredicate| that compares two
   objects, returning true if the first precedes the second. This predicate
   must satisfy the standard mathematical definition of a strict weak
   ordering. The precise requirements are stated below, but what they roughly
   mean is that a Strict Weak Ordering has to behave the way that "less than"
   behaves: if a is less than b then b is not less than a, if a is less than
   b and b is less than c then a is less than c, and so on.

  Refinement of

   |stl-BinaryPredicate|

  Associated types

   +------------------------------------------------------------------------+
   | First argument type  | The type of the Strict Weak Ordering's first    |
   |                      | argument.                                       |
   |----------------------+-------------------------------------------------|
   | Second argument type | The type of the Strict Weak Ordering's second   |
   |                      | argument. The first argument type and second    |
   |                      | argument type must be the same.                 |
   |----------------------+-------------------------------------------------|
   | Result type          | The type returned when the Strict Weak Ordering |
   |                      | is called. The result type must be convertible  |
   |                      | to bool.                                        |
   +------------------------------------------------------------------------+

  Notation

   F       A type that is a model of Strict Weak Ordering
   X       The type of Strict Weak Ordering's arguments.
   f       Object of type F
   x, y, z Object of type X

  Definitions

     * Two objects x and y are equivalent if both f(x, y) and f(y, x) are
       false. Note that an object is always (by the irreflexivity invariant)
       equivalent to itself.

  Valid expressions

   None, except for those defined in the |stl-BinaryPredicate| requirements.

  Expression semantics

   +------------------------------------------------------------------------+
   |   Name   | Expression | Precondition  |   Semantics   | Postcondition  |
   |----------+------------+---------------+---------------+----------------|
   | Function | f(x, y)    | The ordered   | Returns true  | The result is  |
   | call     |            | pair (x,y) is | if x precedes | either true or |
   |          |            | in the domain | y, and false  | false          |
   |          |            | of f          | otherwise     |                |
   +------------------------------------------------------------------------+

  Complexity guarantees

  Invariants

   +------------------------------------------------------------------------+
   | Irreflexivity   | f(x, x) must be false.                               |
   |-----------------+------------------------------------------------------|
   | Antisymmetry    | f(x, y) implies !f(y, x)                             |
   |-----------------+------------------------------------------------------|
   | Transitivity    | f(x, y) and f(y, z) imply f(x, z).                   |
   |-----------------+------------------------------------------------------|
   | Transitivity of | Equivalence (as defined above) is transitive: if x   |
   | equivalence     | is equivalent to y and y is equivalent to z, then x  |
   |                 | is equivalent to z. (This implies that equivalence   |
   |                 | does in fact satisfy the mathematical definition of  |
   |                 | an equivalence relation.) [2][1]                     |
   +------------------------------------------------------------------------+

  Models

     * |stl-less|<int>
     * |stl-less|<double>
     * |stl-greater|<int>
     * |stl-greater|<double>

  Notes

   [1] The first three axioms, irreflexivity, antisymmetry, and transitivity,
   are the definition of a partial ordering; transitivity of equivalence is
   required by the definition of a strict weak ordering. A total ordering is
   one that satisfies an even stronger condition: equivalence must be the
   same as equality.

  See also

   |stl-LessThanComparable|, |stl-less|, |stl-BinaryPredicate|,
   |stl-functors|


*stl-MonoidOperation*

                                MonoidOperation

   Category: functors                                 Component type: concept

  Description

   A Monoid Operation is a special sort of |stl-BinaryFunction|. A
   |stl-BinaryFunction| must satisfy three conditions in order to be a Monoid
   Operation. First, its first argument type and second argument type must be
   the same, and its result type must be the same as its argument type.
   Second, there must be an identity element. Third, the operation must be
   associative. Examples of Monoid Operations are addition and
   multiplication. [2][1]

  Refinement of

   |stl-BinaryFunction|

  Associated types

   +------------------------------------------------------------------------+
   | Argument type | The type of the Monoid Operation's first argument and  |
   |               | second argument, and also the type returned when the   |
   |               | Monoid Operation is returned.                          |
   +------------------------------------------------------------------------+

  Notation

   F       A type that is a model of MonoidOperation
   T       F's argument type.
   f       Object of type F
   x, y, z Objects of type T

  Definitions

   A type F that is a model of |stl-BinaryFunction| is associative if F's
   first argument type, second argument type, and result type are the same,
   and if, for every object f of type F and for every objects x, y, and z of
   F's argument type, f(x, f(y, z)) is the same as f(f(x, y), z). [3][2]

  Valid Expressions

   In addition to the expressions described in the |stl-BinaryFunction|
   requirements, the following expressions must be valid.

   +------------------------------------------------------------------------+
   |     Name     |        Expression         |      Type       |  Return   |
   |              |                           |  requirements   |   type    |
   |--------------+---------------------------+-----------------+-----------|
   | Function     | f(x, y)                   |                 | T         |
   | call         |                           |                 |           |
   |--------------+---------------------------+-----------------+-----------|
   | Identity     | identity_element(f)       |                 | T         |
   | element      | [4][3]                    |                 |           |
   +------------------------------------------------------------------------+

  Expression semantics

  +----------------------------------------------------------------------------+
  |  Name  |     Expression     | Precondition |   Semantics    |Postcondition |
  |--------+--------------------+--------------+----------------+--------------|
  |Function|f(x, y)             |x and y are in|Calls f with x  |              |
  |call    |                    |the domain of |and y as        |              |
  |        |                    |f.            |arguments.      |              |
  |--------+--------------------+--------------+----------------+--------------|
  |Identity|identity_element(f) |              |Returns the     |              |
  |element |                    |              |monoid's        |              |
  |        |                    |              |identity        |              |
  |        |                    |              |element. That   |              |
  |        |                    |              |is, the return  |              |
  |        |                    |              |value is a value|              |
  |        |                    |              |id of type T    |              |
  |        |                    |              |such that, for  |              |
  |        |                    |              |all x in the    |              |
  |        |                    |              |domain of f,    |              |
  |        |                    |              |f(x, id) and    |              |
  |        |                    |              |f(id, x) both   |              |
  |        |                    |              |return x.       |              |
  +----------------------------------------------------------------------------+

  Complexity guarantees

  Invariants

   +------------------------------------------------------------------------+
   | Associativity     | For any x, y, and z of type T, f(x, f(y, z)) and   |
   |                   | f(f(x, y), z) return the same value. [5][4]        |
   |-------------------+----------------------------------------------------|
   | Identity element. | There exists some element id of type T such that,  |
   |                   | for all x of type T, f(x, id) and f(id, x) both    |
   |                   | return x. The expression identity_element(f)       |
   |                   | returns id.                                        |
   +------------------------------------------------------------------------+

  Models

     * |stl-plus|<int>
     * |stl-multiplies|<double>

  Notes

   [1] A monoid is one of three closely related algebraic structures. A
   semigroup is a set S, and a binary operation *, with the properties that *
   is closed on S (that is, if x and y are elements of S then x * y is also a
   member of S) and that * is associative (that is, if x, y, and z are
   elements of S, then x * (y * z) = (x * y) * z). A monoid is a semigroup
   that has an identity element. That is, there exists some element id such
   that, for all x in S, x * id = id * x = x. Finally, a group is a monoid
   with the property that every element has an inverse. That is, for every x
   in S, there exists an element xi such that x * xi = xi * x = id. As an
   example, the set of real numbers under multiplication is a monoid (the
   identity element is 1), but it isn't a group. It isn't a group because 0
   has no inverse.

   [2] Mathematics textbooks typically write this as an equation, instead of
   using words like "is the same as". We can't use equality in this
   definition, however, because F's argument type might not be
   |stl-EqualityComparable|. If F's argument type is
   |stl-EqualityComparable|, however, then these two expression are expected
   to be equal: the condition of associativity becomes f(x, f(y, z)) ==
   f(f(x, y), z)

   [3] This is implemented as an overloaded function. The function
   identity_element is defined, in the standard header |stl-functional|, and the
   nonstandard backward-compatibility header [7]function.h, for arguments of
   type |stl-plus|<T> and |stl-multiplies|<T>. If you define a new Monoid
   Operation F (matrix multiplication, for example), you must overload
   identity_element for arguments of type F. The identity_element function is
   an SGI extension; it is not part of the C++ standard.

   [4] Associativity is not the same as commutativity. That is, the
   requirement that x * (y * z) == (x * y) * z is completely unrelated to the
   requirement that x * y == y * x. Monoid operations are required to be
   associative, but they are not required to be commutative. As an example,
   square matrices under multiplication form a monoid even though matrix
   multiplication is not commutative.

  See also

   |stl-BinaryFunction|, |stl-plus|, |stl-multiplies|

*stl-RandomNumberGenerator*

                            Random Number Generator

   Category: functors                                 Component type: concept

  Description

   A Random Number Generator is a |stl-functors| that can be used to generate
   a random sequence of integers. That is: if f is a Random Number Generator
   and N is a positive integer, then f(N) will return an integer less than N
   and greater than or equal to 0. If f is called many times with the same
   value of N, it will yield a sequence of numbers that is uniformly
   distributed [2][1] in the range [0, N). [3][2]

  Refinement of

   |stl-UnaryFunction|

  Associated types

   +------------------------------------------------------------------------+
   | Argument type | The type of the Random Number Generator's argument.    |
   |               | This must be an integral type.                         |
   |---------------+--------------------------------------------------------|
   | Result type   | The type returned when the Random Number Generator is  |
   |               | called. It must be the same as the argument type.      |
   +------------------------------------------------------------------------+

  Notation

   F       A type that is a model of Random Number Generator.
   Integer The argument type of F.
   f       Object of type F.
   N       Object of type Integer

  Definitions

   The domain of a Random Number Generator (i.e. the set of permissible
   values for its argument) is the set of numbers that are greater than zero
   and less than some maximum value.

   The range of a Random Number Generator is the set of nonnegative integers
   that are less than the Random Number Generator's argument.

  Valid expressions

   None, except for those defined by |stl-UnaryFunction|.

  Expression semantics

   +------------------------------------------------------------------------+
   |   Name   | Expression | Precondition  |   Semantics   | Postcondition  |
   |----------+------------+---------------+---------------+----------------|
   | Function | f(N)       | N is          | Returns a     | The return     |
   | call     |            | positive.     | pseudo-random | value is less  |
   |          |            |               | number of     | than N, and    |
   |          |            |               | type Integer. | greater than   |
   |          |            |               | [4][2]        | or equal to 0. |
   +------------------------------------------------------------------------+

  Complexity guarantees

  Invariants

   +------------------------------------------------------------------------+
   | Uniformity | In the limit as f is called many times with the same      |
   |            | argument N, every integer in the range [0, N) will appear |
   |            | an equal number of times.                                 |
   +------------------------------------------------------------------------+

  Models

  Notes

   [1] Uniform distribution means that all of the numbers in the range [0, N)
   appear with equal frequency. Or, to put it differently, the probability
   for obtaining any particular value is 1/N.

   [2] Random number generators are a very subtle subject: a good random
   number generator must satisfy many statistical properties beyond uniform
   distribution. See section 3.4 of Knuth for a discussion of what it means
   for a sequence to be random, and section 3.2 for several algorithms that
   may be used to write random number generators. (D. E. Knuth, The Art of
   Computer Programming. Volume 2: Seminumerical Algorithms, third edition.
   Addison-Wesley, 1998.)

  See also



    ----------------------------------------------------------------------------
                           Predefined function objects
    ----------------------------------------------------------------------------
        ________________________________________________________________________
                                Arithmetic operations
*stl-plus*

                                    plus<T>

   Category: functors                                    Component type: type

  Description

   Plus<T> is a |stl-functors|. Specifically, it is an
   |stl-AdaptableBinaryFunction|. If f is an object of class plus<T> and x
   and y are objects of class T, then f(x,y) returns x+y.

*stl-plus-example*

   Each element in V3 will be the sum of the corresponding elements in V1 and
   V2

 const int N = 1000;
 |stl-Vector|<double> V1(N);
 |stl-Vector|<double> V2(N);
 |stl-Vector|<double> V3(N);

 |stl-iota|(V1.begin(), V1.end(), 1);
 |stl-fill|(V2.begin(), V2.end(), 75);

 assert(V2.size() >= V1.size() && V3.size() >= V1.size());
 |stl-transform|(V1.begin(), V1.end(), V2.begin(), V3.begin(),
           plus<double>());

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | T         | The function object's argument type and result   |         |
   |           | type.                                            |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-AdaptableBinaryFunction|, |stl-DefaultConstructible|

  Type requirements

   T must be a numeric type; if x and y are objects of type T, then x+y must
   be defined and must have a return type that is convertible to T. T must be
   |stl-Assignable|.

  Public base classes

   |stl-binary_function|<T, T, T>

  Members

   +------------------------------------------------------------------------+
   |        Member         |         Where defined         |  Description   |
   |-----------------------+-------------------------------+----------------|
   | first_argument_type   | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the first      |
   |                       |                               | argument: T    |
   |-----------------------+-------------------------------+----------------|
   | second_argument_type  | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the second     |
   |                       |                               | argument: T    |
   |-----------------------+-------------------------------+----------------|
   | result_type           | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the result: T  |
   |-----------------------+-------------------------------+----------------|
   | T operator()(const T& | |stl-AdaptableBinaryFunction| | Function call  |
   | x, const T& y)        |                               | operator. The  |
   |                       |                               | return value   |
   |                       |                               | is x + y.      |
   |-----------------------+-------------------------------+----------------|
   | plus()                | |stl-DefaultConstructible|    | The default    |
   |                       |                               | constructor.   |
   +------------------------------------------------------------------------+

  New members

   All of plus's members are defined in the |stl-AdaptableBinaryFunction| and
   |stl-DefaultConstructible| requirements. Plus does not introduce any new
   members.

  See also

   The |stl-functors| overview, |stl-AdaptableBinaryFunction|,
   |stl-binary_function|, |stl-minus|, |stl-multiplies|, |stl-divides|,
   |stl-modulus|, |stl-negate|

*stl-minus*

                                    minus<T>

   Category: functors                                    Component type: type

  Description

   Minus<T> is a |stl-functors|. Specifically, it is an
   |stl-AdaptableBinaryFunction|. If f is an object of class minus<T> and x
   and y are objects of class T, then f(x,y) returns x-y.

*stl-minus-example*

   Each element in V3 will be the difference of the corresponding elements in
   V1 and V2

 const int N = 1000;
 |stl-Vector|<double> V1(N);
 |stl-Vector|<double> V2(N);
 |stl-Vector|<double> V3(N);

 |stl-iota|(V1.begin(), V1.end(), 1);
 |stl-fill|(V2.begin(), V2.end(), 75);

 assert(V2.size() >= V1.size() && V3.size() >= V1.size());
 |stl-transform|(V1.begin(), V1.end(), V2.begin(), V3.begin(),
           minus<double>());

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | T         | The function object's argument type and result   |         |
   |           | type.                                            |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-AdaptableBinaryFunction|, |stl-DefaultConstructible|

  Type requirements

   T must be a numeric type; if x and y are objects of type T, then x-y must
   be defined and must have a return type that is convertible to T. T must be
   |stl-Assignable|.

  Public base classes

   |stl-binary_function|<T, T, T>

  Members

   +------------------------------------------------------------------------+
   |        Member         |         Where defined         |  Description   |
   |-----------------------+-------------------------------+----------------|
   | first_argument_type   | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the first      |
   |                       |                               | argument: T    |
   |-----------------------+-------------------------------+----------------|
   | second_argument_type  | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the second     |
   |                       |                               | argument: T    |
   |-----------------------+-------------------------------+----------------|
   | result_type           | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the result: T  |
   |-----------------------+-------------------------------+----------------|
   | T operator()(const T& | |stl-AdaptableBinaryFunction| | Function call  |
   | x, const T& y)        |                               | operator. The  |
   |                       |                               | return value   |
   |                       |                               | is x - y.      |
   |-----------------------+-------------------------------+----------------|
   | minus()               | |stl-DefaultConstructible|    | The default    |
   |                       |                               | constructor.   |
   +------------------------------------------------------------------------+

  New members

   All of minus's members are defined in the |stl-AdaptableBinaryFunction|
   and |stl-DefaultConstructible| requirements. Minus does not introduce any
   new members.

  See also

   The |stl-functors| overview, |stl-AdaptableBinaryFunction|,
   |stl-binary_function|, |stl-plus|, |stl-multiplies|, |stl-divides|,
   |stl-modulus|, |stl-negate|

*stl-multiplies*

                                 multiplies<T>

   Category: functors                                    Component type: type

  Description

   Multiplies<T> [2][1] is a |stl-functors|. Specifically, it is an
   |stl-AdaptableBinaryFunction|. If f is an object of class multiplies<T>
   and x and y are objects of class T, then f(x,y) returns x*y.

*stl-multiplies-example*

   Each element in V3 will be the product of the corresponding elements in V1
   and V2

 const int N = 1000;
 |stl-Vector|<double> V1(N);
 |stl-Vector|<double> V2(N);
 |stl-Vector|<double> V3(N);

 |stl-iota|(V1.begin(), V1.end(), 1);
 |stl-fill|(V2.begin(), V2.end(), 75);

 assert(V2.size() >= V1.size() && V3.size() >= V1.size());
 |stl-transform|(V1.begin(), V1.end(), V2.begin(), V3.begin(),
           multiplies<double>());

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [4]function.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | T         | The function object's argument type and result   |         |
   |           | type.                                            |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-AdaptableBinaryFunction|, |stl-DefaultConstructible|

  Type requirements

   T must be a numeric type; if x and y are objects of type T, then x*y must
   be defined and must have a return type that is convertible to T. T must be
   |stl-Assignable|.

  Public base classes

   |stl-binary_function|<T, T, T>

  Members

   +------------------------------------------------------------------------+
   |        Member         |         Where defined         |  Description   |
   |-----------------------+-------------------------------+----------------|
   | first_argument_type   | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the first      |
   |                       |                               | argument: T    |
   |-----------------------+-------------------------------+----------------|
   | second_argument_type  | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the second     |
   |                       |                               | argument: T    |
   |-----------------------+-------------------------------+----------------|
   | result_type           | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the result: T  |
   |-----------------------+-------------------------------+----------------|
   | T operator()(const T& | |stl-AdaptableBinaryFunction| | Function call  |
   | x, const T& y)        |                               | operator. The  |
   |                       |                               | return value   |
   |                       |                               | is x * y.      |
   |-----------------------+-------------------------------+----------------|
   | multiplies() [5][1]   | |stl-DefaultConstructible|    | The default    |
   |                       |                               | constructor.   |
   +------------------------------------------------------------------------+

  New members

   All of multiplies's members are defined in the
   |stl-AdaptableBinaryFunction| and |stl-DefaultConstructible| requirements.
   Multiplies does not introduce any new members.

  Notes

   [1] Warning: the name of this function object has been changed from times
   to multiplies. The name was changed for two reasons. First, it is called
   multiplies in the C++ standard. Second, the name times conflicts with a
   function in the Unix header <sys/times.h>.

  See also

   The |stl-functors| overview, |stl-AdaptableBinaryFunction|,
   |stl-binary_function|, |stl-plus|, |stl-minus|, |stl-divides|,
   |stl-modulus|, |stl-negate|

*stl-divides*

                                   divides<T>

   Category: functors                                    Component type: type

  Description

   Divides<T> is a |stl-functors|. Specifically, it is an
   |stl-AdaptableBinaryFunction|. If f is an object of class divides<T> and x
   and y are objects of class T, then f(x,y) returns x/y.

*stl-divides-example*

   Each element in V3 will be the quotient of the corresponding elements in
   V1 and V2

 const int N = 1000;
 |stl-Vector|<double> V1(N);
 |stl-Vector|<double> V2(N);
 |stl-Vector|<double> V3(N);

 |stl-iota|(V1.begin(), V1.end(), 1);
 |stl-fill|(V2.begin(), V2.end(), 75);

 assert(V2.size() >= V1.size() && V3.size() >= V1.size());
 |stl-transform|(V1.begin(), V1.end(), V2.begin(), V3.begin(),
           divides<double>());

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | T         | The function object's argument type and result   |         |
   |           | type.                                            |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-AdaptableBinaryFunction|, |stl-DefaultConstructible|

  Type requirements

   T must be a numeric type; if x and y are objects of type T, then x/y must
   be defined and must have a return type that is convertible to T. T must be
   |stl-Assignable|.

  Public base classes

   |stl-binary_function|<T, T, T>

  Members

   +------------------------------------------------------------------------+
   |        Member         |         Where defined         |  Description   |
   |-----------------------+-------------------------------+----------------|
   | first_argument_type   | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the first      |
   |                       |                               | argument: T    |
   |-----------------------+-------------------------------+----------------|
   | second_argument_type  | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the second     |
   |                       |                               | argument: T    |
   |-----------------------+-------------------------------+----------------|
   | result_type           | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the result: T  |
   |-----------------------+-------------------------------+----------------|
   | T operator()(const T& | |stl-AdaptableBinaryFunction| | Function call  |
   | x, const T& y)        |                               | operator. The  |
   |                       |                               | return value   |
   |                       |                               | is x / y.      |
   |-----------------------+-------------------------------+----------------|
   | divides()             | |stl-DefaultConstructible|    | The default    |
   |                       |                               | constructor.   |
   +------------------------------------------------------------------------+

  New members

   All of divides's members are defined in the |stl-AdaptableBinaryFunction|
   and |stl-DefaultConstructible| requirements. Divides does not introduce
   any new members.

  See also

   The |stl-functors| overview, |stl-AdaptableBinaryFunction|,
   |stl-binary_function|, |stl-plus|, |stl-minus|, |stl-multiplies|,
   |stl-modulus|, |stl-negate|

*stl-modulus*

                                   modulus<T>

   Category: functors                                    Component type: type

  Description

   Modulus<T> is a |stl-functors|. Specifically, it is an
   |stl-AdaptableBinaryFunction|. If f is an object of class modulus<T> and x
   and y are objects of class T, then f(x,y) returns x%y.

*stl-modulus-example*

   Each element in V3 will be the modulus of the corresponding elements in V1
   and V2

 const int N = 1000;
 |stl-Vector|<double> V1(N);
 |stl-Vector|<double> V2(N);
 |stl-Vector|<double> V3(N);

 |stl-iota|(V1.begin(), V1.end(), 1);
 |stl-fill|(V2.begin(), V2.end(), 75);

 assert(V2.size() >= V1.size() && V3.size() >= V1.size());
 |stl-transform|(V1.begin(), V1.end(), V2.begin(), V3.begin(),
           modulus<int>());

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | T         | The function object's argument type and result   |         |
   |           | type.                                            |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-AdaptableBinaryFunction|, |stl-DefaultConstructible|

  Type requirements

   T must be an integral type; if x and y are objects of type T, then x%y
   must be defined and must have a return type that is convertible to T. T
   must be |stl-Assignable|.

  Public base classes

   |stl-binary_function|<T, T, T>

  Members

   +------------------------------------------------------------------------+
   |        Member         |         Where defined         |  Description   |
   |-----------------------+-------------------------------+----------------|
   | first_argument_type   | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the first      |
   |                       |                               | argument: T    |
   |-----------------------+-------------------------------+----------------|
   | second_argument_type  | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the second     |
   |                       |                               | argument: T    |
   |-----------------------+-------------------------------+----------------|
   | result_type           | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the result: T  |
   |-----------------------+-------------------------------+----------------|
   | T operator()(const T& | |stl-AdaptableBinaryFunction| | Function call  |
   | x, const T& y)        |                               | operator. The  |
   |                       |                               | return value   |
   |                       |                               | is x % y.      |
   |-----------------------+-------------------------------+----------------|
   | modulus()             | |stl-DefaultConstructible|    | The default    |
   |                       |                               | constructor.   |
   +------------------------------------------------------------------------+

  New members

   All of modulus's members are defined in the |stl-AdaptableBinaryFunction|
   and |stl-DefaultConstructible| requirements. Modulus does not introduce
   any new members.

  See also

   The |stl-functors| overview, |stl-AdaptableBinaryFunction|,
   |stl-binary_function|, |stl-plus|, |stl-minus|, |stl-multiplies|,
   |stl-divides|, |stl-negate|

*stl-negate*

                                   negate<T>

   Category: functors                                    Component type: type

  Description

   Negate<T> is a |stl-functors|. Specifically, it is an
   |stl-AdaptableUnaryFunction|. If f is an object of class negate<T> and x
   is an object of class T, then f(x) returns -x.

*stl-negate-example*

   Each element in V2 will be the negative (additive inverse) of the
   corresponding element in V1.

 const int N = 1000;
 |stl-Vector|<double> V1(N);
 |stl-Vector|<double> V2(N);

 |stl-iota|(V1.begin(), V1.end(), 1);

 assert(V2.size() >= V1.size());
 |stl-transform|(V1.begin(), V1.end(), V2.begin(),
           negate<int>());

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | T         | The function object's argument type and result   |         |
   |           | type.                                            |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-AdaptableUnaryFunction|, |stl-DefaultConstructible|

  Type requirements

   T must be a numeric type; if x is an object of type T, then -x must be
   defined and must have a return type that is convertible to T. T must be
   |stl-Assignable|.

  Public base classes

   |stl-unary_function|<T, T>

  Members

   +------------------------------------------------------------------------+
   |       Member       |        Where defined         |    Description     |
   |--------------------+------------------------------+--------------------|
   | argument_type      | |stl-AdaptableUnaryFunction| | The type of the    |
   |                    |                              | second argument: T |
   |--------------------+------------------------------+--------------------|
   | result_type        | |stl-AdaptableUnaryFunction| | The type of the    |
   |                    |                              | result: T          |
   |--------------------+------------------------------+--------------------|
   | T operator()(const | |stl-AdaptableUnaryFunction| | Function call      |
   | T& x)              |                              | operator. The      |
   |                    |                              | return value is    |
   |                    |                              | -x.                |
   |--------------------+------------------------------+--------------------|
   | negate()           | |stl-DefaultConstructible|   | The default        |
   |                    |                              | constructor.       |
   +------------------------------------------------------------------------+

  New members

   All of negate's members are defined in the |stl-AdaptableUnaryFunction|
   and |stl-DefaultConstructible| requirements. Negate does not introduce any
   new members.

  See also

   The |stl-functors| overview, |stl-AdaptableUnaryFunction|,
   |stl-unary_function|, |stl-plus|, |stl-minus|, |stl-multiplies|, |stl-divides|,
   |stl-modulus|


        ________________________________________________________________________
                                     Comparisons
*stl-equal_to*

                                  equal_to<T>

   Category: functors                                    Component type: type

  Description

   Equal_to<T> is a |stl-functors|. Specifically, it is an
   |stl-AdaptableBinaryPredicate|, which means it is a function object that
   tests the truth or falsehood of some condition. If f is an object of class
   equal_to<T> and x and y are objects of class T, then f(x,y) returns true
   if x == y and false otherwise.

*stl-equal_to-example*

   Rearrange a vector such that all of the elements that are equal to zero
   precede all nonzero elements.

 |stl-Vector|<int> V;
 ...
 |stl-partition|(V.begin(), V.end(), |stl-binder2nd|(equal_to<int>(), 0));

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h.

  Template parameters

   +---------------------------------------------------------+
   | Parameter |            Description            | Default |
   |-----------+-----------------------------------+---------|
   | T         | The type of equal_to's arguments. |         |
   +---------------------------------------------------------+

  Model of

   |stl-AdaptableBinaryPredicate|, |stl-DefaultConstructible|

  Type requirements

   T is |stl-EqualityComparable|.

  Public base classes

   |stl-binary_function|<T, T, bool>.

  Members

   +------------------------------------------------------------------------+
   |        Member         |         Where defined          |  Description  |
   |-----------------------+--------------------------------+---------------|
   | first_argument_type   | |stl-AdaptableBinaryPredicate| | The type of   |
   |                       |                                | the first     |
   |                       |                                | argument: T   |
   |-----------------------+--------------------------------+---------------|
   | second_argument_type  | |stl-AdaptableBinaryPredicate| | The type of   |
   |                       |                                | the second    |
   |                       |                                | argument: T   |
   |-----------------------+--------------------------------+---------------|
   | result_type           | |stl-AdaptableBinaryPredicate| | The type of   |
   |                       |                                | the result:   |
   |                       |                                | bool          |
   |-----------------------+--------------------------------+---------------|
   | equal_to()            | |stl-DefaultConstructible|     | The default   |
   |                       |                                | constructor.  |
   |-----------------------+--------------------------------+---------------|
   | bool operator()(const | |stl-BinaryFunction|           | Function call |
   | T& x, const T& y)     |                                | operator. The |
   |                       |                                | return value  |
   |                       |                                | is x == y.    |
   +------------------------------------------------------------------------+

  New members

   All of equal_to's members are defined in the
   |stl-AdaptableBinaryPredicate| and |stl-DefaultConstructible|
   requirements. Equal_to does not introduce any new members.

  See also

   The |stl-functors|, |stl-AdaptableBinaryPredicate|, |stl-not_equal_to|,
   |stl-greater|, |stl-less|, |stl-greater_equal|, |stl-less_equal|

*stl-not_equal_to*

                                not_equal_to<T>

   Category: functors                                    Component type: type

  Description

   Not_equal_to<T> is a |stl-functors|. Specifically, it is an
   |stl-AdaptableBinaryPredicate|, which means it is a function object that
   tests the truth or falsehood of some condition. If f is an object of class
   not_equal_to<T> and x and y are objects of class T, then f(x,y) returns
   true if x != y and false otherwise.

*stl-not_equal_to-example*

   Finds the first nonzero element in a list.

 |stl-List|<int> L;
 ...
 |stl-List|<int>::iterator first_nonzero =
        |stl-find_if|(L.begin(), L.end(), |stl-binder2nd|(not_equal_to<int>(), 0));
 assert(first_nonzero == L.end() || *first_nonzero != 0);

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h.

  Template parameters

   +-------------------------------------------------------------+
   | Parameter |              Description              | Default |
   |-----------+---------------------------------------+---------|
   | T         | The type of not_equal_to's arguments. |         |
   +-------------------------------------------------------------+

  Model of

   |stl-AdaptableBinaryPredicate|, |stl-DefaultConstructible|

  Type requirements

   T is |stl-EqualityComparable|.

  Public base classes

   |stl-binary_function|<T, T, bool>.

  Members

   +------------------------------------------------------------------------+
   |        Member         |         Where defined          |  Description  |
   |-----------------------+--------------------------------+---------------|
   | first_argument_type   | |stl-AdaptableBinaryPredicate| | The type of   |
   |                       |                                | the first     |
   |                       |                                | argument: T   |
   |-----------------------+--------------------------------+---------------|
   | second_argument_type  | |stl-AdaptableBinaryPredicate| | The type of   |
   |                       |                                | the second    |
   |                       |                                | argument: T   |
   |-----------------------+--------------------------------+---------------|
   | result_type           | |stl-AdaptableBinaryPredicate| | The type of   |
   |                       |                                | the result:   |
   |                       |                                | bool          |
   |-----------------------+--------------------------------+---------------|
   | not_equal_to()        | |stl-DefaultConstructible|     | The default   |
   |                       |                                | constructor.  |
   |-----------------------+--------------------------------+---------------|
   | bool operator()(const | |stl-BinaryFunction|           | Function call |
   | T& x, const T& y)     |                                | operator. The |
   |                       |                                | return value  |
   |                       |                                | is x != y.    |
   +------------------------------------------------------------------------+

  New members

   All of not_equal_to's members are defined in the
   |stl-AdaptableBinaryPredicate| and |stl-DefaultConstructible|
   requirements. Not_equal_to does not introduce any new members.

  See also

   The |stl-functors|, |stl-AdaptableBinaryPredicate|, |stl-equal_to|,
   |stl-greater|, |stl-less|, |stl-greater_equal|, |stl-less_equal|

*stl-less*

                                    less<T>

   Category: functors                                    Component type: type

  Description

   Less<T> is a |stl-functors|. Specifically, it is an
   |stl-AdaptableBinaryPredicate|, which means it is a function object that
   tests the truth or falsehood of some condition. If f is an object of class
   less<T> and x and y are objects of class T, then f(x,y) returns true if x
   < y and false otherwise.

*stl-less-example*

   Finds the first negative element in a list.

 |stl-List|<int> L;
 ...
 |stl-List|<int>::iterator first_negative =
        |stl-find_if|(L.begin(), L.end(), |stl-binder2nd|(less<int>(), 0));
 assert(first_negative == L.end() || *first_negative < 0);

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h.

  Template parameters

   +-----------------------------------------------------+
   | Parameter |          Description          | Default |
   |-----------+-------------------------------+---------|
   | T         | The type of less's arguments. |         |
   +-----------------------------------------------------+

  Model of

   |stl-AdaptableBinaryPredicate|, |stl-DefaultConstructible|

  Type requirements

   T is |stl-LessThanComparable|.

  Public base classes

   |stl-binary_function|<T, T, bool>.

  Members

   +------------------------------------------------------------------------+
   |        Member         |         Where defined          |  Description  |
   |-----------------------+--------------------------------+---------------|
   | first_argument_type   | |stl-AdaptableBinaryPredicate| | The type of   |
   |                       |                                | the first     |
   |                       |                                | argument: T   |
   |-----------------------+--------------------------------+---------------|
   | second_argument_type  | |stl-AdaptableBinaryPredicate| | The type of   |
   |                       |                                | the second    |
   |                       |                                | argument: T   |
   |-----------------------+--------------------------------+---------------|
   | result_type           | |stl-AdaptableBinaryPredicate| | The type of   |
   |                       |                                | the result:   |
   |                       |                                | bool          |
   |-----------------------+--------------------------------+---------------|
   | less()                | |stl-DefaultConstructible|     | The default   |
   |                       |                                | constructor.  |
   |-----------------------+--------------------------------+---------------|
   | bool operator()(const | |stl-BinaryFunction|           | Function call |
   | T& x, const T& y)     |                                | operator. The |
   |                       |                                | return value  |
   |                       |                                | is x < y.     |
   +------------------------------------------------------------------------+

  New members

   All of less's members are defined in the |stl-AdaptableBinaryPredicate|
   and |stl-DefaultConstructible| requirements. less does not introduce any
   new members.

  See also

   The |stl-functors|, |stl-StrictWeakOrdering|,
   |stl-AdaptableBinaryPredicate|, |stl-LessThanComparable|, |stl-equal_to|,
   |stl-not_equal_to|, |stl-greater|, |stl-greater_equal|, |stl-less_equal|

*stl-greater*

                                   greater<T>

   Category: functors                                    Component type: type

  Description

   Greater<T> is a |stl-functors|. Specifically, it is an
   |stl-AdaptableBinaryPredicate|, which means it is a function object that
   tests the truth or falsehood of some condition. If f is an object of class
   greater<T> and x and y are objects of class T, then f(x,y) returns true if
   x > y and false otherwise.

*stl-greater-example*

   Sort a vector in descending order, rather than the default ascending
   order.

 |stl-Vector|<int> V;
 ...
 |stl-sort|(V.begin(), V.end(), greater<int>());

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h.

  Template parameters

   +--------------------------------------------------------+
   | Parameter |           Description            | Default |
   |-----------+----------------------------------+---------|
   | T         | The type of greater's arguments. |         |
   +--------------------------------------------------------+

  Model of

   |stl-AdaptableBinaryPredicate|, |stl-DefaultConstructible|

  Type requirements

   T is |stl-LessThanComparable|.

  Public base classes

   |stl-binary_function|<T, T, bool>.

  Members

   +------------------------------------------------------------------------+
   |        Member         |         Where defined          |  Description  |
   |-----------------------+--------------------------------+---------------|
   | first_argument_type   | |stl-AdaptableBinaryPredicate| | The type of   |
   |                       |                                | the first     |
   |                       |                                | argument: T   |
   |-----------------------+--------------------------------+---------------|
   | second_argument_type  | |stl-AdaptableBinaryPredicate| | The type of   |
   |                       |                                | the second    |
   |                       |                                | argument: T   |
   |-----------------------+--------------------------------+---------------|
   | result_type           | |stl-AdaptableBinaryPredicate| | The type of   |
   |                       |                                | the result:   |
   |                       |                                | bool          |
   |-----------------------+--------------------------------+---------------|
   | greater()             | |stl-DefaultConstructible|     | The default   |
   |                       |                                | constructor.  |
   |-----------------------+--------------------------------+---------------|
   | bool operator()(const | |stl-BinaryFunction|           | Function call |
   | T& x, const T& y)     |                                | operator. The |
   |                       |                                | return value  |
   |                       |                                | is x > y.     |
   +------------------------------------------------------------------------+

  New members

   All of greater's members are defined in the |stl-AdaptableBinaryPredicate|
   and |stl-DefaultConstructible| requirements. Greater does not introduce
   any new members.

  See also

   The |stl-functors|, |stl-AdaptableBinaryPredicate|,
   |stl-LessThanComparable|, |stl-equal_to|, |stl-not_equal_to|, |stl-less|,
   |stl-greater_equal|, |stl-less_equal|

*stl-less_equal*

                                 less_equal<T>

   Category: functors                                    Component type: type

  Description

   Less_equal<T> is a |stl-functors|. Specifically, it is an
   |stl-AdaptableBinaryPredicate|, which means it is a function object that
   tests the truth or falsehood of some condition. If f is an object of class
   less_equal<T> and x and y are objects of class T, then f(x,y) returns true
   if x <= y and false otherwise.

*stl-less_equal-example*

   Finds the first non-positive element in a list.

 |stl-List|<int> L;
 ...
 |stl-List|<int>::iterator first_nonpositive =
        |stl-find_if|(L.begin(), L.end(), |stl-binder2nd|(less_equal<int>(), 0));
 assert(first_nonpositive == L.end() || *first_nonpositive <= 0);

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h.

  Template parameters

   +-----------------------------------------------------------+
   | Parameter |             Description             | Default |
   |-----------+-------------------------------------+---------|
   | T         | The type of less_equal's arguments. |         |
   +-----------------------------------------------------------+

  Model of

   |stl-AdaptableBinaryPredicate|, |stl-DefaultConstructible|

  Type requirements

   T is |stl-LessThanComparable|.

  Public base classes

   |stl-binary_function|<T, T, bool>.

  Members

   +------------------------------------------------------------------------+
   |        Member         |         Where defined          |  Description  |
   |-----------------------+--------------------------------+---------------|
   | first_argument_type   | |stl-AdaptableBinaryPredicate| | The type of   |
   |                       |                                | the first     |
   |                       |                                | argument: T   |
   |-----------------------+--------------------------------+---------------|
   | second_argument_type  | |stl-AdaptableBinaryPredicate| | The type of   |
   |                       |                                | the second    |
   |                       |                                | argument: T   |
   |-----------------------+--------------------------------+---------------|
   | result_type           | |stl-AdaptableBinaryPredicate| | The type of   |
   |                       |                                | the result:   |
   |                       |                                | bool          |
   |-----------------------+--------------------------------+---------------|
   | less_equal()          | |stl-DefaultConstructible|     | The default   |
   |                       |                                | constructor.  |
   |-----------------------+--------------------------------+---------------|
   | bool operator()(const | |stl-BinaryFunction|           | Function call |
   | T& x, const T& y)     |                                | operator. The |
   |                       |                                | return value  |
   |                       |                                | is x <= y.    |
   +------------------------------------------------------------------------+

  New members

   All of less_equal's members are defined in the
   |stl-AdaptableBinaryPredicate| and |stl-DefaultConstructible|
   requirements. Less_equal does not introduce any new members.

  See also

   The |stl-functors|, |stl-AdaptableBinaryPredicate|, |stl-equal_to|,
   |stl-not_equal_to|, |stl-greater|, |stl-less|, |stl-greater_equal|,

*stl-greater_equal*

                                greater_equal<T>

   Category: functors                                    Component type: type

  Description

   Greater_equal<T> is a |stl-functors|. Specifically, it is an
   |stl-AdaptableBinaryPredicate|, which means it is a function object that
   tests the truth or falsehood of some condition. If f is an object of class
   greater_equal<T> and x and y are objects of class T, then f(x,y) returns
   true if x >= y and false otherwise.

*stl-greater_equal-example*

   Find the first nonnegative element in a list.

 |stl-List|<int> L;
 ...
 |stl-List|<int>::iterator first_nonnegative =
     |stl-find_if|(L.begin(), L.end(), |stl-binder2nd|(greater_equal<int>(), 0));
 assert(first_nonnegative == L.end() || *first_nonnegative >= 0);

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h.

  Template parameters

   +--------------------------------------------------------------+
   | Parameter |              Description               | Default |
   |-----------+----------------------------------------+---------|
   | T         | The type of greater_equal's arguments. |         |
   +--------------------------------------------------------------+

  Model of

   |stl-AdaptableBinaryPredicate|, |stl-DefaultConstructible|

  Type requirements

   T is |stl-LessThanComparable|.

  Public base classes

   |stl-binary_function|<T, T, bool>.

  Members

   +------------------------------------------------------------------------+
   |        Member         |         Where defined          |  Description  |
   |-----------------------+--------------------------------+---------------|
   | first_argument_type   | |stl-AdaptableBinaryPredicate| | The type of   |
   |                       |                                | the first     |
   |                       |                                | argument: T   |
   |-----------------------+--------------------------------+---------------|
   | second_argument_type  | |stl-AdaptableBinaryPredicate| | The type of   |
   |                       |                                | the second    |
   |                       |                                | argument: T   |
   |-----------------------+--------------------------------+---------------|
   | result_type           | |stl-AdaptableBinaryPredicate| | The type of   |
   |                       |                                | the result:   |
   |                       |                                | bool          |
   |-----------------------+--------------------------------+---------------|
   | greater_equal()       | |stl-DefaultConstructible|     | The default   |
   |                       |                                | constructor.  |
   |-----------------------+--------------------------------+---------------|
   | bool operator()(const | |stl-BinaryFunction|           | Function call |
   | T& x, const T& y)     |                                | operator. The |
   |                       |                                | return value  |
   |                       |                                | is x >= y.    |
   +------------------------------------------------------------------------+

  New members

   All of greater_equal's members are defined in the
   |stl-AdaptableBinaryPredicate| and |stl-DefaultConstructible|
   requirements. Greater_equal does not introduce any new members.

  See also

   The |stl-functors|, |stl-AdaptableBinaryPredicate|, |stl-equal_to|,
   |stl-not_equal_to|, |stl-greater| |stl-less|, |stl-less_equal|


        ________________________________________________________________________
                                  Logical operations
*stl-logical_and*

                                 logical_and<T>

   Category: functors                                    Component type: type

  Description

   Logical_and<T> is a |stl-functors|; specifically, it is an
   |stl-AdaptableBinaryPredicate|, which means it is a function object that
   tests the truth or falsehood of some condition. If f is an object of class
   logical_and<T> and x and y are objects of class T (where T is convertible
   to bool) then f(x,y) returns true if and only if both x and y are true.
   [2][1]

*stl-logical_and-example*

   Finds the first element in a list that lies in the range from 1 to 10.

 |stl-List|<int> L;
 ...
 |stl-List|<int>::iterator in_range =
      |stl-find_if|(L.begin(), L.end(),
              |stl-binary_compose|(logical_and<bool>(),
                       |stl-binder2nd|(|stl-greater_equal|<int>(), 1),
                       |stl-binder2nd|(|stl-less_equal|<int>(), 10)));
 assert(in_range == L.end() || (*in_range >= 1 && *in_range <= 10));

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [4]function.h.

  Template parameters

   +-----------------------------------------------------------+
   | Parameter |             Description             | Default |
   |-----------+-------------------------------------+---------|
   | T         | The type of logical_and's arguments |         |
   +-----------------------------------------------------------+

  Model of

   |stl-AdaptableBinaryPredicate|, |stl-DefaultConstructible|

  Type requirements

   T must be convertible to bool.

  Public base classes

   |stl-binary_function|<T, T, bool>

  Members

   +------------------------------------------------------------------------+
   |        Member         |         Where defined         |  Description   |
   |-----------------------+-------------------------------+----------------|
   | first_argument_type   | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the first      |
   |                       |                               | argument: T    |
   |-----------------------+-------------------------------+----------------|
   | second_argument_type  | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the second     |
   |                       |                               | argument: T    |
   |-----------------------+-------------------------------+----------------|
   | result_type           | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the result:    |
   |                       |                               | bool           |
   |-----------------------+-------------------------------+----------------|
   | bool operator()(const | |stl-BinaryFunction|          | Function call  |
   | T& x, const T& y)     |                               | operator. The  |
   | const                 |                               | return value   |
   |                       |                               | is x && y.     |
   |-----------------------+-------------------------------+----------------|
   | logical_and()         | |stl-DefaultConstructible|    | The default    |
   |                       |                               | constructor.   |
   +------------------------------------------------------------------------+

  New members

   All of logical_and's members are defined in the
   |stl-AdaptableBinaryFunction| and |stl-DefaultConstructible| requirements.
   Logical_and does not introduce any new members.

  Notes

   [1] Logical_and and |stl-logical_or| are not very useful by themselves.
   They are mainly useful because, when combined with the function object
   adaptor |stl-binary_compose|, they perform logical operations on other
   function objects.

  See also

   The |stl-functors|, |stl-logical_or|, |stl-logical_not|.

*stl-logical_or*

                                 logical_or<T>

   Category: functors                                    Component type: type

  Description

   Logical_or<T> is a |stl-functors|; specifically, it is an
   |stl-AdaptableBinaryPredicate|, which means it is a function object that
   tests the truth or falsehood of some condition. If f is an object of class
   logical_and<T> and x and y are objects of class T (where T is convertible
   to bool) then f(x,y) returns true if and only if either x or y is true.
   [2][1]

*stl-logical_or-example*

   Finds the first instance of either ' ' or '\n' in a string.

 char str[MAXLEN];
 ...
 const char* wptr = |stl-find_if|(str, str + MAXLEN,
                            |stl-binary_compose|(logical_or<bool>(),
                                     |stl-binder2nd|(|stl-equal_to|<char>(), ' '),
                                     |stl-binder2nd|(|stl-equal_to|<char>(), '\n')));
 assert(wptr == str + MAXLEN || *wptr == ' ' || *wptr == '\n');

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [4]function.h.

  Template parameters

   +----------------------------------------------------------+
   | Parameter |            Description             | Default |
   |-----------+------------------------------------+---------|
   | T         | The type of logical_or's arguments |         |
   +----------------------------------------------------------+

  Model of

   |stl-AdaptableBinaryPredicate|, |stl-DefaultConstructible|

  Type requirements

   T must be convertible to bool.

  Public base classes

   |stl-binary_function|<T, T, bool>

  Members

   +------------------------------------------------------------------------+
   |        Member         |         Where defined         |  Description   |
   |-----------------------+-------------------------------+----------------|
   | first_argument_type   | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the first      |
   |                       |                               | argument: T    |
   |-----------------------+-------------------------------+----------------|
   | second_argument_type  | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the second     |
   |                       |                               | argument: T    |
   |-----------------------+-------------------------------+----------------|
   | result_type           | |stl-AdaptableBinaryFunction| | The type of    |
   |                       |                               | the result:    |
   |                       |                               | bool           |
   |-----------------------+-------------------------------+----------------|
   | bool operator()(const | |stl-BinaryFunction|          | Function call  |
   | T& x, const T& y)     |                               | operator. The  |
   | const                 |                               | return value   |
   |                       |                               | is x || y.     |
   |-----------------------+-------------------------------+----------------|
   | logical_or()          | |stl-DefaultConstructible|    | The default    |
   |                       |                               | constructor.   |
   +------------------------------------------------------------------------+

  New members

   All of logical_or's members are defined in the
   |stl-AdaptableBinaryFunction| and |stl-DefaultConstructible| requirements.
   Logical_or does not introduce any new members.

  Notes

   [1] |stl-logical_and| and logical_or are not very useful by themselves.
   They are mainly useful because, when combined with the function object
   adaptor |stl-binary_compose|, they perform logical operations on other
   function objects.

  See also

   The |stl-functors|, |stl-logical_and|, |stl-logical_not|.

*stl-logical_not*

                                 logical_not<T>

   Category: functors                                    Component type: type

  Description

   Logical_not<T> is a |stl-functors|; specifically, it is an
   |stl-AdaptablePredicate|, which means it is a function object that tests
   the truth or falsehood of some condition. If f is an object of class
   logical_not<T> and x is an object of class T (where T is convertible to
   bool) then f(x) returns true if and only if x is false.

*stl-logical_not-example*

   Transforms a vector of bool into its logical complement.

 |stl-Vector|<bool> V;
 ...
 |stl-transform|(V.begin(), V.end(), V.begin(), |stl-logical_not|<bool>());

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h.

  Template parameters

   +----------------------------------------------------------+
   | Parameter |            Description             | Default |
   |-----------+------------------------------------+---------|
   | T         | The type of logical_not's argument |         |
   +----------------------------------------------------------+

  Model of

   |stl-AdaptablePredicate|, |stl-DefaultConstructible|

  Type requirements

   T must be convertible to bool.

  Public base classes

   |stl-unary_function|<T, bool>

  Members

   +------------------------------------------------------------------------+
   |       Member        |        Where defined         |    Description    |
   |---------------------+------------------------------+-------------------|
   | argument_type       | |stl-AdaptableUnaryFunction| | The type of the   |
   |                     |                              | second argument:  |
   |                     |                              | T                 |
   |---------------------+------------------------------+-------------------|
   | result_type         | |stl-AdaptableUnaryFunction| | The type of the   |
   |                     |                              | result: bool      |
   |---------------------+------------------------------+-------------------|
   | bool                | |stl-UnaryFunction|          | Function call     |
   | operator()(const T& |                              | operator. The     |
   | x) const            |                              | return value is   |
   |                     |                              | !x.               |
   |---------------------+------------------------------+-------------------|
   | logical_not()       | |stl-DefaultConstructible|   | The default       |
   |                     |                              | constructor.      |
   +------------------------------------------------------------------------+

  See also

   The |stl-functors|, |stl-logical_or|, |stl-logical_and|.


        ________________________________________________________________________
                           Generalized identity operations
*stl-identity*

                                  identity<T>

   Category: functors                                    Component type: type

  Description

   Identity is a |stl-UnaryFunction| that represents the identity function:
   it takes a single argument x, and returns x.

*stl-identity-example*

 int main()
 {
   int x = 137;
   identity<int> id;
   assert(x == id(x));
 }

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h. This class is an SGI
   extension; it is not part of the C++ standard.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | T         | The function object's argument type, and return  |         |
   |           | type. [4][1]                                     |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-AdaptableUnaryFunction|

  Type requirements

   None.

  Public base classes

   |stl-unary_function|<T, T>

  Members

   +------------------------------------------------------------------------+
   |        Member        |        Where defined         |   Description    |
   |----------------------+------------------------------+------------------|
   | argument_type        | |stl-AdaptableUnaryFunction| | The type of      |
   |                      |                              | identity's       |
   |                      |                              | argument: T.     |
   |----------------------+------------------------------+------------------|
   | result_type          | |stl-AdaptableUnaryFunction| | The type of the  |
   |                      |                              | result: T.       |
   |                      |                              | [5][1]           |
   |----------------------+------------------------------+------------------|
   | const T&             | |stl-AdaptableUnaryFunction| | Function call.   |
   | operator()(const T&) |                              | The return value |
   | const                |                              | is simply the    |
   |                      |                              | argument.        |
   +------------------------------------------------------------------------+

  New members

   All of identity's members are defined in the |stl-AdaptableUnaryFunction|
   requirements. Identity does not introduce any new members.

  Notes

   [1] It is essential that the return type and the argument type are the
   same: generalizing identity to allow them to differ would not work. The
   reason is that identity returns a const reference to its argument, rather
   than a copy of its argument. If identity were allowed to perform a
   conversion, then this would be a dangling reference.

  See also

   The |stl-functors|, |stl-select1st|, |stl-select2nd|, |stl-project1st|,
   |stl-project2nd|

*stl-project1st*

                             project1st<Arg1, Arg2>

   Category: functors                                    Component type: type

  Description

   Project1st is a |stl-functors| that takes two arguments and returns its
   first argument; the second argument is unused. It is essentially a
   generalization of |stl-identity| to the case of a |stl-BinaryFunction|.

*stl-project1st-example*

 int main()
 {
   |stl-Vector|<int> v1(10, 137);
   |stl-Vector|<char*> v2(10, (char*) 0);
   |stl-Vector|<int> result(10);

   |stl-transform|(v1.begin(), v1.end(), v2.begin(), result.begin(),
             project1st<int, char*>());
   assert(|stl-equal|(v1.begin(), v1.end(), result.begin()));
 }

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h. This function object is an
   SGI extension; it is not part of the C++ standard.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | Arg1      | project1st's first argument type, and its result |         |
   |           | type.                                            |         |
   |-----------+--------------------------------------------------+---------|
   | Arg2      | project1st's second argument type.               |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-AdaptableBinaryFunction|

  Type requirements

   None.

  Public base classes

   |stl-binary_function|<Arg1, Arg2, Arg1>

  Members

   +------------------------------------------------------------------------+
   |         Member          |         Where defined         | Description  |
   |-------------------------+-------------------------------+--------------|
   | first_argument_type     | |stl-AdaptableBinaryFunction| | The type of  |
   |                         |                               | project1st's |
   |                         |                               | first        |
   |                         |                               | argument:    |
   |                         |                               | Arg1         |
   |-------------------------+-------------------------------+--------------|
   | second_argument_type    | |stl-AdaptableBinaryFunction| | The type of  |
   |                         |                               | project1st's |
   |                         |                               | second       |
   |                         |                               | argument:    |
   |                         |                               | Arg2         |
   |-------------------------+-------------------------------+--------------|
   | result_type             | |stl-AdaptableBinaryFunction| | The type of  |
   |                         |                               | the result:  |
   |                         |                               | Arg1.        |
   |-------------------------+-------------------------------+--------------|
   | Arg1 operator()(const   | |stl-AdaptableBinaryFunction| | Function     |
   | Arg1& x, const Arg2&)   |                               | call. The    |
   | const                   |                               | return value |
   |                         |                               | is x.        |
   +------------------------------------------------------------------------+

  New members

   All of project1st's members are defined in the
   |stl-AdaptableBinaryFunction| requirements. project1st does not introduce
   any new members.

  See also

   |stl-functors|, |stl-identity|, |stl-project2nd|, |stl-select1st|,
   |stl-select2nd|

*stl-project2nd*

                             project2nd<Arg1, Arg2>

   Category: functors                                    Component type: type

  Description

   Project2nd is a |stl-functors| that takes two arguments and returns its
   second argument; the first argument is unused. It is essentially a
   generalization of |stl-identity| to the case of a |stl-BinaryFunction|.

*stl-project2nd-example*

 int main()
 {
   |stl-Vector|<char*> v1(10, (char*) 0);
   |stl-Vector|<int> v2(10, 137);
   |stl-Vector|<int> result(10);

   |stl-transform|(v1.begin(), v1.end(), v2.begin(), result.begin(),
             project2nd<char*, int>());
   assert(|stl-equal|(v2.begin(), v2.end(), result.begin()));
 }

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h. This function object is an
   SGI extension; it is not part of the C++ standard.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | Arg1      | project2nd's first argument type.                |         |
   |-----------+--------------------------------------------------+---------|
   | Arg2      | project2nd's second argument type, and its       |         |
   |           | result type.                                     |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-AdaptableBinaryFunction|

  Type requirements

   None.

  Public base classes

   |stl-binary_function|<Arg1, Arg2, Arg2>

  Members

   +------------------------------------------------------------------------+
   |         Member          |         Where defined         | Description  |
   |-------------------------+-------------------------------+--------------|
   | first_argument_type     | |stl-AdaptableBinaryFunction| | The type of  |
   |                         |                               | project2nd's |
   |                         |                               | first        |
   |                         |                               | argument:    |
   |                         |                               | Arg1         |
   |-------------------------+-------------------------------+--------------|
   | second_argument_type    | |stl-AdaptableBinaryFunction| | The type of  |
   |                         |                               | project2nd's |
   |                         |                               | second       |
   |                         |                               | argument:    |
   |                         |                               | Arg2         |
   |-------------------------+-------------------------------+--------------|
   | result_type             | |stl-AdaptableBinaryFunction| | The type of  |
   |                         |                               | the result:  |
   |                         |                               | Arg2.        |
   |-------------------------+-------------------------------+--------------|
   | Arg1 operator()(const   | |stl-AdaptableBinaryFunction| | Function     |
   | Arg1&, const Arg2& y)   |                               | call. The    |
   | const                   |                               | return value |
   |                         |                               | is y.        |
   +------------------------------------------------------------------------+

  New members

   All of project2nd's members are defined in the
   |stl-AdaptableBinaryFunction| requirements. project2nd does not introduce
   any new members.

  See also

   |stl-functors|, |stl-identity|, |stl-project1st|, |stl-select1st|,
   |stl-select2nd|

*stl-select1st*

                                select1st<Pair>

   Category: functors                                    Component type: type

  Description

   Select1st is a |stl-functors| that takes a single argument, a |stl-pair|
   [2][1], and returns the pair's first element.

*stl-select1st-example*

   Print all of a |stl-Map|'s keys.

 int main()
 {
   |stl-Map|<int, double> M;
   M[1] = 0.3;
   M[47] = 0.8;
   M[33] = 0.1;

   |stl-transform|(M.begin(), M.end(), |stl-ostream_iterator|<int>(cout, " "),
             select1st<|stl-Map|<int, double>::value_type>());
   // The output is  1 33 47.
 }

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [4]function.h. This function object is an
   SGI extension; it is not part of the C++ standard.

  Template parameters

   +------------------------------------------------------------+
   | Parameter |             Description              | Default |
   |-----------+--------------------------------------+---------|
   | Pair      | The function object's argument type. |         |
   +------------------------------------------------------------+

  Model of

   |stl-AdaptableUnaryFunction||stl-AdaptableUnaryFunction||stl-AdaptableUnaryFunction|

  Type requirements

   There exist some types U and V such that Pair provides the same interface
   as a |stl-pair|<U,V>. [5][1]

  Public base classes

   |stl-unary_function|<Pair, Pair::first_type>

  Members

+---------------------------------------------------------------------------------+
|            Member             |        Where defined        |    Description    |
|-------------------------------+-----------------------------+-------------------|
|argument_type                  ||stl-AdaptableUnaryFunction| |The type of        |
|                               |                             |select1st's        |
|                               |                             |argument: Pair     |
|-------------------------------+-----------------------------+-------------------|
|result_type                    ||stl-AdaptableUnaryFunction| |The type of the    |
|                               |                             |result:            |
|                               |                             |Pair::first_type   |
|-------------------------------+-----------------------------+-------------------|
|const Pair::first_type&        ||stl-AdaptableUnaryFunction| |Function call. The |
|operator()(const Pair& p) const|                             |return value is    |
|                               |                             |p.first.           |
+---------------------------------------------------------------------------------+

  New members

   All of select1st's members are defined in the |stl-AdaptableUnaryFunction|
   requirements. Select1st does not introduce any new members.

  Notes

   [1] Pair is not actually required to be a |stl-pair|<U,V>, but merely to
   support the same interface as |stl-pair|. In almost all cases the template
   parameter will be a |stl-pair|, but it is occasionally useful for it to be
   something else. One example is a struct that has the members first,
   second, and third.

  See also

   |stl-identity|, |stl-select2nd|, |stl-project1st|, |stl-project2nd|

*stl-select2nd*

                                select2nd<Pair>

   Category: functors                                    Component type: type

  Description

   Select2nd is a |stl-functors| that takes a single argument, a |stl-pair|
   [2][1], and returns the pair's second element.

*stl-select2nd-example*

   Print all of a |stl-Map|'s values.

 int main()
 {
   |stl-Map|<int, double> M;
   M[1] = 0.3;
   M[47] = 0.8;
   M[33] = 0.1;

   |stl-transform|(M.begin(), M.end(), |stl-ostream_iterator|<double>(cout, " "),
             select2nd<|stl-Map|<int, double>::value_type>());
   // The output is  0.3 0.1 0.8
 }

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [4]function.h. This function object is an
   SGI extension; it is not part of the C++ standard.

  Template parameters

   +------------------------------------------------------------+
   | Parameter |             Description              | Default |
   |-----------+--------------------------------------+---------|
   | Pair      | The function object's argument type. |         |
   +------------------------------------------------------------+

  Model of

   |stl-AdaptableUnaryFunction|

  Type requirements

   There exist some types U and V such that Pair provides the same interface
   as a |stl-pair|<U,V>. [5][1]

  Public base classes

   |stl-unary_function|<Pair, Pair::second_type>

  Members

+----------------------------------------------------------------------------------+
|            Member             |        Where defined        |    Description     |
|-------------------------------+-----------------------------+--------------------|
|argument_type                  ||stl-AdaptableUnaryFunction| |The type of         |
|                               |                             |select2nd's         |
|                               |                             |argument: Pair      |
|-------------------------------+-----------------------------+--------------------|
|result_type                    ||stl-AdaptableUnaryFunction| |The type of the     |
|                               |                             |result:             |
|                               |                             |Pair::second_type   |
|-------------------------------+-----------------------------+--------------------|
|const Pair::second_type&       ||stl-AdaptableUnaryFunction| |Function call. The  |
|operator()(const Pair& p) const|                             |return value is     |
|                               |                             |p.second.           |
+----------------------------------------------------------------------------------+

  New members

   All of select2nd's members are defined in the |stl-AdaptableUnaryFunction|
   requirements. Select2nd does not introduce any new members.

  Notes

   [1] Pair is not actually required to be a |stl-pair|<U,V>, but merely to
   support the same interface as |stl-pair|. In almost all cases the template
   parameter will be a |stl-pair|, but it is occasionally useful for it to be
   something else. One example is a struct that has the members first,
   second, and third.

  See also

   |stl-identity|, |stl-select1st|, |stl-project1st|, |stl-project2nd|


        ________________________________________________________________________
                                |stl-subtractive_rng|
*stl-subtractive_rng*

                                subtractive_rng

   Category: functors                                    Component type: type

  Description

   Subtractive_rng is a |stl-RandomNumberGenerator| based on the subtractive
   method [2][1]. It is a |stl-UnaryFunction|: it takes a single argument N,
   an unsigned int, and returns an unsigned int that is less than N.
   Successive calls to the same subtractive_rng object [3][2] yield a
   pseudo-random sequence.

*stl-subtractive_rng-example*

 int main()
 {
   subtractive_rng R;
   for (int i = 0; i < 20; ++i)
     cout << R(5) << ' ';
   cout << endl;
 }
 // The output is   3 2 3 2 4 3 1 1 2 2 0 3 4 4 4 4 2 1 0 0

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [5]function.h. This function object is an
   SGI extension; it is not part of the C++ standard.

  Template parameters

   None.

  Model of

   |stl-RandomNumberGenerator|, |stl-AdaptableUnaryFunction|

  Type requirements

   None.

  Public base classes

   |stl-unary_function|<unsigned int, unsigned int>

  Members

 +-----------------------------------------------------------------------------+
 |        Parameter         |         Description         |      Default       |
 |--------------------------+-----------------------------+--------------------|
 |argument_type             ||stl-AdaptableUnaryFunction| |The type of a       |
 |                          |                             |subtractive_rng's   |
 |                          |                             |argument: unsigned  |
 |                          |                             |int.                |
 |--------------------------+-----------------------------+--------------------|
 |result_type               ||stl-AdaptableUnaryFunction| |The type of the     |
 |                          |                             |result: unsigned    |
 |                          |                             |int.                |
 |--------------------------+-----------------------------+--------------------|
 |subtractive_rng(unsigned  |subtractive_rng              |See below.          |
 |int seed)                 |                             |                    |
 |--------------------------+-----------------------------+--------------------|
 |subtractive_rng()         |subtractive_rng              |See below.          |
 |--------------------------+-----------------------------+--------------------|
 |unsigned int              ||stl-AdaptableUnaryFunction| |Function call.      |
 |operator()(unsigned int N)|                             |Returns a           |
 |                          |                             |pseudo-random number|
 |                          |                             |in the range [0, N).|
 |--------------------------+-----------------------------+--------------------|
 |void initialize(unsigned  |subtractive_rng              |See below.          |
 |int seed)                 |                             |                    |
 +-----------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-AdaptableUnaryFunction|
   requirements, but are specific to subtractive_rng.

   +------------------------------------------------------------------------+
   |               Member               |            Description            |
   |------------------------------------+-----------------------------------|
   | subtractive_rng(unsigned int seed) | The constructor. Creates a        |
   |                                    | subtractive_rng whose internal    |
   |                                    | state is initialized using seed.  |
   |------------------------------------+-----------------------------------|
   | subtractive_rng()                  | The default constructor. Creates  |
   |                                    | a subtractive_rng initialized     |
   |                                    | using a default value.            |
   |------------------------------------+-----------------------------------|
   | void initialize(unsigned int seed) | Re-initializes the internal state |
   |                                    | of the subtractive_rng, using the |
   |                                    | value seed.                       |
   +------------------------------------------------------------------------+

  Notes

   [1] See section 3.6 of Knuth for an implementation of the subtractive
   method in FORTRAN. Section 3.2.2 of Knuth analyzes this class of
   algorithms. (D. E. Knuth, The Art of Computer Programming. Volume 2:
   Seminumerical Algorithms, second edition. Addison-Wesley, 1981.)

   [2] Note that the sequence produced by a subtractive_rng is completely
   deterministic, and that the sequences produced by two different
   subtractive_rng objects are independent of each other. That is: if R1 is a
   subtractive_rng, then the values returned when R1 is called depend only on
   R1's seed and on the number of times that R1 has been called. Calls to
   other subtractive_rng objects are irrelevant. In implementation terms,
   this is because the class subtractive_rng contains no static members.

  See also

   |stl-RandomNumberGenerator|




    ----------------------------------------------------------------------------
                             Function object adaptors
    ----------------------------------------------------------------------------
*stl-binder1st*

                       binder1st<AdaptableBinaryFunction>

   Categories: functors, adaptors                        Component type: type

  Description

   Binder1st is a |stl-functors| adaptor: it is used to transform an
   |stl-AdaptableBinaryFunction| into an |stl-AdaptableUnaryFunction|.
   Specifically, if f is an object of class
   binder1st<AdaptableBinaryFunction>, then f(x) returns F(c, x), where F is
   an object of class AdaptableBinaryFunction and where c is a constant. Both
   F and c are passed as arguments to binder1st's constructor. [2][1]

   The easiest way to create a binder1st is not to call the constructor
   explicitly, but instead to use the helper function bind1st.

*stl-binder1st-example*

   Finds the first nonzero element in a list.

 |stl-List|<int> L;
 ...
 |stl-List|<int>::iterator first_nonzero =
        |stl-find_if|(L.begin(), L.end(), bind1st(|stl-not_equal_to|<int>(), 0));
 assert(first_nonzero == L.end() || *first_nonzero != 0);

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [4]function.h.

  Template parameters

   +------------------------------------------------------------------------+
   |        Parameter        |            Description             | Default |
   |-------------------------+------------------------------------+---------|
   | AdaptableBinaryFunction | The type of the binary function    |         |
   |                         | whose first argument is being      |         |
   |                         | bound to a constant.               |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-AdaptableUnaryFunction|

  Type requirements

   AdaptableBinaryFunction must be a model of |stl-AdaptableBinaryFunction|.

  Public base classes

 |stl-unary_function|<|stl-AdaptableBinaryFunction|::second_argument_type,
                |stl-AdaptableBinaryFunction|::result_type>

  Members

+----------------------------------------------------------------------------------------------------------------------------------------+
|                         Member                          |        Where defined        |                  Description                   |
|---------------------------------------------------------+-----------------------------+------------------------------------------------|
|argument_type                                            ||stl-AdaptableUnaryFunction| |The type of the function object's argument,     |
|                                                         |                             |which is                                        |
|                                                         |                             |AdaptableBinaryFunction::second_argument_type   |
|---------------------------------------------------------+-----------------------------+------------------------------------------------|
|result_type                                              ||stl-AdaptableUnaryFunction| |The type of the result:                         |
|                                                         |                             |AdaptableBinaryFunction::result_type            |
|---------------------------------------------------------+-----------------------------+------------------------------------------------|
|result_type operator()(const argument_type& x) const     ||stl-AdaptableUnaryFunction| |Function call. Returns F(c, x), where F and c   |
|                                                         |                             |are the arguments with which this binder1st was |
|                                                         |                             |constructed.                                    |
|---------------------------------------------------------+-----------------------------+------------------------------------------------|
|binder1st(const AdaptableBinaryFunction& F,              |binder1st                    |See below                                       |
|          AdaptableBinaryFunction::first_argument_type c)|                             |                                                |
|---------------------------------------------------------+-----------------------------+------------------------------------------------|
|template <class |stl-AdaptableBinaryFunction|, class T>  |binder1st                    |See below                                       |
|binder1st<|stl-AdaptableBinaryFunction|>                 |                             |                                                |
|bind1st(const AdaptableBinaryFunction& F, const T& c);   |                             |                                                |
+----------------------------------------------------------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-AdaptableUnaryFunction|
   requirements, but are specific to binder1st.

+----------------------------------------------------------------------------------------------------------+
|                         Member                          |                  Description                   |
|---------------------------------------------------------+------------------------------------------------|
|binder1st(const AdaptableBinaryFunction& F,              |The constructor. Creates a binder1st such that  |
|          AdaptableBinaryFunction::first_argument_type c)|calling it with the argument x (where x is of   |
|                                                         |type                                            |
|                                                         |AdaptableBinaryFunction::second_argument_type)  |
|                                                         |corresponds to the call F(c, x).                |
|---------------------------------------------------------+------------------------------------------------|
|template <class |stl-AdaptableBinaryFunction|, class T>  |If F is an object of type                       |
|binder1st<|stl-AdaptableBinaryFunction|>                 |AdaptableBinaryFunction, then bind1st(F, c) is  |
|bind1st(const AdaptableBinaryFunction& F, const T& c);   |equivalent to                                   |
|                                                         |binder1st<AdaptableBinaryFunction>(F, c), but is|
|                                                         |more convenient. The type T must be convertible |
|                                                         |to AdaptableBinaryFunction::first_argument_type.|
|                                                         |This is a global function, not a member         |
|                                                         |function.                                       |
+----------------------------------------------------------------------------------------------------------+

  Notes

   [1] Intuitively, you can think of this operation as "binding" the first
   argument of a binary function to a constant, thus yielding a unary
   function. This is a special case of a closure.

  See also

   The |stl-functors|, |stl-binder2nd|, |stl-AdaptableUnaryFunction|,
   |stl-AdaptableBinaryFunction|

*stl-binder2nd*

                       binder2nd<AdaptableBinaryFunction>

   Categories: functors, adaptors                        Component type: type

  Description

   Binder2nd is a |stl-functors| adaptor: it is used to transform an
   |stl-AdaptableBinaryFunction| into an |stl-AdaptableUnaryFunction|.
   Specifically, if f is an object of class
   binder2nd<AdaptableBinaryFunction>, then f(x) returns F(x, c), where F is
   an object of class AdaptableBinaryFunction and where c is a constant. Both
   F and c are passed as arguments to binder2nd's constructor. [2][1]

   The easiest way to create a binder2nd is not to call the constructor
   explicitly, but instead to use the helper function bind2nd.

*stl-binder2nd-example*

   Finds the first positive number in a list.

 |stl-List|<int> L;
 ...
 |stl-List|<int>::iterator first_positive =
        |stl-find_if|(L.begin(), L.end(), bind2nd(|stl-greater|<int>(), 0));
 assert(first_positive == L.end() || *first_positive > 0);

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [4]function.h.

  Template parameters

   +------------------------------------------------------------------------+
   |        Parameter        |            Description             | Default |
   |-------------------------+------------------------------------+---------|
   | AdaptableBinaryFunction | The type of the binary function    |         |
   |                         | whose second argument is being     |         |
   |                         | bound to a constant.               |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-AdaptableUnaryFunction|

  Type requirements

   AdaptableBinaryFunction must be a model of |stl-AdaptableBinaryFunction|.

  Public base classes

 |stl-unary_function|<|stl-AdaptableBinaryFunction|::first_argument_type,
                |stl-AdaptableBinaryFunction|::result_type>

  Members

+----------------------------------------------------------------------------------------------------------------------------------------+
|                          Member                          |        Where defined        |                  Description                  |
|----------------------------------------------------------+-----------------------------+-----------------------------------------------|
|argument_type                                             ||stl-AdaptableUnaryFunction| |The type of the function object's argument,    |
|                                                          |                             |which is                                       |
|                                                          |                             |AdaptableBinaryFunction::first_argument_type   |
|----------------------------------------------------------+-----------------------------+-----------------------------------------------|
|result_type                                               ||stl-AdaptableUnaryFunction| |The type of the result:                        |
|                                                          |                             |AdaptableBinaryFunction::result_type           |
|----------------------------------------------------------+-----------------------------+-----------------------------------------------|
|result_type operator()(const argument_type& x) const      ||stl-AdaptableUnaryFunction| |Function call. Returns F(x, c), where F and c  |
|                                                          |                             |are the arguments with which this binder1st was|
|                                                          |                             |constructed.                                   |
|----------------------------------------------------------+-----------------------------+-----------------------------------------------|
|binder2nd(const AdaptableBinaryFunction& F,               |binder2nd                    |See below                                      |
|          AdaptableBinaryFunction::second_argument_type c)|                             |                                               |
|----------------------------------------------------------+-----------------------------+-----------------------------------------------|
|template <class |stl-AdaptableBinaryFunction|, class T>   |binder2nd                    |See below                                      |
|binder2nd<|stl-AdaptableBinaryFunction|>                  |                             |                                               |
|bind2nd(const AdaptableBinaryFunction& F, const T& c);    |                             |                                               |
+----------------------------------------------------------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-AdaptableUnaryFunction|
   requirements, but are specific to binder2nd.

+-----------------------------------------------------------------------------------------------------------+
|                          Member                          |                  Description                   |
|----------------------------------------------------------+------------------------------------------------|
|binder2nd(const AdaptableBinaryFunction& F,               |The constructor. Creates a binder2nd such that  |
|          AdaptableBinaryFunction::second_argument_type c)|calling it with the argument x (where x is of   |
|                                                          |type                                            |
|                                                          |AdaptableBinaryFunction::first_argument_type)   |
|                                                          |corresponds to the call F(x, c).                |
|----------------------------------------------------------+------------------------------------------------|
|template <class |stl-AdaptableBinaryFunction|, class T>   |If F is an object of type                       |
|binder2nd<|stl-AdaptableBinaryFunction|>                  |AdaptableBinaryFunction, then bind2nd(F, c) is  |
|bind2nd(const AdaptableBinaryFunction& F, const T& c);    |equivalent to                                   |
|                                                          |binder2nd<AdaptableBinaryFunction>(F, c), but is|
|                                                          |more convenient. The type T must be convertible |
|                                                          |to                                              |
|                                                          |AdaptableBinaryFunction::second_argument_type.  |
|                                                          |This is a global function, not a member         |
|                                                          |function.                                       |
+-----------------------------------------------------------------------------------------------------------+

   [1] Intuitively, you can think of this operation as "binding" the second
   argument of a binary function to a constant, thus yielding a unary
   function. This is a special case of a closure.

  See also

   The |stl-functors|, |stl-binder1st|, |stl-AdaptableUnaryFunction|,
   |stl-AdaptableBinaryFunction|

*stl-ptr_fun*

                                    ptr_fun

   Categories: functors, adaptors                    Component type: function

  Prototype

 template <class Arg, class Result>
 pointer_to_unary_function<Arg, Result>
 ptr_fun(Result (*x)(Arg));

 template <class Arg1, class Arg2, class Result>
 pointer_to_binary_function<Arg1, Arg2, Result>
 ptr_fun(Result (*x)(Arg1, Arg2));

  Description

   Ptr_fun takes a function pointer as its argument and returns a function
   pointer adaptor, a type of |stl-functors|. It is actually two different
   functions, not one (that is, the name ptr_fun is overloaded). If its
   argument is of type Result (*)(Arg) then ptr_fun creates a
   |stl-pointer_to_unary_function|, and if its argument is of type Result
   (*)(Arg1, Arg2) then ptr_fun creates a |stl-pointer_to_binary_function|.

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h.

  Requirements on types

   The argument must be a pointer to a function that takes either one or two
   arguments. The argument type(s) and the return type of the function are
   arbitrary, with the restriction that the function must return a value; it
   may not be a void function.

  Preconditions

  Complexity

*stl-ptr_fun-example*

   See the examples in the discussions of |stl-pointer_to_unary_function| and
   |stl-pointer_to_binary_function|.

  See also

   |stl-functors|, |stl-pointer_to_unary_function|,
   |stl-pointer_to_binary_function|, |stl-AdaptableUnaryFunction|,
   |stl-AdaptableBinaryFunction|

*stl-pointer_to_unary_function*

                     pointer_to_unary_function<Arg, Result>

   Categories: functors, adaptors                        Component type: type

  Description

   Pointer_to_unary_function is a |stl-functors| adaptor that allows a
   function pointer Result (*f)(Arg) to be treated as an
   |stl-AdaptableUnaryFunction|. That is: if F is a
   pointer_to_unary_function<Arg, Result> that was initialized with an
   underlying function pointer f of type Result (*)(Arg), then F(x) calls the
   function f(x). The difference between f and F is that
   pointer_to_unary_function is an |stl-AdaptableUnaryFunction|, i.e. it
   defines the nested typedefs argument_type and result_type.

   Note that a function pointer of type Result (*)(Arg) is a perfectly good
   |stl-UnaryFunction| object, and may be passed to an STL algorithm that
   expects an argument that is a |stl-UnaryFunction|. The only reason for
   using the pointer_to_unary_function object is if you need to use an
   ordinary function in a context that requires an
   |stl-AdaptableUnaryFunction|, e.g. as the argument of a function object
   adaptor.

   Most of the time, you need not declare an object of type
   pointer_to_unary_function directly. It is almost always easier to
   construct one using the |stl-ptr_fun| function.

*stl-pointer_to_unary_function-example*

   The following code fragment replaces all of the numbers in a range with
   their absolute values, using the standard library function fabs. There is
   no need to use a pointer_to_unary_function adaptor in this case.

 |stl-transform|(first, last, first, fabs);

   The following code fragment replaces all of the numbers in a range with
   the negative of their absolute values. In this case we are composing fabs
   and |stl-negate|. This requires that fabs be treated as an
   |stl-AdaptableUnaryFunction|, so we do need to use a
   pointer_to_unary_function adaptor.

 |stl-transform|(first, last, first,
           |stl-unary_compose|(|stl-negate|<double>, |stl-ptr_fun|(fabs)));

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h.

  Template parameters

   +-----------------------------------------------------------+
   | Parameter |             Description             | Default |
   |-----------+-------------------------------------+---------|
   | Arg       | The function object's argument type |         |
   |-----------+-------------------------------------+---------|
   | Result    | The function object's result type   |         |
   +-----------------------------------------------------------+

  Model of

   |stl-AdaptableUnaryFunction|

  Type requirements

     * Arg is |stl-Assignable|.
     * Result is |stl-Assignable|.

  Public base classes

   |stl-unary_function|<Arg, Result>

  Members

+------------------------------------------------------------------------------------+
|                Member                 |        Where defined        | Description  |
|---------------------------------------+-----------------------------+--------------|
|argument_type                          ||stl-AdaptableUnaryFunction| |The type of   |
|                                       |                             |the function  |
|                                       |                             |object's      |
|                                       |                             |argument: Arg.|
|---------------------------------------+-----------------------------+--------------|
|result_type                            ||stl-AdaptableUnaryFunction| |The type of   |
|                                       |                             |the result:   |
|                                       |                             |Result        |
|---------------------------------------+-----------------------------+--------------|
|result_type operator()(argument_type x)||stl-UnaryFunction|          |Function call |
|                                       |                             |operator.     |
|---------------------------------------+-----------------------------+--------------|
|pointer_to_unary_function(Result       |pointer_to_unary_function    |See below.    |
|(*f)(Arg))                             |                             |              |
|---------------------------------------+-----------------------------+--------------|
|pointer_to_unary_function()            |pointer_to_unary_function    |See below.    |
|---------------------------------------+-----------------------------+--------------|
|template <class Arg, class Result>     |pointer_to_unary_function    |See below.    |
|pointer_to_unary_function<Arg, Result> |                             |              |
|ptr_fun(Result (*x)(Arg));             |                             |              |
+------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-AdaptableUnaryFunction|
   requirements, but are specific to pointer_to_unary_function.

+-----------------------------------------------------------------------------------+
|                Member                 |                Description                |
|---------------------------------------+-------------------------------------------|
|pointer_to_unary_function(Result       |The constructor. Creates a                 |
|(*f)(Arg))                             |pointer_to_unary_function whose underlying |
|                                       |function is f.                             |
|---------------------------------------+-------------------------------------------|
|pointer_to_unary_function()            |The default constructor. This creates a    |
|                                       |pointer_to_unary_function that does not    |
|                                       |have an underlying C function, and that    |
|                                       |therefore cannot actually be called.       |
|---------------------------------------+-------------------------------------------|
|template <class Arg, class Result>     |If f is of type Result (*)(Arg) then       |
|pointer_to_unary_function<Arg, Result> |ptr_fun(f) is equivalent to                |
|ptr_fun(Result (*x)(Arg));             |pointer_to_unary_function<Arg,Result>(f),  |
|                                       |but more convenient. This is a global      |
|                                       |function, not a member.                    |
+-----------------------------------------------------------------------------------+

  See also

   |stl-pointer_to_binary_function|, |stl-ptr_fun|,
   |stl-AdaptableUnaryFunction|

*stl-unary_negate*

                        unary_negate<AdaptablePredicate>

   Categories: functors, adaptors                        Component type: type

  Description

   Unary_negate is a |stl-functors| adaptor: it is an
   |stl-AdaptablePredicate| that represents the logical negation of some
   other |stl-AdaptablePredicate|. That is: if f is an object of class
   unary_negate<AdaptablePredicate>, then there exists an object pred of
   class AdaptablePredicate such that f(x) always returns the same value as
   !pred(x). [2][1] There is rarely any reason to construct a unary_negate
   directly; it is almost always easier to use the helper function not1.

*stl-unary_negate-example*

   Finds the first element in a list that does not lie in the range from 1 to
   10.

 |stl-List|<int> L;
 ...
 |stl-List|<int>::iterator in_range =
      |stl-find_if|(L.begin(), L.end(),
              |stl-unary_negate|(|stl-binary_compose|(logical_and<bool>(),
                            |stl-binder2nd|(|stl-greater_equal|<int>(), 1),
                            |stl-binder2nd|(|stl-less_equal|<int>(), 10))));
 assert(in_range == L.end() || !(*in_range >= 1 && *in_range <= 10));

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [4]function.h.

  Template parameters

   +------------------------------------------------------------------------+
   |     Parameter      |               Description               | Default |
   |--------------------+-----------------------------------------+---------|
   | AdaptablePredicate | The type of the function object that    |         |
   |                    | this unary_negate is the logical        |         |
   |                    | negation of.                            |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-AdaptablePredicate|

  Type requirements

   AdaptablePredicate must be a model of |stl-AdaptablePredicate|.

  Public base classes

   |stl-unary_function|<|stl-AdaptablePredicate|::argument_type, bool>

  Members

+---------------------------------------------------------------------------------------------------------------------+
|                   Member                   |        Where defined        |               Description                |
|--------------------------------------------+-----------------------------+------------------------------------------|
|argument_type                               ||stl-AdaptableUnaryFunction| |The type of the argument:                 |
|                                            |                             ||stl-AdaptablePredicate|::argument_type   |
|--------------------------------------------+-----------------------------+------------------------------------------|
|result_type                                 ||stl-AdaptableUnaryFunction| |The type of the result: bool              |
|--------------------------------------------+-----------------------------+------------------------------------------|
|bool operator()(argument_type)              ||stl-UnaryFunction|          |Function call operator.                   |
|--------------------------------------------+-----------------------------+------------------------------------------|
|unary_negate(const AdaptablePredicate& pred)|unary_negate                 |See below.                                |
|--------------------------------------------+-----------------------------+------------------------------------------|
|template <class |stl-AdaptablePredicate|>   |unary_negate                 |See below.                                |
|unary_negate<AdaptablePredicate>            |                             |                                          |
|not1(const AdaptablePredicate& pred);       |                             |                                          |
+---------------------------------------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-AdaptablePredicate|
   requirements, but are specific to unary_negate.

+-----------------------------------------------------------------------------------+
|                   Member                   |             Description              |
|--------------------------------------------+--------------------------------------|
|unary_negate(const AdaptablePredicate& pred)|The constructor. Creates a            |
|                                            |unary_negate<AdaptablePredicate> whose|
|                                            |underlying predicate is pred.         |
|--------------------------------------------+--------------------------------------|
|template <class |stl-AdaptablePredicate|>   |If p is of type AdaptablePredicate    |
|unary_negate<AdaptablePredicate>            |then not1(p) is equivalent to         |
|not1(const AdaptablePredicate& pred);       |unary_negate<AdaptablePredicate>(p),  |
|                                            |but more convenient. This is a global |
|                                            |function, not a member function.      |
+-----------------------------------------------------------------------------------+

  Notes

   [1] Strictly speaking, unary_negate is redundant. It can be constructed
   using the function object |stl-logical_not| and the adaptor
   |stl-unary_compose|.

  See also

   The |stl-functors|, |stl-AdaptablePredicate|, |stl-Predicate|,
   |stl-binary_negate|, |stl-unary_compose|, |stl-binary_compose|

*stl-binary_negate*

                    binary_negate<AdaptableBinaryPredicate>

   Categories: functors, adaptors                        Component type: type

  Description

   Binary_negate is a |stl-functors| adaptor: it is an
   |stl-AdaptableBinaryPredicate| that represents the logical negation of
   some other |stl-AdaptableBinaryPredicate|. That is: if f is an object of
   class binary_negate<AdaptableBinaryPredicate>, then there exists an object
   pred of class AdaptableBinaryPredicate such that f(x,y) always returns the
   same value as !pred(x,y). There is rarely any reason to construct a
   binary_negate directly; it is almost always easier to use the helper
   function not2.

*stl-binary_negate-example*

   Finds the first character in a string that is neither ' ' nor '\n'.

 char str[MAXLEN];
 ...
 const char* wptr = |stl-find_if|(str, str + MAXLEN,
                            |stl-binary_compose|(not2(|stl-logical_or|<bool>()),
                                     |stl-binder2nd|(|stl-equal_to|<char>(), ' '),
                                     |stl-binder2nd|(|stl-equal_to|<char>(), '\n')));
 assert(wptr == str + MAXLEN || !(*wptr == ' ' || *wptr == '\n'));

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h.

  Template parameters

   +------------------------------------------------------------------------+
   |        Parameter         |            Description            | Default |
   |--------------------------+-----------------------------------+---------|
   | AdaptableBinaryPredicate | The type of the function object   |         |
   |                          | that this binary_negate is the    |         |
   |                          | logical negation of.              |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-AdaptableBinaryPredicate|

  Type requirements

   AdaptableBinaryPredicate must be a model of
   |stl-AdaptableBinaryPredicate|.

  Public base classes

 |stl-binary_function|<|stl-AdaptableBinaryPredicate|::first_argument_type,
                 |stl-AdaptableBinaryPredicate|::second_argument_type,
                 bool>

  Members

+------------------------------------------------------------------------------------------------------------------------------------------+
|                      Member                       |        Where defined         |                      Description                      |
|---------------------------------------------------+------------------------------+-------------------------------------------------------|
|first_argument_type                                ||stl-AdaptableBinaryFunction| |The type of the first argument:                        |
|                                                   |                              ||stl-AdaptableBinaryPredicate|::first_argument_type    |
|---------------------------------------------------+------------------------------+-------------------------------------------------------|
|second_argument_type                               ||stl-AdaptableBinaryFunction| |The type of the second argument:                       |
|                                                   |                              ||stl-AdaptableBinaryPredicate|::second_argument_type   |
|---------------------------------------------------+------------------------------+-------------------------------------------------------|
|result_type                                        ||stl-AdaptableBinaryFunction| |The type of the result: bool                           |
|---------------------------------------------------+------------------------------+-------------------------------------------------------|
|binary_negate(const AdaptableBinaryPredicate& pred)|binary_negate                 |See below.                                             |
|---------------------------------------------------+------------------------------+-------------------------------------------------------|
|template <class |stl-AdaptableBinaryPredicate|>    |binary_negate                 |See below.                                             |
|binary_negate<AdaptableBinaryPredicate>            |                              |                                                       |
|not2(const AdaptableBinaryPredicate& pred);        |                              |                                                       |
+------------------------------------------------------------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-AdaptableBinaryPredicate|
   requirements, but are specific to binary_negate.

+-------------------------------------------------------------------------------------------------+
|                      Member                       |                 Description                 |
|---------------------------------------------------+---------------------------------------------|
|binary_negate(const AdaptableBinaryPredicate& pred)|The constructor. Creates a                   |
|                                                   |binary_negate<AdaptableBinaryPredicate> whose|
|                                                   |underlying predicate is pred.                |
|---------------------------------------------------+---------------------------------------------|
|template <class |stl-AdaptableBinaryPredicate|>    |If p is of type AdaptableBinaryPredicate then|
|binary_negate<AdaptableBinaryPredicate>            |not2(p) is equivalent to                     |
|not2(const AdaptableBinaryPredicate& pred);        |binary_negate<AdaptableBinaryPredicate>(p),  |
|                                                   |but more convenient. This is a global        |
|                                                   |function, not a member function.             |
+-------------------------------------------------------------------------------------------------+

  See also

   The |stl-functors|, |stl-AdaptablePredicate|, |stl-Predicate|,
   |stl-unary_negate|, |stl-unary_compose|, |stl-binary_compose|

*stl-unary_compose*

         unary_compose<AdaptableUnaryFunction1,AdaptableUnaryFunction2>

   Categories: functors, adaptors                        Component type: type

  Description

   Unary_compose is a |stl-functors| adaptor. If f and g are both
   |stl-AdaptableUnaryFunction|, and if g's return type is convertible to f's
   argument type, then unary_compose can be used to create a function object
   h such that h(x) is the same as f(g(x)). [2][1] As with other function
   object adaptors, the easiest way to create a unary_compose is to use the
   helper function compose1. It is possible to call unary_compose's
   constructor directly, but there is usually no reason to do so.

*stl-unary_compose-example*

   Calculates the negative of the sines of the elements in a vector, where
   the elements are angles measured in degrees. Since the C library function
   sin takes its arguments in radians, this operation is the composition of
   three operations: negation, sin, and the conversion of degrees to radians.

 vector<double> angles;
 vector<double> sines;
 const double pi = 3.14159265358979323846;
 ...
 assert(sines.size() >= angles.size());
 transform(angles.begin(), angles.end(), sines.begin(),
           compose1(|stl-negate|<double>(),
                    compose1(|stl-ptr_fun|(sin),
                             |stl-binder2nd|(|stl-multiplies|<double>(), pi / 180.))));

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [4]function.h. The unary_compose class is an
   SGI extension; it is not part of the C++ standard.

  Template parameters

   +------------------------------------------------------------------------+
   |        Parameter        |            Description             | Default |
   |-------------------------+------------------------------------+---------|
   | AdaptableUnaryFunction1 | The type of the first operand in   |         |
   |                         | the function composition           |         |
   |                         | operation. That is, if the         |         |
   |                         | composition is written f o g       |         |
   |                         | [5][1], then                       |         |
   |                         | AdaptableUnaryFunction1 is the     |         |
   |                         | type of the function object f.     |         |
   |-------------------------+------------------------------------+---------|
   | AdaptableUnaryFunction2 | The type of the second operand in  |         |
   |                         | the function composition           |         |
   |                         | operation. That is, if the         |         |
   |                         | composition is written f o g       |         |
   |                         | [6][1], then                       |         |
   |                         | AdaptableUnaryFunction1 is the     |         |
   |                         | type of the function object g.     |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-AdaptableUnaryFunction|

  Type requirements

   AdaptableUnaryFunction1 and AdaptableUnaryFunction2 must both be models of
   |stl-AdaptableUnaryFunction|. AdaptableUnaryFunction2::result_type must be
   convertible to AdaptableUnaryFunction1::argument_type.

  Public base classes

 |stl-unary_function|<AdaptableUnaryFunction2::argument_type,
                AdaptableUnaryFunction1::result_type>

  Members

+------------------------------------------------------------------------------------------------------------------------------------------------------------+
|                                      Member                                       |        Where defined        |               Description                |
|-----------------------------------------------------------------------------------+-----------------------------+------------------------------------------|
|argument_type                                                                      ||stl-AdaptableUnaryFunction| |The type of the function object's         |
|                                                                                   |                             |argument:                                 |
|                                                                                   |                             |AdaptableUnaryFunction2::argument_type.   |
|-----------------------------------------------------------------------------------+-----------------------------+------------------------------------------|
|result_type                                                                        ||stl-AdaptableUnaryFunction| |The type of the result:                   |
|                                                                                   |                             |AdaptableUnaryFunction1::result_type      |
|-----------------------------------------------------------------------------------+-----------------------------+------------------------------------------|
|unary_compose(const AdaptableUnaryFunction1& f,                                    |unary_compose                |See below.                                |
|              const AdaptableUnaryFunction2& g);                                   |                             |                                          |
|-----------------------------------------------------------------------------------+-----------------------------+------------------------------------------|
|template <class |stl-AdaptableUnaryFunction|1, class |stl-AdaptableUnaryFunction|2>|unary_compose                |See below.                                |
|unary_compose<AdaptableUnaryFunction1, AdaptableUnaryFunction2>                    |                             |                                          |
|compose1(const AdaptableUnaryFunction1& op1,                                       |                             |                                          |
|         const AdaptableUnaryFunction2& op2);                                      |                             |                                          |
+------------------------------------------------------------------------------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-AdaptableUnaryFunction|
   requirements, but are specific to unary_compose.

+----------------------------------------------------------------------------------------------------------------------------+
|                                      Member                                       |              Description               |
|-----------------------------------------------------------------------------------+----------------------------------------|
|unary_compose(const AdaptableUnaryFunction1& f,                                    |The constructor. Constructs a           |
|              const AdaptableUnaryFunction2& g);                                   |unary_compose object that represents the|
|                                                                                   |function object f o g. [7][1]           |
|-----------------------------------------------------------------------------------+----------------------------------------|
|template <class |stl-AdaptableUnaryFunction|1, class |stl-AdaptableUnaryFunction|2>|Creates a unary_compose object. If f and|
|unary_compose<AdaptableUnaryFunction1, AdaptableUnaryFunction2>                    |g are, respectively, of classes         |
|compose1(const AdaptableUnaryFunction1& op1,                                       |AdaptableUnaryFunction1 and             |
|         const AdaptableUnaryFunction2& op2);                                      |AdaptableUnaryFunction2, then           |
|                                                                                   |compose1(f, g) is equivalent to         |
|                                                                                   |unary_compose<AdaptableUnaryFunction1,  |
|                                                                                   |AdaptableUnaryFunction2>(f, g), but is  |
|                                                                                   |more convenient. This is a global       |
|                                                                                   |function, not a member function.        |
+----------------------------------------------------------------------------------------------------------------------------+

  Notes

   [1] This operation is called function composition, hence the name
   unary_compose. It is often represented in mathematics as the operation f o
   g, where f o g is a function such that (f o g)(x) == f(g(x)). Function
   composition is a very important concept in algebra. It is also extremely
   important as a method of building software components out of other
   components, because it makes it possible to construct arbitrarily
   complicated function objects out of simple ones.

  See also

   The |stl-functors|, |stl-binary_compose|, |stl-binder1st|,
   |stl-binder2nd|.

*stl-binary_compose*

binary_compose<AdaptableBinaryFunction,AdaptableUnaryFunction1,AdaptableUnaryFunction2>

   Categories: functors, adaptors                        Component type: type

  Description

   Binary_compose is a |stl-functors| adaptor. If f is an
   |stl-AdaptableBinaryFunction| and g1 and g2 are both
   |stl-AdaptableUnaryFunction|, and if g1's and g2's return types are
   convertible to f's argument types, then binary_compose can be used to
   create a function object h such that h(x) is the same as f(g1(x), g2(x)).
   [2][1] [3][2]

*stl-binary_compose-example*

   Finds the first element in a list that lies in the range from 1 to 10.

 |stl-List|<int> L;
 ...
 |stl-List|<int>::iterator in_range =
      |stl-find_if|(L.begin(), L.end(),
              compose2(|stl-logical_and|<bool>(),
                       |stl-binder2nd|(|stl-greater_equal|<int>(), 1),
                       |stl-binder2nd|(|stl-less_equal|<int>(), 10)));
 assert(in_range == L.end() || (*in_range >= 1 && *in_range <= 10));

   Computes sin(x)/(x + DBL_MIN) for each element of a range.

 |stl-transform|(first, last, first,
           compose2(|stl-divides|<double>(),
                    |stl-ptr_fun|(sin),
                    |stl-binder2nd|(|stl-plus|<double>(), DBL_MIN)));

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [5]function.h. The binary_compose class is
   an SGI extension; it is not part of the C++ standard.

  Template parameters

   +------------------------------------------------------------------------+
   |        Parameter        |            Description             | Default |
   |-------------------------+------------------------------------+---------|
   | AdaptableBinaryFunction | The type of the "outer" function   |         |
   |                         | in the function composition        |         |
   |                         | operation. That is, if the         |         |
   |                         | binary_compose is a function       |         |
   |                         | object h such that h(x) = f(g1(x), |         |
   |                         | g2(x)), then                       |         |
   |                         | AdaptableBinaryFunction is the     |         |
   |                         | type of f.                         |         |
   |-------------------------+------------------------------------+---------|
   | AdaptableUnaryFunction1 | The type of the first "inner"      |         |
   |                         | function in the function           |         |
   |                         | composition operation. That is, if |         |
   |                         | the binary_compose is a function   |         |
   |                         | object h such that h(x) = f(g1(x), |         |
   |                         | g2(x)), then                       |         |
   |                         | AdaptableBinaryFunction is the     |         |
   |                         | type of g1.                        |         |
   |-------------------------+------------------------------------+---------|
   | AdaptableUnaryFunction2 | The type of the second "inner"     |         |
   |                         | function in the function           |         |
   |                         | composition operation. That is, if |         |
   |                         | the binary_compose is a function   |         |
   |                         | object h such that h(x) = f(g1(x), |         |
   |                         | g2(x)), then                       |         |
   |                         | AdaptableBinaryFunction is the     |         |
   |                         | type of g2.                        |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-AdaptableUnaryFunction|

  Type requirements

   AdaptableBinaryFunction must be a model of |stl-AdaptableBinaryFunction|.
   AdaptableUnaryFunction1 and AdaptableUnaryFunction2 must both be models of
   |stl-AdaptableUnaryFunction|. The argument types of
   AdaptableUnaryFunction1 and AdaptableUnaryFunction2 must be convertible to
   each other. The result types of AdaptableUnaryFunction1 and
   AdaptableUnaryFunction2 must be convertible, respectively, to the first
   and second argument types of AdaptableBinaryFunction.

  Public base classes

 |stl-unary_function|<AdaptableUnaryFunction1::argument_type,
                AdaptableBinaryFunction::result_type>

  Members

+---------------------------------------------------------------------------------------------------------------------------+
|                      Member                       |        Where defined        |               Description               |
|---------------------------------------------------+-----------------------------+-----------------------------------------|
|argument_type                                      ||stl-AdaptableUnaryFunction| |The type of the function object's        |
|                                                   |                             |argument:                                |
|                                                   |                             |AdaptableUnaryFunction::argument_type.   |
|---------------------------------------------------+-----------------------------+-----------------------------------------|
|result_type                                        ||stl-AdaptableUnaryFunction| |The type of the result:                  |
|                                                   |                             |AdaptableBinaryFunction::result_type     |
|---------------------------------------------------+-----------------------------+-----------------------------------------|
|binary_compose(const AdaptableBinaryFunction& f,   |binary_compose               |See below.                               |
|               const AdaptableUnaryFunction1& g1,  |                             |                                         |
|               const AdaptableUnaryFunction1& g2); |                             |                                         |
|---------------------------------------------------+-----------------------------+-----------------------------------------|
|template <class |stl-AdaptableBinaryFunction|,     |binary_compose               |See below.                               |
|          class |stl-AdaptableUnaryFunction|1,     |                             |                                         |
|          class |stl-AdaptableUnaryFunction|2>     |                             |                                         |
|binary_compose<AdaptableBinaryFunction,            |                             |                                         |
|               AdaptableUnaryFunction1,            |                             |                                         |
|               AdaptableUnaryFunction2>            |                             |                                         |
|compose2(const AdaptableBinaryFunction&,           |                             |                                         |
|         const AdaptableUnaryFunction1&,           |                             |                                         |
|         const AdaptableUnaryFunction2&);          |                             |                                         |
+---------------------------------------------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-AdaptableUnaryFunction|
   requirements, but are specific to binary_compose.

+---------------------------------------------------------------------------------------------+
|                      Member                       |               Description               |
|---------------------------------------------------+-----------------------------------------|
|binary_compose(const AdaptableBinaryFunction& f,   |The constructor. Constructs a            |
|               const AdaptableUnaryFunction1& g1,  |binary_compose object such that calling  |
|               const AdaptableUnaryFunction1& g2); |that object with the argument x returns  |
|                                                   |f(g1(x), g2(x)).                         |
|---------------------------------------------------+-----------------------------------------|
|template <class |stl-AdaptableBinaryFunction|,     |Creates a binary_compose object. If f, g,|
|          class |stl-AdaptableUnaryFunction|1,     |and g2 are, respectively, of classes     |
|          class |stl-AdaptableUnaryFunction|2>     |AdaptableBinaryFunction,                 |
|binary_compose<AdaptableBinaryFunction,            |AdaptableUnaryFunction1, and             |
|               AdaptableUnaryFunction1,            |AdaptableUnaryFunction2, then compose2(f,|
|               AdaptableUnaryFunction2>            |g1, g2) is equivalent to                 |
|compose2(const AdaptableBinaryFunction&,           |binary_compose<AdaptableBinaryFunction,  |
|         const AdaptableUnaryFunction1&,           |AdaptableUnaryFunction1,                 |
|         const AdaptableUnaryFunction2&);          |AdaptableUnaryFunction2>(f, g1, g2), but |
|                                                   |is more convenient. This is a global     |
|                                                   |function, not a member function.         |
+---------------------------------------------------------------------------------------------+

  Notes

   [1] This is a form of function composition. The |stl-unary_compose|
   adaptor allows composition of |stl-AdaptableUnaryFunction|; note, however,
   that once binary functions are introduced, there are several possible
   patterns of function composition. The binary_compose allows you to form a
   unary function by putting together two unary functions and a binary
   function, but you could also, for example, imagine putting together two
   unary functions and a binary function to form a binary function. In that
   case, f, g1, and g2 would be combined into a function object h such that
   h(x,y) = f(g1(x), g2(y)).

  See also

   The |stl-functors|, |stl-unary_compose|, |stl-binder1st|, |stl-binder2nd|.

        ________________________________________________________________________
                               Member function adaptors
*stl-mem_fun_t*

                              mem_fun_t<Result, X>

   Categories: functors, adaptors                        Component type: type

  Description

   Mem_fun_t is an adaptor for member functions. If X is some class with a
   member function Result X::f() (that is, a member function that takes no
   arguments and that returns a value of type Result |stl-#1">[1]), then a
   mem_fun_t<Result, X> is a |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | Result    | The member function's return type.               |         |
   |-----------+--------------------------------------------------+---------|
   | X         | The class whose member function the mem_fun_t    |         |
   |           | invokes.                                         |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-AdaptableUnaryFunction|

  Type requirements

     * X has at least one member function that takes no arguments and that
       returns a value of type Result. [4][1]

  Public base classes

   |stl-unary_function|<X*, Result>

  Members

+----------------------------------------------------------------------------------+
|               Member               |        Where defined        |  Description  |
|------------------------------------+-----------------------------+---------------|
|argument_type                       ||stl-AdaptableUnaryFunction| |The type of the|
|                                    |                             |argument: X*   |
|------------------------------------+-----------------------------+---------------|
|result_type                         ||stl-AdaptableUnaryFunction| |The type of the|
|                                    |                             |result: Result |
|------------------------------------+-----------------------------+---------------|
|Result operator()(X* x) const       ||stl-UnaryFunction|          |Function call  |
|                                    |                             |operator.      |
|                                    |                             |Invokes x->f(),|
|                                    |                             |where f is the |
|                                    |                             |member function|
|                                    |                             |that was passed|
|                                    |                             |to the         |
|                                    |                             |constructor.   |
|------------------------------------+-----------------------------+---------------|
|explicit mem_fun_t(Result (X::*f)())|mem_fun_t                    |See below.     |
|------------------------------------+-----------------------------+---------------|
|template <class Result, class X>    |mem_fun_t                    |See below.     |
|mem_fun_t<Result, X>                |                             |               |
|mem_fun(Result (X::*f)());          |                             |               |
+----------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-AdaptableUnaryFunction|
   requirements, but are specific to mem_fun_t.

   +------------------------------------------------------------------------+
   |               Member               |            Description            |
   |------------------------------------+-----------------------------------|
   |explicit mem_fun_t(Result (X::*f)())| The constructor. Creates a        |
   |                                    | mem_fun_t that calls the member   |
   |                                    | function f.                       |
   |------------------------------------+-----------------------------------|
   |template <class Result, class X>    | If f if of type Result (X::*)     |
   |mem_fun_t<Result, X>                | then mem_fun(f) is the same as    |
   |mem_fun(Result (X::*f)());          | mem_fun_t<Result, X>(f), but is   |
   |                                    | more convenient. This is a global |
   |                                    | function, not a member function.  |
   +------------------------------------------------------------------------+

  Notes

   [1] The type Result is permitted to be void. That is, this adaptor may be
   used for functions that return no value. However, this presents
   implementation difficulties. According to the draft C++ standard, it is
   possible to return from a void function by writing return void instead of
   just return. At present, however (early 1998), very few compilers support
   that feature. As a substitute, then, mem_fun_t uses partial specialization
   to support void member functions. If your compiler has not implemented
   partial specialization, then you will not be able to use mem_fun_t with
   member functions whose return type is void.

  See also

   |stl-mem_fun_ref_t|, |stl-mem_fun1_t|, |stl-mem_fun1_ref_t|

*stl-mem_fun_ref_t*

                            mem_fun_ref_t<Result, X>

   Categories: functors, adaptors                        Component type: type

  Description

   Mem_fun_ref_t is an adaptor for member functions. If X is some class with
   a member function Result X::f() (that is, a member function that takes no
   arguments and that returns a value of type Result |stl-#1">[1]), then a
   mem_fun_ref_t<Result, X> is a |stl-functional|, and in the nonstandard
   backward-compatibility header [3]function.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | Result    | The member function's return type.               |         |
   |-----------+--------------------------------------------------+---------|
   | X         | The class whose member function the              |         |
   |           | mem_fun_ref_t invokes.                           |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-AdaptableUnaryFunction|

  Type requirements

     * X has at least one member function that takes no arguments and that
       returns a value of type Result. [4][1]

  Public base classes

   |stl-unary_function|<X, Result>

  Members

+--------------------------------------------------------------------------------------+
|                 Member                 |        Where defined        |  Description  |
|----------------------------------------+-----------------------------+---------------|
|argument_type                           ||stl-AdaptableUnaryFunction| |The type of the|
|                                        |                             |argument: X    |
|----------------------------------------+-----------------------------+---------------|
|result_type                             ||stl-AdaptableUnaryFunction| |The type of the|
|                                        |                             |result: Result |
|----------------------------------------+-----------------------------+---------------|
|Result operator()(X& x) const           ||stl-UnaryFunction|          |Function call  |
|                                        |                             |operator.      |
|                                        |                             |Invokes x.f(), |
|                                        |                             |where f is the |
|                                        |                             |member function|
|                                        |                             |that was passed|
|                                        |                             |to the         |
|                                        |                             |constructor.   |
|----------------------------------------+-----------------------------+---------------|
|explicit mem_fun_ref_t(Result (X::*f)())|mem_fun_ref_t                |See below.     |
|----------------------------------------+-----------------------------+---------------|
|template <class Result, class X>        |mem_fun_ref_t                |See below.     |
|mem_fun_ref_t<Result, X>                |                             |               |
|mem_fun_ref(Result (X::*f)());          |                             |               |
+--------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-AdaptableUnaryFunction|
   requirements, but are specific to mem_fun_ref_t.

   +------------------------------------------------------------------------+
   |                 Member                 |          Description          |
   |----------------------------------------+-------------------------------|
   |explicit mem_fun_ref_t(Result (X::*f)())| The constructor. Creates a    |
   |                                        | mem_fun_ref_t that calls the  |
   |                                        | member function f.            |
   |----------------------------------------+-------------------------------|
   |template <class Result, class X>        | If f is of type Result        |
   |mem_fun_ref_t<Result, X>                | (X::*)() then mem_fun_ref(f)  |
   |mem_fun_ref(Result (X::*f)());          | is the same as                |
   |                                        | mem_fun_ref_t<Result, X>(f),  |
   |                                        | but is more convenient. This  |
   |                                        | is a global function, not a   |
   |                                        | member function.              |
   +------------------------------------------------------------------------+

  Notes

   [1] The type Result is permitted to be void. That is, this adaptor may be
   used for functions that return no value. However, this presents
   implementation difficulties. According to the draft C++ standard, it is
   possible to return from a void function by writing return void instead of
   just return. At present, however (early 1998), very few compilers support
   that feature. As a substitute, then, mem_fun_ref_t uses partial
   specialization to support void member functions. If your compiler has not
   implemented partial specialization, then you will not be able to use
   mem_fun_ref_t with member functions whose return type is void.

  See also

   |stl-mem_fun_t|, |stl-mem_fun1_t|, |stl-mem_fun1_ref_t|

*stl-mem_fun1_t*

                           mem_fun1_t<Result, X, Arg>

   Categories: functors, adaptors                        Component type: type

  Description

   Mem_fun1_t is an adaptor for member functions. If X is some class with a
   member function Result X::f(Arg) (that is, a member function that takes
   one argument of type Arg and that returns a value of type Result [2][1]),
   then a mem_fun1_t<Result, X, Arg> is a |stl-functors| adaptor that makes
   it possible to call f as if it were an ordinary function instead of a
   member function.

   Mem_fun1_t<Result, X, Arg>'s constructor takes a pointer to one of X's
   member functions. Then, like all function objects, mem_fun1_t has an
   operator() that allows the mem_fun1_t to be invoked with ordinary function
   call syntax. In this case, mem_fun1_t's operator() takes two arguments;
   the first is of type X* and the second is of type Arg.

   If F is a mem_fun1_t that was constructed to use the member function X::f,
   and if x is a pointer of type X* and a is a value of type Arg, then the
   expression F(x, a) is equivalent to the expression x->f(a). The difference
   is simply that F can be passed to STL algorithms whose arguments must be
   function objects.

   Mem_fun1_t is one of a family of member function adaptors. These adaptors
   are useful if you want to combine generic programming with inheritance and
   polymorphism, since, in C++, polymorphism involves calling member
   functions through pointers or references.

   As with many other adaptors, it is usually inconvenient to use
   mem_fun1_t's constructor directly. It is usually better to use the helper
   function mem_fun [3][2] instead.

*stl-mem_fun1_t-example*

 struct Operation {
   virtual double eval(double) = 0;
 };

 struct Square : public Operation {
   double eval(double x) { return x * x; }
 };

 struct Negate : public Operation {
   double eval(double x) { return -x; }
 };

 int main() {
   |stl-Vector|<Operation*> operations;
   |stl-Vector|<double> operands;

   operations.push_back(new Square);
   operations.push_back(new Square);
   operations.push_back(new Negate);
   operations.push_back(new Negate);
   operations.push_back(new Square);

   operands.push_back(1);
   operands.push_back(2);
   operands.push_back(3);
   operands.push_back(4);
   operands.push_back(5);

   |stl-transform|(operations.begin(), operations.end(),
             operands.begin(),
             |stl-ostream_iterator|<double>(cout, "\n"),
             mem_fun(Operation::eval));
 }

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [5]function.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | Result    | The member function's return type.               |         |
   |-----------+--------------------------------------------------+---------|
   | X         | The class whose member function the mem_fun1_t   |         |
   |           | invokes.                                         |         |
   |-----------+--------------------------------------------------+---------|
   | Arg       | The member function's argument type.             |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-AdaptableBinaryFunction|

  Type requirements

     * X has at least one member function that takes a single argument of
       type Arg and that returns a value of type Result. [6][1]

  Public base classes

   |stl-binary_function|<X*, Arg, Result>

  Members

+------------------------------------------------------------------------------------------+
|                  Member                   |        Where defined         |  Description  |
|-------------------------------------------+------------------------------+---------------|
|first_argument_type                        ||stl-AdaptableBinaryFunction| |The type of the|
|                                           |                              |first argument:|
|                                           |                              |X*             |
|-------------------------------------------+------------------------------+---------------|
|second_argument_type                       ||stl-AdaptableBinaryFunction| |The type of the|
|                                           |                              |second         |
|                                           |                              |argument: Arg  |
|-------------------------------------------+------------------------------+---------------|
|result_type                                ||stl-AdaptableBinaryFunction| |The type of the|
|                                           |                              |result: Result |
|-------------------------------------------+------------------------------+---------------|
|Result operator()(X* x, Arg a) const       ||stl-BinaryFunction|          |Function call  |
|                                           |                              |operator.      |
|                                           |                              |Invokes        |
|                                           |                              |x->f(a), where |
|                                           |                              |f is the member|
|                                           |                              |function that  |
|                                           |                              |was passed to  |
|                                           |                              |the            |
|                                           |                              |constructor.   |
|-------------------------------------------+------------------------------+---------------|
|explicit mem_fun1_t(Result (X::*f)(Arg))   |mem_fun1_t                    |See below.     |
|-------------------------------------------+------------------------------+---------------|
|template <class Result, class X, class Arg>|mem_fun1_t                    |See below.     |
|mem_fun1_t<Result, X, Arg>                 |                              |               |
|mem_fun(Result (X::*f)(Arg)); [7][2]       |                              |               |
+------------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-AdaptableBinaryFunction|
   requirements, but are specific to mem_fun1_t.

   +------------------------------------------------------------------------+
   |                  Member                   |        Description         |
   |-------------------------------------------+----------------------------|
   |explicit mem_fun1_t(Result (X::*f)(Arg))   | The constructor. Creates a |
   |                                           | mem_fun1_t that calls the  |
   |                                           | member function f.         |
   |-------------------------------------------+----------------------------|
   |template <class Result, class X, class Arg>| If f is of type Result     |
   |mem_fun1_t<Result, X, Arg>                 | (X::*)(Arg) then           |
   |mem_fun(Result (X::*f)(Arg)); [8][2]       | mem_fun(f) is the same as  |
   |                                           | mem_fun1_t<Result, X,      |
   |                                           | Arg>(f), but is more       |
   |                                           | convenient. This is a      |
   |                                           | global function, not a     |
   |                                           | member function.           |
   +------------------------------------------------------------------------+

  Notes

   [1] The type Result is permitted to be void. That is, this adaptor may be
   used for functions that return no value. However, this presents
   implementation difficulties. According to the draft C++ standard, it is
   possible to return from a void function by writing return void instead of
   just return. At present, however (early 1998), very few compilers support
   that feature. As a substitute, then, mem_fun1_t uses partial
   specialization to support void member functions. If your compiler has not
   implemented partial specialization, then you will not be able to use
   mem_fun1_t with member functions whose return type is void.

   [2] This helper function was called mem_fun1 in drafts of the C++
   standard, but it is called mem_fun in the final standard. This
   implementation provides both versions for backward compatibility, but
   mem_fun1 will be removed in a future release.

  See also

   |stl-mem_fun_t|, |stl-mem_fun_ref_t|, |stl-mem_fun1_ref_t|

*stl-mem_fun1_ref_t*

                         mem_fun1_ref_t<Result, X, Arg>

   Categories: functors, adaptors                        Component type: type

  Description

   Mem_fun1_ref_t is an adaptor for member functions. If X is some class with
   a member function Result X::f(Arg) (that is, a member function that takes
   one argument of type Arg and that returns a value of type Result [2][1]),
   then a mem_fun1_ref_t<Result, X, Arg> is a |stl-functors| adaptor that
   makes it possible to call f as if it were an ordinary function instead of
   a member function.

   Mem_fun1_ref_t<Result, X, Arg>'s constructor takes a pointer to one of X's
   member functions. Then, like all function objects, mem_fun1_ref_t has an
   operator() that allows the mem_fun1_ref_t to be invoked with ordinary
   function call syntax. In this case, mem_fun1_ref_t's operator() takes two
   arguments; the first is of type X and the second is of type Arg.

   If F is a mem_fun1_ref_t that was constructed to use the member function
   X::f, and if x is an object of type X and a is a value of type Arg, then
   the expression F(x, a) is equivalent to the expression x.f(a). The
   difference is simply that F can be passed to STL algorithms whose
   arguments must be function objects.

   Mem_fun1_ref_t is one of a family of member function adaptors. These
   adaptors are useful if you want to combine generic programming with
   inheritance and polymorphism, since, in C++, polymorphism involves calling
   member functions through pointers or references. In fact, though,
   mem_fun1_ref_t is usually not as useful as |stl-mem_fun1_t|. The
   difference between the two is that mem_fun1_t's first argument is a
   pointer to an object while mem_fun1_ref_t's argument is a reference to an
   object. References, unlike pointers, can't be stored in STL containers:
   pointers are objects in their own right, but references are merely
   aliases.

   As with many other adaptors, it is usually inconvenient to use
   mem_fun1_ref_t's constructor directly. It is usually better to use the
   helper function mem_fun_ref [3][2] instead.

*stl-mem_fun1_ref_t-example*

   Given a vector of vectors, extract one element from each vector.

 int main() {
   int A1[5] = {1, 2, 3, 4, 5};
   int A2[5] = {1, 1, 2, 3, 5};
   int A3[5] = {1, 4, 1, 5, 9};

   |stl-Vector|<vector<int> > V;
   V.push_back(vector<int>(A1, A1 + 5));
   V.push_back(vector<int>(A2, A2 + 5));
   V.push_back(vector<int>(A3, A3 + 5));

   int indices[3] = {0, 2, 4};

   int& (vector<int>::*extract)(vector<int>::size_type);
   extract = vector<int>::operator[];
   |stl-transform|(V.begin(), V.end(), indices,
             |stl-ostream_iterator|<int>(cout, "\n"),
             mem_fun_ref(extract));
 }

  Definition

   Defined in the standard header |stl-functional|, and in the nonstandard
   backward-compatibility header [5]function.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | Result    | The member function's return type.               |         |
   |-----------+--------------------------------------------------+---------|
   | X         | The class whose member function the              |         |
   |           | mem_fun1_ref_t invokes.                          |         |
   |-----------+--------------------------------------------------+---------|
   | Arg       | The member function's argument type.             |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-AdaptableBinaryFunction|

  Type requirements

     * X has at least one member function that takes a single argument of
       type Arg and that returns a value of type Result. [6][1]

  Public base classes

   |stl-binary_function|<X, Arg, Result>

  Members

+-------------------------------------------------------------------------------------------+
|                   Member                   |        Where defined         |  Description  |
|--------------------------------------------+------------------------------+---------------|
|first_argument_type                         ||stl-AdaptableBinaryFunction| |The type of the|
|                                            |                              |first argument:|
|                                            |                              |X              |
|--------------------------------------------+------------------------------+---------------|
|second_argument_type                        ||stl-AdaptableBinaryFunction| |The type of the|
|                                            |                              |second         |
|                                            |                              |argument: Arg  |
|--------------------------------------------+------------------------------+---------------|
|result_type                                 ||stl-AdaptableBinaryFunction| |The type of the|
|                                            |                              |result: Result |
|--------------------------------------------+------------------------------+---------------|
|Result operator()(X& x, Arg a) const        ||stl-BinaryFunction|          |Function call  |
|                                            |                              |operator.      |
|                                            |                              |Invokes x.f(a),|
|                                            |                              |where f is the |
|                                            |                              |member function|
|                                            |                              |that was passed|
|                                            |                              |to the         |
|                                            |                              |constructor.   |
|--------------------------------------------+------------------------------+---------------|
|explicit mem_fun1_ref_t(Result (X::*f)(Arg))|mem_fun1_ref_t                |See below.     |
|--------------------------------------------+------------------------------+---------------|
|template <class Result, class X, class Arg> |mem_fun1_ref_t                |See below.     |
|mem_fun1_ref_t<Result, X, Arg>              |                              |               |
|mem_fun_ref(Result (X::*f)(Arg)); [7][2]    |                              |               |
+-------------------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-AdaptableBinaryFunction|
   requirements, but are specific to mem_fun1_ref_t.

   +------------------------------------------------------------------------+
   |                   Member                   |        Description        |
   |--------------------------------------------+---------------------------|
   |explicit mem_fun1_ref_t(Result (X::*f)(Arg))| The constructor. Creates  |
   |                                            | a mem_fun1_ref_t that     |
   |                                            | calls the member function |
   |                                            | f.                        |
   |--------------------------------------------+---------------------------|
   |template <class Result, class X, class Arg> | If f is of type Result    |
   |mem_fun1_ref_t<Result, X, Arg>              | (X::*)(Arg) then          |
   |mem_fun1_ref(Result (X::*f)(Arg)); [8][2]   | mem_fun_ref(f) is the     |
   |                                            | same as                   |
   |                                            | mem_fun1_ref_t<Result, X, |
   |                                            | Arg>(f), but is more      |
   |                                            | convenient. This is a     |
   |                                            | global function, not a    |
   |                                            | member function.          |
   +------------------------------------------------------------------------+

  Notes

   [1] The type Result is permitted to be void. That is, this adaptor may be
   used for functions that return no value. However, this presents
   implementation difficulties. According to the draft C++ standard, it is
   possible to return from a void function by writing return void instead of
   just return. At present, however (early 1998), very few compilers support
   that feature. As a substitute, then, mem_fun1_ref_t uses partial
   specialization to support void member functions. If your compiler has not
   implemented partial specialization, then you will not be able to use
   mem_fun1_ref_t with member functions whose return type is void.

   [2] This helper function was called mem_fun1_ref in drafts of the C++
   standard, but it is called mem_fun_ref in the final standard. This
   implementation provides both versions for backward compatibility, but
   mem_fun1_ref will be removed in a future release.

  See also

   |stl-mem_fun_t|, |stl-mem_fun_ref_t|, |stl-mem_fun1_t|




********************************************************************************
                                   Utilities
********************************************************************************
    ----------------------------------------------------------------------------
                                     Concepts
    ----------------------------------------------------------------------------
*stl-Assignable*

                                   Assignable

   Category: utilities                                Component type: concept

  Description

   A type is Assignable if it is possible to copy objects of that type and to
   assign values to variables.

  Refinement of

  Associated types

  Notation

   X    A type that is a model of Assignable
   x, y Object of type X

  Definitions

  Valid expressions

   +-------------------------------------------------------------------+
   |       Name       |  Expression  | Type requirements | Return type |
   |------------------+--------------+-------------------+-------------|
   | Copy constructor | X(x)         |                   | X           |
   |------------------+--------------+-------------------+-------------|
   | Copy constructor |X x(y);       |                   |             |
   |                  |X x = y;      |                   |             |
   |------------------+--------------+-------------------+-------------|
   | Assignment       | x = y [2][1] |                   | X&          |
   |------------------+--------------+-------------------+-------------|
   | Swap             | swap(x,y)    |                   | void        |
   +-------------------------------------------------------------------+

  Expression semantics

  +----------------------------------------------------------------------------+
  |    Name    |   Expression   |Precondition |  Semantics  |  Postcondition   |
  |------------+----------------+-------------+-------------+------------------|
  |Copy        |X(x)            |             |             |X(x) is a copy of |
  |constructor |                |             |             |x [3][2]          |
  |------------+----------------+-------------+-------------+------------------|
  |Copy        |X(x)            |             |             |X(x) is a copy of |
  |constructor |                |             |             |x [4][2]          |
  |------------+----------------+-------------+-------------+------------------|
  |Copy        |X x(y);         |             |             |x is a copy of y  |
  |constructor |X x = y;        |             |             |[5][2]            |
  |------------+----------------+-------------+-------------+------------------|
  |Assignment  |x = y [6][1]    |             |             |x is a copy of y  |
  |            |                |             |             |[7][2]            |
  |------------+----------------+-------------+-------------+------------------|
  |Swap        ||stl-swap|(x,y) |             |Equivalent to|                  |
  |            |                |             |             |                  |
  |            |                |             |{            |                  |
  |            |                |             |  X tmp = x; |                  |
  |            |                |             |  x = y;     |                  |
  |            |                |             |  y = tmp;   |                  |
  |            |                |             |}            |                  |
  +----------------------------------------------------------------------------+

  Complexity guarantees

  Invariants

  Models

     * int

  Notes

   [1] One implication of this requirement is that a const type is not
   Assignable. For example, const int is not Assignable: if x is declared to
   be of type const int, then x = 7 is illegal. Similarly, the type
   |stl-pair|<const int, int> is not Assignable.

   [2] The reason this says "x is a copy of y", rather than "x == y", is that
   operator== is not necessarily defined: equality is not a requirement of
   Assignable. If the type X is |stl-EqualityComparable| as well as
   Assignable, then a copy of x should compare equal to x.

  See also

   |stl-DefaultConstructible|

*stl-DefaultConstructible*

                             Default Constructible

   Category: utilities                                Component type: concept

  Description

   A type is DefaultConstructible if it has a default constructor, that is,
   if it is possible to construct an object of that type without initializing
   the object to any particular value.

  Refinement of

  Associated types

  Notation

   X A type that is a model of DefaultConstructible
   x An object of type X

  Definitions

  Valid expressions

   +---------------------------------------------------------------------+
   |        Name         | Expression  | Type requirements | Return type |
   |---------------------+-------------+-------------------+-------------|
   | Default constructor | X()         |                   | X           |
   |---------------------+-------------+-------------------+-------------|
   | Default constructor | X x; [2][1] |                   |             |
   +---------------------------------------------------------------------+

  Expression semantics

   +------------------------------------------------------------------------+
   |      Name      | Expression | Precondition | Semantics | Postcondition |
   |----------------+------------+--------------+-----------+---------------|
   | Default        | X()        |              |           |               |
   | constructor    |            |              |           |               |
   |----------------+------------+--------------+-----------+---------------|
   | Default        | X x;       |              |           |               |
   | constructor    |            |              |           |               |
   +------------------------------------------------------------------------+

  Complexity guarantees

  Models

     * int
     * |stl-Vector|<double>

  Notes

   [1] The form X x = X() is not guaranteed to be a valid expression, because
   it uses a copy constructor. A type that is DefaultConstructible is not
   necessarily |stl-Assignable|

  See also

   |stl-Assignable|

*stl-EqualityComparable*

                              Equality Comparable

   Category: utilities                                Component type: concept

  Description

   A type is EqualityComparable if objects of that type can be compared for
   equality using operator==, and if operator== is an equivalence relation.

  Refinement of

  Associated types

  Notation

   X       A type that is a model of EqualityComparable
   x, y, z Object of type X

  Definitions

  Valid expressions

   +-------------------------------------------------------------------+
   |    Name    | Expression | Type requirements |     Return type     |
   |------------+------------+-------------------+---------------------|
   | Equality   | x == y     |                   | Convertible to bool |
   |------------+------------+-------------------+---------------------|
   | Inequality | x != y     |                   | Convertible to bool |
   +-------------------------------------------------------------------+

  Expression semantics

   +------------------------------------------------------------------------+
   |    Name    | Expression |  Precondition   | Semantics  | Postcondition |
   |------------+------------+-----------------+------------+---------------|
   | Equality   | x == y     | x and y are in  |            |               |
   |            |            | the domain of   |            |               |
   |            |            | ==              |            |               |
   |------------+------------+-----------------+------------+---------------|
   | Inequality | x != y     | x and y are in  | Equivalent |               |
   |            |            | the domain of   | to !(x ==  |               |
   |            |            | ==              | y)         |               |
   +------------------------------------------------------------------------+

  Complexity guarantees

  Invariants

   +-------------------------------------------------+
   | Identity     | &x == &y implies x == y          |
   |--------------+----------------------------------|
   | Reflexivity  | x == x                           |
   |--------------+----------------------------------|
   | Symmetry     | x == y implies y == x            |
   |--------------+----------------------------------|
   | Transitivity | x == y and y == z implies x == z |
   +-------------------------------------------------+

  Models

     * int
     * |stl-Vector|<int>

  See also

   |stl-LessThanComparable|.

*stl-LessThanComparable*

                              LessThan Comparable

   Category: utilities                                Component type: concept

  Description

   A type is LessThanComparable if it is ordered: it must be possible to
   compare two objects of that type using operator<, and operator< must be a
   partial ordering.

  Refinement of

  Associated types

  Notation

   X       A type that is a model of LessThanComparable
   x, y, z Object of type X

  Definitions

   Consider the relation !(x < y) && !(y < x). If this relation is transitive
   (that is, if !(x < y) && !(y < x) && !(y < z) && !(z < y) implies !(x < z)
   && !(z < x)), then it satisfies the mathematical definition of an
   equivalence relation. In this case, operator< is a strict weak ordering.

   If operator< is a strict weak ordering, and if each equivalence class has
   only a single element, then operator< is a total ordering.

  Valid expressions

   +------------------------------------------------------------------------+
   |      Name       | Expression | Type requirements |     Return type     |
   |-----------------+------------+-------------------+---------------------|
   | Less            | x < y      |                   | Convertible to bool |
   |-----------------+------------+-------------------+---------------------|
   | Greater         | x > y      |                   | Convertible to bool |
   |-----------------+------------+-------------------+---------------------|
   | Less or equal   | x <= y     |                   | Convertible to bool |
   |-----------------+------------+-------------------+---------------------|
   | Greater or      | x >= y     |                   | Convertible to bool |
   | equal           |            |                   |                     |
   +------------------------------------------------------------------------+

  Expression semantics

   +------------------------------------------------------------------------+
   |   Name    | Expression |  Precondition   |  Semantics  | Postcondition |
   |-----------+------------+-----------------+-------------+---------------|
   | Less      | x < y      | x and y are in  |             |               |
   |           |            | the domain of < |             |               |
   |-----------+------------+-----------------+-------------+---------------|
   | Greater   | x > y      | x and y are in  | Equivalent  |               |
   |           |            | the domain of < | to y < x    |               |
   |           |            |                 | [2][1]      |               |
   |-----------+------------+-----------------+-------------+---------------|
   | Less or   | x <= y     | x and y are in  | Equivalent  |               |
   | equal     |            | the domain of < | to !(y < x) |               |
   |           |            |                 | [3][1]      |               |
   |-----------+------------+-----------------+-------------+---------------|
   | Greater   | x >= y     | x and y are in  | Equivalent  |               |
   | or equal  |            | the domain of < | to !(x < y) |               |
   |           |            |                 | [4][1]      |               |
   +------------------------------------------------------------------------+

  Complexity guarantees

  Invariants

   +------------------------------------------------------+
   | Irreflexivity | x < x must be false.                 |
   |---------------+--------------------------------------|
   | Antisymmetry  | x < y implies !(y < x) [5][2]        |
   |---------------+--------------------------------------|
   | Transitivity  | x < y and y < z implies x < z [6][3] |
   +------------------------------------------------------+

  Models

     * int

  Notes

   [1] Only operator< is fundamental; the other inequality operators are
   essentially syntactic sugar.

   [2] Antisymmetry is a theorem, not an axiom: it follows from irreflexivity
   and transitivity.

   [3] Because of irreflexivity and transitivity, operator< always satisfies
   the definition of a partial ordering. The definition of a strict weak
   ordering is stricter, and the definition of a total ordering is stricter
   still.

  See also

   |stl-EqualityComparable|, |stl-StrictWeakOrdering|



    ----------------------------------------------------------------------------
                                    Functions
    ----------------------------------------------------------------------------
*stl-RelationalOperators*

                              Relational Operators

   Category: utilities                               Component type: function

  Prototype

 template <class T> bool operator!=(const T& x, const T& y);
 template <class T> bool operator>(const T& x, const T& y);
 template <class T> bool operator<=(const T& x, const T& y);
 template <class T> bool operator>=(const T& x, const T& y);

  Description

   The |stl-EqualityComparable| requirements specify that it must be possible
   to compare objects using operator!= as well as operator==; similarly, the
   |stl-LessThanComparable| requirements include operator>, operator<= and
   operator>= as well as operator<. Logically, however, most of these
   operators are redundant: all of them can be defined in terms of operator==
   and operator<.

   These four templates use operator== and operator< to define the other four
   relational operators. They exist purely for the sake of convenience: they
   make it possible to write algorithms in terms of the operators !=, >, <=,
   and >=, without requiring that those operators be explicitly defined for
   every type.

   As specified in the |stl-EqualityComparable| requirements, x != y is
   equivalent to !(x == y). As specified in the |stl-LessThanComparable|
   requirements, x > y is equivalent to y < x, x >= y is equivalent to !(x <
   y), and x <= y is equivalent to !(y < x).

  Definition

   Defined in the standard header [2]utility, and in the nonstandard
   backward-compatibility header [3]function.h.

  Requirements on types

   The requirement for operator!= is that x == y is a valid expression for
   objects x and y of type T.

   The requirement for operator> is that y < x is a valid expression for
   objects x and y of type T.

   The requirement for operator<= is that y < x is a valid expression for
   objects x and y of type T.

   The requirement for operator>= is that x < y is a valid expression for
   objects x and y of type T.

  Preconditions

   The precondition for operator!= is that x and y are in the domain of
   operator==.

   The precondition for operator>, operator<=, and operator>= is that x and y
   are in the domain of operator<.

  Complexity

*stl-RelationalOperators-example*

 template <class T> void relations(T x, T y)
 {
   if (x == y) assert(!(x != y));
   else assert(x != y);

   if (x < y) {
     assert(x <= y);
     assert(y > x);
     assert(y >= x);
   }
   else if (y < x) {
     assert(y <= x);
     assert(x < y);
     assert(x <= y);
   }
   else {
     assert(x <= y);
     assert(x >= y);
   }
 }

  See also

   |stl-EqualityComparable|, |stl-LessThanComparable|



    ----------------------------------------------------------------------------
                                     Classes
    ----------------------------------------------------------------------------
*stl-pair*

                                  pair<T1, T2>

   Category: utilities                                   Component type: type

  Description

   Pair<T1,T2> is a heterogeneous pair: it holds one object of type T1 and
   one of type T2. A pair is much like a |stl-Container|, in that it "owns"
   its elements. It is not actually a model of |stl-Container|, though,
   because it does not support the standard methods (such as |stl-Iterators|)
   for accessing the elements of a |stl-Container|.

   Functions that need to return two values often return a pair.

*stl-pair-example*

 pair<bool, double> result = do_a_calculation();
 if (result.first)
   do_something_more(result.second);
 else
   report_error();

  Definition

   Defined in the standard header [2]utility, and in the nonstandard
   backward-compatibility header |stl-pair|.h.

  Template parameters

   +------------------------------------------------------------------------+
   | Parameter |                   Description                    | Default |
   |-----------+--------------------------------------------------+---------|
   | T1        | The type of the first element stored in the pair |         |
   |-----------+--------------------------------------------------+---------|
   | T2        | The type of the second element stored in the     |         |
   |           | pair                                             |         |
   +------------------------------------------------------------------------+

  Model of

   |stl-Assignable|

  Type requirements

   T1 and T2 must both be models of |stl-Assignable|. Additional operations
   have additional requirements. Pair's default constructor may only be used
   if both T1 and T2 are |stl-DefaultConstructible|, operator== may only be
   used if both T1 and T2 are |stl-EqualityComparable|, and operator< may
   only be used if both T1 and T2 are |stl-LessThanComparable|.

  Public base classes

   None.

  Members

+------------------------------------------------------------------------------+
|                   Member                    |  Where defined  | Description  |
|---------------------------------------------+-----------------+--------------|
|first_type                                   |pair             |See below.    |
|---------------------------------------------+-----------------+--------------|
|second_type                                  |pair             |See below.    |
|---------------------------------------------+-----------------+--------------|
|pair()                                       |pair             |The default   |
|                                             |                 |constructor.  |
|                                             |                 |See below.    |
|---------------------------------------------+-----------------+--------------|
|pair(const first_type&, const second_type&)  |pair             |The pair      |
|                                             |                 |constructor.  |
|                                             |                 |See below.    |
|---------------------------------------------+-----------------+--------------|
|pair(const pair&)                            ||stl-Assignable| |The copy      |
|                                             |                 |constructor   |
|---------------------------------------------+-----------------+--------------|
|pair& operator=(const pair&)                 ||stl-Assignable| |The assignment|
|                                             |                 |operator      |
|---------------------------------------------+-----------------+--------------|
|first                                        |pair             |See below.    |
|---------------------------------------------+-----------------+--------------|
|second                                       |pair             |See below.    |
|---------------------------------------------+-----------------+--------------|
|bool operator==(const pair&, const pair&)    |pair             |See below.    |
|---------------------------------------------+-----------------+--------------|
|bool operator<(const pair&, const pair&)     |pair             |See below.    |
|---------------------------------------------+-----------------+--------------|
|template <class T1, class T2>                |pair             |See below.    |
|pair<T1, T2> make_pair(const T1&, const T2&) |                 |              |
+------------------------------------------------------------------------------+

  New members

   These members are not defined in the |stl-Assignable| requirements, but
   are specific to pair.

+------------------------------------------------------------------------------+
|                     Member                     |         Description         |
|------------------------------------------------+-----------------------------|
|first_type                                      |The type of the pair's first |
|                                                |component. This is a typedef |
|                                                |for the template parameter T1|
|------------------------------------------------+-----------------------------|
|second_type                                     |The type of the pair's second|
|                                                |component. This is a typedef |
|                                                |for the template parameter T2|
|------------------------------------------------+-----------------------------|
|pair()                                          |The default constructor. It  |
|                                                |uses constructs objects of   |
|                                                |types T1 and T2 using their  |
|                                                |default constructors. This   |
|                                                |constructor may only be used |
|                                                |if both T1 and T2 are        |
|                                                ||stl-DefaultConstructible|.  |
|------------------------------------------------+-----------------------------|
|pair(const first_type& x, const second_type& y) |The pair constructor.        |
|                                                |Constructs a pair such that  |
|                                                |first is constructed from x  |
|                                                |and second is constructed    |
|                                                |from y.                      |
|------------------------------------------------+-----------------------------|
|first                                           |Public member variable of    |
|                                                |type first_type: the first   |
|                                                |object stored in the pair.   |
|------------------------------------------------+-----------------------------|
|second                                          |Public member variable of    |
|                                                |type second_type: The second |
|                                                |object stored in the pair.   |
|------------------------------------------------+-----------------------------|
|template <class T1, class T2>                   |The equality operator. The   |
|bool operator==(const pair<T1,T2>& x,           |return value is true if and  |
|                const pair<T1,T2>& y);          |only the first elements of x |
|                                                |and y are equal, and the     |
|                                                |second elements of x and y   |
|                                                |are equal. This operator may |
|                                                |only be used if both T1 and  |
|                                                |T2 are                       |
|                                                ||stl-EqualityComparable|.    |
|                                                |This is a global function,   |
|                                                |not a member function.       |
|------------------------------------------------+-----------------------------|
|template <class T1, class T2>                   |The comparison operator. It  |
|bool operator<(const pair<T1,T2>& x,            |uses lexicographic           |
|               const pair<T1,T2>& y);           |comparison: the return value |
|                                                |is true if the first element |
|                                                |of x is less than the first  |
|                                                |element of y, and false if   |
|                                                |the first element of y is    |
|                                                |less than the first element  |
|                                                |of x. If neither of these is |
|                                                |the case, then operator<     |
|                                                |returns the result of        |
|                                                |comparing the second elements|
|                                                |of x and y. This operator may|
|                                                |only be used if both T1 and  |
|                                                |T2 are                       |
|                                                ||stl-LessThanComparable|.    |
|                                                |This is a global function,   |
|                                                |not a member function.       |
|------------------------------------------------+-----------------------------|
|template <class T1, class T2>                   |Equivalent to pair<T1, T2>(x,|
|pair<T1, T2> make_pair(const T1& x, const T2& x)|y). This is a global         |
|                                                |function, not a member       |
|                                                |function. It exists only for |
|                                                |the sake of convenience.     |
+------------------------------------------------------------------------------+

  See also

   |stl-Assignable|, |stl-DefaultConstructible|, |stl-LessThanComparable|






********************************************************************************
                               Memory Allocation
********************************************************************************
    ----------------------------------------------------------------------------
                                     Classes
    ----------------------------------------------------------------------------
*stl-Allocators*

                                   Allocators

   Category: allocators                              Component type: overview

  Summary

   Allocators encapsulate allocation and deallocation of memory. They provide
   a low-level interface that permits efficient allocation of many small
   objects; different allocator types represent different schemes for memory
   management.

   Note that allocators simply allocate and deallocate memory, as opposed to
   creating and destroying objects. The STL also includes several low-level
   algorithms for manipulating uninitialized memory.

   Note also that allocators do not attempt to encapsulate multiple memory
   models. The C++ language only defines a single memory model (the
   difference of two pointers, for example, is always ptrdiff_t), and this
   memory model is the only one that allocators support. This is a major
   change from the definition of allocators in the original STL. [2][1]

  Description

   The details of the allocator interface are still subject to change, and we
   do not guarantee that specific member functions will remain in future
   versions. You should think of an allocator as a "black box". That is, you
   may select a container's memory allocation strategy by instantiating the
   container template with a particular allocator [3][2], but you should not
   make any assumptions about how the container actually uses the allocator.

   The available allocators are as follows. In most cases you shouldn't have
   to worry about the distinction: the default allocator, alloc, is usually
   the best choice.

   +------------------------------------------------------------------------+
   | alloc               | The default allocator. It is thread-safe, and    |
   |                     | usually has the best performance                 |
   |                     | characteristics.                                 |
   |---------------------+--------------------------------------------------|
   | pthread_alloc       | A thread-safe allocator that uses a different    |
   |                     | memory pool for each thread; you can only use    |
   |                     | pthread_alloc if your operating system provides  |
   |                     | pthreads. Pthread_alloc is usually faster than   |
   |                     | alloc, especially on multiprocessor systems. It  |
   |                     | can, however, cause resource fragmentation:      |
   |                     | memory deallocated in one thread is not          |
   |                     | available for use by other threads.              |
   |---------------------+--------------------------------------------------|
   | single_client_alloc | A fast but thread-unsafe allocator. In programs  |
   |                     | that only have one thread, this allocator might  |
   |                     | be faster than alloc.                            |
   |---------------------+--------------------------------------------------|
   | malloc_alloc        | An allocator that simply uses the standard       |
   |                     | library function malloc. It is thread-safe but   |
   |                     | slow; the main reason why you might sometimes    |
   |                     | want to use it is to get more useful information |
   |                     | from bounds-checking or leak-detection tools     |
   |                     | while you are debugging.                         |
   +------------------------------------------------------------------------+

*stl-Allocators-example*

 vector<double> V(100, 5.0);     // Uses the default allocator.
 vector<double, single_client_alloc> local(V.begin(), V.end());

  Concepts

     * Allocator

  Types

     * alloc
     * pthread_alloc
     * single_client_alloc
     * malloc_alloc
     * |stl-raw_storage_iterator|

  Functions

     * |stl-construct|
     * |stl-destroy|
     * |stl-uninitialized_copy|
     * |stl-uninitialized_fill|
     * |stl-uninitialized_fill_n|
     * |stl-get_temporary_buffer|
     * |stl-return_temporary_buffer|

  Notes

   [1] The reason for this change is that the new interface reduces memory
   fragmentation, and that it allows an implementation that is both efficient
   and thread-safe.

   [2] Different containers may use different allocators. You might, for
   example, have some containers that use the default allocator alloc and
   others that use pthread_alloc. Note, however, that vector<int> and
   vector<int, pthread_alloc> are distinct types.

  See also



    ----------------------------------------------------------------------------
                                    Functions
    ----------------------------------------------------------------------------
*stl-construct*

                                   construct

   Category: allocators                              Component type: function

  Prototype

 template <class T1, class T2> void construct(T1* p, const T2& value);

  Description

   In C++, the operator new allocates memory for an object and then creates
   an object at that location by calling a constructor. Occasionally,
   however, it is useful to separate those two operations. [2][1] If p is a
   pointer to memory that has been allocated but not initialized, then
   construct(p, value) creates an object of type T1 at the location pointed
   to by p. The argument value is passed as an argument to T1's constructor.

  Definition

   Defined in the standard header |stl-memory|, and in the nonstandard
   backward-compatibility header [4]algo.h. The construct algorithm is no
   longer part of the C++ standard; it was present in early drafts, and it is
   retained in this implementation for backward compatibility.

  Requirements on types

     * T1 must have a constructor that takes a single argument of type T2.

  Preconditions

     * p is a valid pointer that points to a region of memory whose size is
       at least sizeof(T1).
     * The memory pointed to by p is uninitialized. That is, no object has
       been constructed at the location p.

  Complexity

*stl-construct-example*

 double* dp = (double*) malloc(sizeof(double));
 construct(dp, 3);
 assert(*dp == 3);

  Notes

   [1] In particular, construct, along with other low-level memory allocation
   primitives, is used to implement container classes.

  See also

   |stl-Allocators|, |stl-destroy|, |stl-uninitialized_copy|,
   |stl-uninitialized_fill|, |stl-uninitialized_fill_n|,
   |stl-raw_storage_iterator|

*stl-destroy*

                                    destroy

   Category: allocators                              Component type: function

  Prototype

   Destroy is an overloaded name; there are actually two destroy functions.

 template <class T> void destroy(T* pointer);

 template <class |stl-ForwardIterator|>
 void destroy(ForwardIterator first, ForwardIterator last);

  Description

   In C++, the operator delete destroys an object by calling its destructor,
   and then deallocates the memory where that object was stored.
   Occasionally, however, it is useful to separate those two operations.
   [2][1] Destroy calls an object's destructor without deallocating the
   memory where the object was stored.

   The first version of destroy destroys the object pointed to by pointer by
   calling the destructor T::~T(). The memory pointed to by pointer is not
   deallocated, and can be reused for some other object.

   The second version of destroy destroys all of the objects in the range of
   elements [first, last). It is equivalent to calling destroy(&*i) for each
   iterator i in the range [first, last).

  Definition

   Defined in the standard header |stl-memory|, and in the nonstandard
   backward-compatibility header [4]algo.h. The destroy algorithms are no
   longer part of the C++ standard; they were present in early drafts, and
   they are retained in this implementation for backward compatibility.

  Requirements on types

   For the first version of destroy:

     * T's destructor, ~T, is accessible.

   For the second version of destroy:

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * ForwardIterator is mutable.
     * ForwardIterator's value type has an accessible destructor.

  Preconditions

   For the first version of destroy:

     * pointer points to a valid object of type T.

   For the second version of destroy:

     * [first, last) is a valid range.
     * Each iterator i in [first, last) points to a valid object.

  Complexity

   The run-time complexity of the second version is linear: it calls the
   destructor exactly last - first times.

*stl-destroy-example*

 class Int {
 public:
   Int(int x) : val(x) {}
   int get() { return val; }
 private:
   int val;
 };

 int main()
 {
   Int A[] = { Int(1), Int(2), Int(3), Int(4) };

   destroy(A, A + 4);
   construct(A,     Int(10));
   construct(A + 1, Int(11));
   construct(A + 2, Int(12));
   construct(A + 3,  Int(13));
 }

  Notes

   [1] In particular, destroy, along with other low-level memory allocation
   primitives, is used to implement container classes.

  See also

   |stl-Allocators|, |stl-construct|, |stl-uninitialized_copy|,
   |stl-uninitialized_fill|, |stl-uninitialized_fill_n|,
   |stl-raw_storage_iterator|

*stl-uninitialized_copy*

                               uninitialized_copy

   Categories: allocators, algorithms                Component type: function

  Prototype

 template <class |stl-InputIterator|, class |stl-ForwardIterator|>
 ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                    ForwardIterator result);

  Description

   In C++, the operator new allocates memory for an object and then creates
   an object at that location by calling a constructor. Occasionally,
   however, it is useful to separate those two operations. [2][1] If each
   iterator in the range [result, result + (last - first)) points to
   uninitialized memory, then uninitialized_copy creates a copy of [first,
   last) in that range. That is, for each iterator i in the input range,
   uninitialized_copy creates a copy of *i in the location pointed to by the
   corresponding iterator in the output range by calling
   |stl-construct|(&*(result + (i - first)), *i).

  Definition

   Defined in the standard header |stl-memory|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

     * InputIterator is a model of |stl-InputIterator|.
     * ForwardIterator is a model of |stl-ForwardIterator|.
     * ForwardIterator is mutable.
     * ForwardIterator's value type has a constructor that takes a single
       argument whose type is InputIterator's value type.

  Preconditions

     * [first, last) is a valid range.
     * [result, result + (last - first)) is a valid range.
     * Each iterator in [result, result + (last - first)) points to a region
       of uninitialized memory that is large enough to store a value of
       ForwardIterator's value type.

  Complexity

   Linear. Exactly last - first constructor calls.

*stl-uninitialized_copy-example*

 class Int {
 public:
   Int(int x) : val(x) {}
   int get() { return val; }
 private:
   int val;
 };

 int main()
 {
   int A1[] = {1, 2, 3, 4, 5, 6, 7};
   const int N = sizeof(A1) / sizeof(int);

   Int* A2 = (Int*) malloc(N * sizeof(Int));
   uninitialized_copy(A1, A1 + N, A2);
 }

  Notes

   [1] In particular, this sort of low-level memory management is used in the
   implementation of some container classes.

  See also

   |stl-Allocators|, |stl-construct|, |stl-destroy|,
   |stl-uninitialized_fill|, |stl-uninitialized_fill_n|,
   |stl-raw_storage_iterator|

*stl-uninitialized_copy_n*

                              uninitialized_copy_n

   Categories: allocators, algorithms                Component type: function

  Prototype

 template <class |stl-InputIterator|, class Size, class |stl-ForwardIterator|>
 ForwardIterator uninitialized_copy_n(InputIterator first, Size count,
                                      ForwardIterator result);

  Description

   In C++, the operator new allocates memory for an object and then creates
   an object at that location by calling a constructor. Occasionally,
   however, it is useful to separate those two operations. [2][1] If each
   iterator in the range [result, result + n) points to uninitialized memory,
   then uninitialized_copy_n creates a copy of [first, first + n) in that
   range. That is, for each iterator i in the input range,
   uninitialized_copy_n creates a copy of *i in the location pointed to by
   the corresponding iterator in the output range by calling
   |stl-construct|(&*(result + (i - first)), *i).

  Definition

   Defined in the standard header |stl-memory|, and in the nonstandard
   backward-compatibility header [4]algo.h. This function is an SGI
   extension; it is not part of the C++ standard.

  Requirements on types

     * InputIterator is a model of |stl-InputIterator|.
     * Size is an integral type.
     * ForwardIterator is a model of |stl-ForwardIterator|.
     * ForwardIterator is mutable.
     * ForwardIterator's value type has a constructor that takes a single
       argument whose type is InputIterator's value type.

  Preconditions

     * n >= 0
     * [first, first + n) is a valid range.
     * [result, result + n) is a valid range.
     * Each iterator in [result, result + n) points to a region of
       uninitialized memory that is large enough to store a value of
       ForwardIterator's value type.

  Complexity

   Linear. Exactly n constructor calls.

*stl-uninitialized_copy_n-example*

 class Int {
 public:
   Int(int x) : val(x) {}
   int get() { return val; }
 private:
   int val;
 };

 int main()
 {
   int A1[] = {1, 2, 3, 4, 5, 6, 7};
   const int N = sizeof(A1) / sizeof(int);

   Int* A2 = (Int*) malloc(N * sizeof(Int));
   uninitialized_copy_n(A1, N, A2);
 }

  Notes

   [1] In particular, this sort of low-level memory management is used in the
   implementation of some container classes.

   [2] Uninitialized_copy_n is almost, but not quite, redundant. If first is
   an |stl-InputIterator|, as opposed to a |stl-ForwardIterator|, then the
   uninitialized_copy_n operation can't be expressed in terms of
   |stl-uninitialized_copy|.

  See also

   |stl-Allocators|, |stl-construct|, |stl-destroy|,
   |stl-uninitialized_copy|, |stl-uninitialized_fill|,
   |stl-uninitialized_fill_n|, |stl-raw_storage_iterator|

*stl-uninitialized_fill*

                               uninitialized_fill

   Categories: allocators, algorithms                Component type: function

  Prototype

 template <class |stl-ForwardIterator|, class T>
 void uninitialized_fill(ForwardIterator first, ForwardIterator last,
                         const T& x);

  Description

   In C++, the operator new allocates memory for an object and then creates
   an object at that location by calling a constructor. Occasionally,
   however, it is useful to separate those two operations. [2][1] If each
   iterator in the range [first, last) points to uninitialized memory, then
   uninitialized_fill creates copies of x in that range. That is, for each
   iterator i in the range [first, last), uninitialized_copy creates a copy
   of x in the location pointed to i by calling |stl-construct|(&*i, x).

  Definition

   Defined in the standard header |stl-memory|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * ForwardIterator is mutable.
     * ForwardIterator's value type has a constructor that takes a single
       argument of type T.

  Preconditions

     * [first, last) is a valid range.
     * Each iterator in [first, last) points to a region of uninitialized
       memory that is large enough to store a value of ForwardIterator's
       value type.

  Complexity

   Linear. Exactly last - first constructor calls.

*stl-uninitialized_fill-example*

 class Int {
 public:
   Int(int x) : val(x) {}
   int get() { return val; }
 private:
   int val;
 };

 int main()
 {
   const int N = 137;

   Int val(46);
   Int* A = (Int*) malloc(N * sizeof(Int));
   uninitialized_fill(A, A + N, val);
 }

  Notes

   [1] In particular, this sort of low-level memory management is used in the
   implementation of some container classes.

  See also

   |stl-Allocators|, |stl-construct|, |stl-destroy|,
   |stl-uninitialized_copy|, |stl-uninitialized_fill_n|,
   |stl-raw_storage_iterator|

*stl-uninitialized_fill_n*

                              uninitialized_fill_n

   Categories: allocators, algorithms                Component type: function

  Prototype

 template <class ForwardIterator, class Size, class T>
 ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n,
                                      const T& x);

  Description

   In C++, the operator new allocates memory for an object and then creates
   an object at that location by calling a constructor. Occasionally,
   however, it is useful to separate those two operations. [2][1] If each
   iterator in the range [first, first + n) points to uninitialized memory,
   then uninitialized_fill_n creates copies of x in that range. That is, for
   each iterator i in the range [first, first + n), uninitialized_fill_n
   creates a copy of x in the location pointed to i by calling
   |stl-construct|(&*i, x).

  Definition

   Defined in the standard header |stl-memory|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

     * ForwardIterator is a model of |stl-ForwardIterator|.
     * ForwardIterator is mutable.
     * Size is an integral type that is convertible to ForwardIterator's
       distance type.
     * ForwardIterator's value type has a constructor that takes a single
       argument of type T.

  Preconditions

     * n is nonnegative.
     * [first, first + n) is a valid range.
     * Each iterator in [first, first + n) points to a region of
       uninitialized memory that is large enough to store a value of
       ForwardIterator's value type.

  Complexity

   Linear. Exactly n constructor calls.

*stl-uninitialized_fill_n-example*

 class Int {
 public:
   Int(int x) : val(x) {}
   int get() { return val; }
 private:
   int val;
 };

 int main()
 {
   const int N = 137;

   Int val(46);
   Int* A = (Int*) malloc(N * sizeof(Int));
   uninitialized_fill_n(A, N, val);
 }

  Notes

   [1] In particular, this sort of low-level memory management is used in the
   implementation of some container classes.

  See also

   |stl-Allocators|, |stl-construct|, |stl-destroy|,
   |stl-uninitialized_copy|, |stl-uninitialized_fill|,
   |stl-raw_storage_iterator|

*stl-temporary_buffer*

                      temporary_buffer<ForwardIterator, T>

   Category: allocators                                  Component type: type

  Description

   Some algorithms, such as |stl-stable_sort| and |stl-inplace_merge|, are
   adaptive: they attempt to use extra temporary memory to store intermediate
   results, and their run-time complexity is better if that extra memory is
   available. These algorithms use temporary_buffer to allocate that extra
   memory.

   temporary_buffer's constructor takes two arguments, first and last, of
   type ForwardIterator; the constructor allocates a buffer that is large
   enough to contain N objects of type T, where 0 <= N <= last - first
   [2][1], and it fills the buffer with objects of type T. The member
   functions begin() and end() return iterators that point to the beginning
   and the end of the buffer.

   Note that the elements in the buffer are guaranteed to be initialized;
   that is, begin() points to an object of type T, not to raw memory.
   However, the initial values of the buffer's elements are unspecified. You
   should not rely on them to be initialized to any particular value.

   temporary_buffer does not have a copy constructor, or an assignment
   operator. Those operations would have complicated, and not terribly
   useful, semantics.

   (Earlier versions of the STL used |stl-get_temporary_buffer| and
   |stl-return_temporary_buffer| instead of temporary_buffer.
   temporary_buffer is more convenient, because it does not require using
   |stl-uninitialized_copy|, and in some cases it is also more efficient.
   Additionally, it is much easier to write exception-safe code with
   temporary_buffer than with |stl-get_temporary_buffer| and
   |stl-return_temporary_buffer|.)

*stl-temporary_buffer-example*

 int main()
 {
   vector<int> V(50);
   iota(V.begin(), V.end(), 1);

   temporary_buffer<vector<int>::iterator, int> buf(V.begin(), V.end());
   copy(V.rbegin(), V.rbegin() + buf.size(), buf.begin());
   copy(buf.begin(), buf.end(), ostream_iterator<int>(cout, "\n"));
 }

  Definition

   Defined in the standard header |stl-memory|, and in the nonstandard
   backward-compatibility header [4]algo.h. This class is an SGI extension;
   it is not part of the C++ standard.

  Template parameters

+-------------------------------------------------------------------------------------------+
|   Parameter    |      Description      |                     Default                      |
|----------------+-----------------------+--------------------------------------------------|
|ForwardIterator |The type of the        |                                                  |
|                |iterators passed as    |                                                  |
|                |arguments to           |                                                  |
|                |temporary_buffer's     |                                                  |
|                |constructor.           |                                                  |
|----------------+-----------------------+--------------------------------------------------|
|T               |The type of object     ||stl-iterator_traits|<ForwardIterator>::value_type|
|                |stored in the temporary|[5][2]                                            |
|                |buffer.                |                                                  |
+-------------------------------------------------------------------------------------------+

  Model of

   None. temporary_buffer is vaguely similar to a |stl-Container|, but it
   does not provide the entire |stl-Container| interface. In particular, it
   is not a model of |stl-DefaultConstructible| or |stl-Assignable|.

  Type requirements

     * ForwardIterator is a model of |stl-ForwardIterator|
     * ForwardIterator is mutable.
     * T has a constructor that can take a single argument of
       ForwardIterator's value type.

  Public base classes

   None.

  Members

   +------------------------------------------------------------------------+
   |                 Member                 |          Description          |
   |----------------------------------------+-------------------------------|
   |temporary_buffer(ForwardIterator first, | Allocates a temporary buffer  |
   |                 ForwardIterator last)  | that holds at most last -     |
   |                                        | first elements of type T, and |
   |                                        | constructs those elements.    |
   |                                        | The initial values of the     |
   |                                        | elements are unspecified.     |
   |                                        | Precondition: [first, last)   |
   |                                        | is a valid range.             |
   |----------------------------------------+-------------------------------|
   | ~temporary_buffer()                    | Destroys the elements in the  |
   |                                        | temporary buffer, and         |
   |                                        | deallocates the buffer        |
   |                                        | itself.                       |
   |----------------------------------------+-------------------------------|
   | T* begin()                             | Returns a pointer to the      |
   |                                        | first element in the buffer.  |
   |----------------------------------------+-------------------------------|
   | T* end()                               | Returns a pointer that points |
   |                                        | one past the last element in  |
   |                                        | the buffer.                   |
   |----------------------------------------+-------------------------------|
   | ptrdiff_t requested_size() const       | Returns the value last -      |
   |                                        | first, where first and last   |
   |                                        | are the arguments that were   |
   |                                        | passed to the constructor.    |
   |----------------------------------------+-------------------------------|
   | ptrdiff_t size() const                 | Returns the number of         |
   |                                        | elements in the temporary     |
   |                                        | buffer, end() - begin(). The  |
   |                                        | return value satisfies the    |
   |                                        | constraint 0 <= size() <=     |
   |                                        | requested_size().             |
   +------------------------------------------------------------------------+

  New members

  Notes

   [1] The requested size is last - first. The size of the temporary buffer
   is never larger than the requested size, but it might well be smaller; the
   size might even be zero. The intention is that temporary_buffer will
   allocate as large a buffer as is possible without hurting performance.
   Note that determining this maximum size is quite difficult: it depends on
   cache size, physical versus virtual memory, heap fragmentation, and so on.
   A good implementation of temporary_buffer must be nonportable.

   [2] The |stl-iterator_traits| mechanism relies on partial specialization
   of templates. If your compiler does not yet implement this features, then
   you will not be able to use this default parameter; you will have to
   provide both template arguments.

  See also

*stl-get_temporary_buffer*

                              get_temporary_buffer

   Category: allocators                              Component type: function

  Prototype

 template <class T>
 |stl-pair|<T*, ptrdiff_t> get_temporary_buffer(ptrdiff_t len, T*);

  Description

   Some algorithms, such as |stl-stable_sort| and |stl-inplace_merge|, are
   adaptive: they attempt to use extra temporary memory to store intermediate
   results, and their run-time complexity is better if that extra memory is
   available.

   The first argument to get_temporary_buffer specifies the requested size of
   the temporary buffer, and the second specifies the type of object that
   will be stored in the buffer. That is, get_temporary_buffer(len, (T*) 0)
   requests a buffer that is aligned for objects of type T and that is large
   enough to hold len objects of type T. [2][1]

   The return value of get_temporary_buffer is a |stl-pair| P whose first
   component is a pointer to the temporary buffer and whose second argument
   indicates how large the buffer is: the buffer pointed to by P.first is
   large enough to hold P.second objects of type T. P.second is greater than
   or equal to 0 [3][2], and less than or equal to len [4][1]. Note that
   P.first is a pointer to uninitialized memory, rather than to actual
   objects of type T; this memory can be initialized using
   |stl-uninitialized_copy|, |stl-uninitialized_fill|, or
   |stl-uninitialized_fill_n|.

   As the name suggests, get_temporary_buffer should only be used to obtain
   temporary memory. If a function allocates memory using
   get_temporary_buffer, then it must deallocate that memory, using
   |stl-return_temporary_buffer| [5][3], before it returns.

   Note: get_temporary_buffer and |stl-return_temporary_buffer| are only
   provided for backward compatibility. If you are writing new code, you
   should instead use the |stl-temporary_buffer| class.

  Definition

   Defined in the standard header |stl-memory|, and in the nonstandard
   backward-compatibility header [7]algo.h.

  Requirements on types

  Preconditions

     * len is greater than 0.

  Complexity

*stl-get_temporary_buffer-example*

 int main()
 {
   pair<int*, ptrdiff_t> P = get_temporary_buffer(10000, (int*) 0);
   int* buf = P.first;
   ptrdiff_t N = P.second;
   |stl-uninitialized_fill_n|(buf, N, 42);
   int* result = |stl-find_if|(buf, buf + N, |stl-binder2nd|(|stl-not_equal_to|<int>(), 42));
   assert(result == buf + N);
   |stl-return_temporary_buffer|(buf);
 }

  Notes

   [1] The argument len is a request, rather than a requirement. The
   intention is that get_temporary_buffer will return as large a buffer as
   can be allocated without hurting performance. Note that determining this
   maximum size is quite difficult: it depends on cache size, physical versus
   virtual memory, heap fragmentation, and so on. A good implementation of
   get_temporary_buffer must be nonportable.

   [2] If P.second is 0, this means that get_temporary_buffer was unable to
   allocate a temporary buffer at all. In that case, P.first is a null
   pointer.

   [3] It is unspecified whether get_temporary_buffer is implemented using
   malloc, or ::operator new, or some other method. The only portable way to
   return memory that was allocated using get_temporary_buffer is to use
   |stl-return_temporary_buffer|.

  See also

   |stl-temporary_buffer|, |stl-return_temporary_buffer|, |stl-Allocators|

*stl-return_temporary_buffer*

                            return_temporary_buffer

   Category: allocators                              Component type: function

  Prototype

 template <class T> void return_temporary_buffer(T* p);

  Description

   Return_temporary_buffer is used to deallocate memory that was allocated
   using |stl-get_temporary_buffer|. [2][1]

   Note: |stl-get_temporary_buffer| and return_temporary_buffer are only
   provided for backward compatibility. If you are writing new code, you
   should instead use the |stl-temporary_buffer| class.

  Definition

   Defined in the standard header |stl-memory|, and in the nonstandard
   backward-compatibility header [4]algo.h.

  Requirements on types

  Preconditions

   The argument p is a pointer to a block of memory that was allocated using
   |stl-get_temporary_buffer|(ptrdiff_t, T*).

  Complexity

*stl-return_temporary_buffer-example*

 int main()
 {
   pair<int*, ptrdiff_t> P = |stl-get_temporary_buffer|(10000, (int*) 0);
   int* buf = P.first;
   ptrdiff_t N = P.second;
   |stl-uninitialized_fill_n|(buf, N, 42);
   int* result = |stl-find_if|(buf, buf + N, |stl-binder2nd|(|stl-not_equal_to|<int>(), 42));
   assert(result == buf + N);
   return_temporary_buffer(buf);
 }

  Notes

   [1] As is always true, memory that was allocated using a particular
   allocation function must be deallocated using the corresponding
   deallocation function. Memory obtained using |stl-get_temporary_buffer|
   must be deallocated using return_temporary_buffer, rather than using free
   or ::operator delete.

  See also

   |stl-temporary_buffer|, |stl-get_temporary_buffer|, |stl-Allocators|






********************************************************************************
                               Design Documents
********************************************************************************
    ----------------------------------------------------------------------------
                           Thread-safety for SGI STL         *stl-thread_safety*
    ----------------------------------------------------------------------------


   [2]SGI STL provides what we believe to be the most useful form of
   thread-safety. This explains some of the design decisions made in the SGI
   STL implementation.

Client must lock shared mutable containers

   The SGI implementation of STL is thread-safe only in the sense that
   simultaneous accesses to distinct containers are safe, and simultaneous
   read accesses to to shared containers are safe. If multiple threads access
   a single container, and at least one thread may potentially write, then
   the user is responsible for ensuring mutual exclusion between the threads
   during the container accesses.

   This is the only way to ensure full performance for containers that do not
   need concurrent access. Locking or other forms of synchronization are
   typically expensive and should be avoided when not necessary.

   It is easy for the client or another library to provide the necessary
   locking by wrapping the underlying container operations with a lock
   acquisition and release. For example, it would be possible to provide a
   locked_queue container adapter that provided a container with atomic queue
   operations.

   For most clients, it would be insufficient to simply make container
   operations atomic; larger grain atomic actions are needed. If a user's
   code needs to increment the third element in a vector of counters, it
   would be insuffcient to guarantee that fetching the third element and
   storing the third element is atomic; it is also necessary to guarantee
   that no other updates occur in the middle. Thus it would be useless for
   vector operations to acquire the lock; the user code must provide for
   locking in any case.

   This decision is different from that made by the Java designers. There are
   two reasons for that. First, for security reasons Java must guarantee that
   even in the presence of unprotected concurrent accesses to a container,
   the integrity of the virtual machine cannot be violated. Such safety
   constraints were clearly not a driving force behind either C++ or STL.
   Secondly, performance was a more important design goal for STL then it was
   for the Java standard library.

   On the other hand, this notion of thread-safety is stronger than that
   provided by reference-counted string implementations that try to follow
   the CD2 version of the draft standard. Such implementations require
   locking between multiple readers of a shared string.

Lock implementation

   The SGI STL implementation removes all nonconstant static data from
   container implementations. The only potentially shared static data resides
   in the allocator implementations. To this end, the code to implement
   per-class node allocation in HP STL was transformed into inlined code for
   per-size node allocation in the SGI STL allocators. Currently the only
   explicit locking is performed inside |stl-allocators|.

   Many other container implementations should also benefit from this design.
   It will usually be possible to implement thread-safe containers in
   portable code that does not depend on any particular thread package or
   locking primitives.

   Alloc.h uses three different locking primitives depending on the
   environment. In addition, it can be forced to perform no locking by
   defining _NOTHREADS. The three styles of locking are:

     * Pthread mutexes. These are used if _PTHREADS is defined by the user.
       This may be done on SGI machines, but is not recommended in
       performance critical code with the currently (March 1997) released
       versions of the SGI Pthreads libraries.
     * Win32 critical sections. These are used by default for win32
       compilations with compiler options that request multi-threaded code.
     * An SGI specific spin-lock implementation that is usable with both
       pthread and sproc threads. This could serve as a prototype
       implementation for other platforms. This is the default on SGI/MIPS
       platforms.

   It would be preferable if we could always use the OS-supplied locking
   primitives. Unfortunately, these often do not perform well, for very short
   critical sections such as those used by the allocator.

   Allocation intensive applications using Pthreads to obtain concurrency on
   multiprocessors should consider using pthread_alloc from
   [4]pthread_alloc.h. It imposes the restriction that memory deallocated by
   a thread can only be reallocated by that thread. However, it often obtains
   significant performance advantages as a result.



    ----------------------------------------------------------------------------
                         STL Complexity Specifications          *stl-complexity*
    ----------------------------------------------------------------------------


   STL container, algorithm, and concept specifications include asymptotic
   complexity specifications. For example, iterators are required to take
   constant time, that is the time required by an iterator operation should
   be no more than a fixed constant, independent of the size of the container
   to which it refers.

   Clearly programs will still function if a program component ignores the
   complexity specifications. Nonetheless, these specifications are an
   important part of the interface between STL components and code that uses
   them. If they are ignored, the performance of the resulting program will
   often render it useless.

   As an example, consider the STL |stl-vector| container. Ignoring the
   complexity specification, it is possible to implement vector using the
   same underlying data structure as |stl-list|, i.e. as a doubly linked list.
   But for a vector of length 10,000, this would probably slow down an
   average computation of v[i] by something like a factor of 5,000. For a
   program that requires many vector accesses, such as a typical numerical
   computation, this is likely to change an execution time of minutes to
   days.

   This does not preclude the use of STL algorithms in conjunction with
   containers or iterators that do not meet the standard complexity
   specifications. This is occasionally quite useful, especially if the code
   is either not performance critical, or other requirements on the container
   make the performance specifications unrealizable. But this has two
   potential problems. First, the algorithm may no longer be the right one,
   or even a reasonable one, for the problem. A different algorithm may be
   better tailored to actual relative costs of the container operations.
   Second, the algorithm is, of course, unlikely to satisfy its specified
   complexity constraint.

   The complexity specifications in STL are, of necessity, an
   oversimplification. A full specification would describe exactly how the
   running time of an operation varies with that of the operations it
   invokes. The result would be rather unmanageable for the user, who would
   have to be keep track of large amounts of irrelevent detail. It would be
   overly constraining on the implementor, since overall improvements on the
   existing algorithms may not satisfy such detailed constraints.

   Concept specifications (e.g. |stl-Forward-Iterator| or |stl-Container|) specify
   complexity requirements that should be met by all instances of the
   concept. This is the minimum behavior required by operations (e.g.
   |stl-sort|) parameterized with respect to the concept. Any specific instance
   (e.g. |stl-vector|) is likely to perform better in at least some cases.

   It is difficult to specify precisely when an algorithm satisfies a
   performance constraint. Does copying a vector on a 16-bit embedded
   processor take constant time? After all, the size of the |stl-vector| is
   limited to some value less than 65,536. Thus the number of memory
   operations involved in the copy operation is certainly bounded by a
   constant. It is even conceivable that the worst case vector copy time on
   this processor may be less than the worst-case time for a single memory
   access on a machine with paged virtual memory. Nonetheless, it would be
   intuitively wrong to describe a vector copy or a list traversal as being a
   constant time operation. Even on this machine, a vector implemented as a
   list is unlikely to yield satisfactory performance. (Of course, so would
   an implementation that looped for a second for every vector access,
   although that would clearly run in constant time. The point here is to
   communicate the proper intent between implementor and user, not to guard
   against malicious or silly implementations.)

   Fundamentally, it is difficult to define the notion of asymptotic
   algorithm complexity precisely for real computer hardware instead of an
   abstract machine model. Thus we settle for the following guidelines:

    1. For an algorithm A to have running time O(f(n)), there must be a
       corresponding algorithm A' that is correct on machines with
       arbitrarily long pointer and size_t types, such that A and A' perform
       essentially the same sequence of operations on the actual hardware.
       (In simple cases A and A' will be the same. In other cases A may have
       been simplified with the knowledge that adresses are bounded.) For
       inputs of sufficiently large size n, A' must take at most time Cf(n),
       where C is a constant, independent of both n and the address size.
       (Pointer, size_t, and ptrdiff_t operations are presumed to take
       constant time independent of their size.)
    2. All container or iterator complexity specifications refer to amortized
       complexity. An individual operation may take longer than specified.
       But any sufficiently long sequence of operations on the same container
       or iterator will take at most as long as the corresponding sum of the
       specified operation costs.
    3. Algorithms specify either worst-case or average case performance, and
       identify which. Unless otherwise stated, averages assume that
       container elements are chosen from a finite type with more possible
       values than the size of the container, and that container elements are
       independently uniformly distributed.
    4. A complexity specification for an operation f assumes that operations
       invoked by f require at most the specified runtime. But algorithms
       generally remain appropriate if the invoked operations are no more
       than a logarithmic factor slower than specified in the expected case.
    5. If operations are more expensive than assumed by a function F in the
       current STL, then F will slow down at most in proportion to the added
       cost. Any future operations that fail to satisfy this property will
       make that explicit.

       To make this precise, assume F is specified to use time f(m) for input
       of size m. F uses operations G[k], with specified running times
       g[k](n) on input size n. If F is used in a context in which each G[k]
       is slower than expected by at most a factor h(n), then F slows down by
       at most a factor h(m). This holds because none of the current
       algorithms ever apply the operations G[k] to inputs significantly
       larger than m.



    ----------------------------------------------------------------------------
                           Respresentations of strings
    ----------------------------------------------------------------------------
*stl-string_discussion*

                               Strings in SGI STL

   This is an attempt to answer some of the questions related to the use of
   strings with SGI STL.

What's wrong with the string class defined by the draft standard?

   There are several problems, but the most serious ones relate to the
   specification for lifetimes of references to characters in a string. The
   second committee draft disallows the expression s[1] == s[2] where s is a
   nonconstant string. This is not simply an oversight; current reference
   counted implementations may fail for more complicated examples. They may
   fail even for s[1] == s[2] if the string s is simultaneously examined
   (merely examined, not necessarily modified) by another thread. It is hard
   to define precisely what constitutes a correct use of one of the current
   reference counted implementation.

   This problem was partially addressed at the July 1997 meeting of the C++
   standardization committee; the solution was to adopt more complicated
   rules about reference lifetimes. Unfortunately, these new rules still do
   not address the multi-threading issues.

   A related problem was pointed out in the French national body comments on
   the second committee draft. The following program produces the wrong
   answer for most reference counted basic_string implementations that we
   have tested; the problem is that, if two strings share a common
   representation, they are vulnerable to modification through a pre-existing
   reference or iterator.

 # include &ltstring>
 # include &ltstdio.h>

 main() {
    string s("abc");
    string t;
    char & c(s[1]);

    t = s;       // Data typically shared between s and t.
    c = 'z';     // How many strings does this modify?
    if (t[1] == 'z') {
         printf("wrong\n");
    } else {
         printf("right\n");
    }
 }

   The draft standard (as well as common sense) says that updating a
   reference to one of s's elements should only modify s, not t as well; the
   fact that s and t might share a representation is an implementation detail
   that should have no effect on program behavior. Given the design of
   basic_string, though, it is very difficult for a reference-counted
   implementation to satisfy that requirement.

   The only known way for a reference-counted implementation to avoid this
   problem is to mark a string as unsharable whenever there might be an
   existing reference or iterator to that string. That is, whenever a program
   obtains a reference or an iterator to a string (e.g. by using operator[]
   or begin()), that particular string will no longer use reference counting;
   assignment and copy construction will copy the string's elements instead
   of just copying a pointer. (We are not aware of any implementation that
   uses this technique and that also attempts to be thread-safe.)

   This is a drastic solution: since almost all ways of referring to
   characters involve references or iterators, this solution implies, in
   effect, that the only strings that can be reference-counted are the ones
   that are never used. In practice, then, a reference counted implementation
   of basic_string can't achieve the performance gains that one might
   otherwise expect, since reference counting is forbidden in all but a few
   special cases.

   A different solution is to abandon the goal of reference-counted strings
   altogether, and to provide a non-reference-counted implementation of
   basic_string instead. The draft standard permits non-reference-counted
   implementations, and several vendors already provide them. The performance
   characteristics of a non-reference-counted basic_string are predicable,
   and are very similar to those of a vector&ltchar>: copying a string, for
   example, is always an O(N) operation.

   In this implementation, |stl-basic_string| does not use reference
   counting.

I have been using a reference counted implementation, and it works fine. Why
haven't I seen problems?

   The current implementations do work correctly, most of the time:
   preserving a reference to a character in a string is uncommon. (Although
   preserving iterators to strings may be more frequent, and exactly the same
   issues apply to iterators.) Some less contrived sequential programs also
   fail, though, or else behave differently on different platforms.

   Multi-threaded applications that use a reference counted basic_string are
   likely to fail intermittently, perhaps once every few months; these
   intermittent failures are difficult to reproduce and debug. But it is
   likely that a large fraction of multi-threaded clients will fail
   occasionally, thus making such a library completely inappropriate for
   multi-threaded use.

So what should I use to represent strings?

   There are several possible options, which are appropriate under different
   circumstances:

   [2]Ropes
           Use the |stl-rope| package provided by the SGI STL. This provides all
           functionality that's likely to be needed. Its interface is similar
           to the current draft standard, but different enough to allow a
           correct and thread-safe implementation. It should perform
           reasonably well for all applications that do not require very
           frequent small updates to strings. It is the only alternative that
           scales well to very long strings, i.e. that could easily be used
           to represent a mail message or a text file as a single string.

           The disadvantages are:

              * Single character replacements are slow. Consequently STL
                algorithms are likely to be slow when updating ropes.
                (Insertions near the beginning take roughly the same amount
                of time as single character replacements, and much less time
                than corresponding insertions for the other string
                alternatives.)
              * The |stl-rope| implementation stretches current compiler
                technology. Portability and compilation time may be an issue
                in the short term. Pthread performance on non-SGI platforms
                will be an issue until someone provides machine-specific fast
                reference counting code. (This is also likely to be an issue
                for other reference counted implementations.)

   C strings
           This is likely to be the most efficient way to represent a large
           collection of very short strings. It is by far the most space
           efficient alternative for small strings. For short strings, the C
           library functions in <string.h> provide an efficient set of tools
           for manipulating such strings. They allow easy communication with
           the C library. The primary disadvantages are that

              * Operations such as concatenation and substring are much more
                expensive than for [5]ropes if the strings are long. A C
                string is not a good representation for a text file in an
                editor.
              * The user needs to be aware of sharing between string
                representations. If strings are assigned by copying pointers,
                an update to one string may affect another.
              * C strings provide no help in storage management. This may be
                a major issue, although a garbage collector can help
                alleviate it.

   |stl-vector|<char>
           If a string is treated primarily as an array of characters, with
           frequent in-place updates, it is reasonable to represent it as
           |stl-vector|<char> or |stl-vector|<wchar_t>. The same is true if it will
           be modified by STL container algorithms. Unlike C strings, vectors
           handle internal storage management automatically, and operations
           that modify the length of a string are generally more convenient.

           Disadvantages are:

              * Vector assignments are much more expensive than C string
                pointer assignments; the only way to share string
                representations is to pass pointers or references to vectors.
              * Most operations on entire strings (e.g. assignment,
                concatenation) do not scale well to long strings.
              * A number of standard string operations (e.g. concatenation
                and substring) are not provided with the usual syntax, and
                must be expressed using generic STL algorithms. This is
                usually not hard.
              * Conversion to C strings is currently slow, even for short
                strings. That may change in future implementations.

What about mstring.h, as supplied with SGI's 7.1 compiler?

   This package was a minimal adaptation of the freely available Modena
   strings package. It was intended as a stopgap. We do not intend to develop
   it further.

   It shares some of the reference lifetime problems of other implementations
   that try to conform to the draft standard. Its exact semantics were never
   well-defined. Under rare conditions, it will have unexpected semantics for
   single-threaded applications. It fails on the example given above. We
   strongly discourage use for multi-threaded applications.


********************************************************************************
                      Index: The Standard Template Library           *stl-index*
********************************************************************************

    |stl-accumulate|
    |stl-AdaptableBinaryFunction|
    |stl-AdaptableBinaryPredicate|
    |stl-AdaptableGenerator|
    |stl-AdaptablePredicate|
    |stl-AdaptableUnaryFunction|
    |stl-adjacent_difference|
    |stl-adjacent_find|
    |stl-advance|
    |stl-Allocators|
    |stl-Assignable|
    |stl-AssociativeContainer|
    |stl-BackInsertionSequence|
    |stl-back_insert_iterator|
    |stl-basic_string|
    |stl-BidirectionalIterator|
    |stl-bidirectional_iterator|
    |stl-bidirectional_iterator_tag|
    |stl-BinaryFunction|
    |stl-BinaryPredicate|
    |stl-binary_compose|
    |stl-binary_function|
    |stl-binary_negate|
    |stl-binary_search|
    |stl-binder1st|
    |stl-binder2nd|
    |stl-bit_vector|
    |stl-bitset|
    |stl-char_producer|
    |stl-char_traits|
    |stl-character_traits|
    |stl-construct|
    |stl-Container|
    |stl-copy|
    |stl-copy_backward|
    |stl-copy_n|
    |stl-count|
    |stl-count_if|
    |stl-DefaultConstructible|
    |stl-Deque|
    |stl-destroy|
    |stl-distance|
    |stl-distance_type|
    |stl-divides|
    |stl-equal|
    |stl-equal_range|
    |stl-equal_to|
    |stl-EqualityComparable|
    |stl-fill|
    |stl-fill_n|
    |stl-find|
    |stl-find_end|
    |stl-find_first_of|
    |stl-find_if|
    |stl-for_each|
    |stl-ForwardContainer|
    |stl-ForwardIterator|
    |stl-forward_iterator|
    |stl-forward_iterator_tag|
    |stl-FrontInsertionSequence|
    |stl-front_insert_iterator|
    |stl-functors|
    |stl-generate|
    |stl-generate_n|
    |stl-Generator|
    |stl-get_temporary_buffer|
    |stl-greater|
    |stl-greater_equal|
    |stl-HashFunction|
    |stl-hash|
    |stl-hash_map|
    |stl-hash_multimap|
    |stl-hash_multiset|
    |stl-hash_set|
    |stl-HashedAssociativeContainer|
    |stl-identity|
    |stl-includes|
    |stl-inner_product|
    |stl-inplace_merge|
    |stl-InputIterator|
    |stl-input_iterator|
    |stl-input_iterator_tag|
    |stl-insert_iterator|
    |stl-iota|
    |stl-is_heap|
    |stl-is_sorted|
    |stl-istream_iterator|
    |stl-iter_swap|
    |stl-iterator_tags|
    |stl-iterator_category|
    |stl-iterator_traits|
    |stl-Iterators|
    |stl-less|
    |stl-less_equal|
    |stl-LessThanComparable|
    |stl-lexicographical_compare|
    |stl-lexicographical_compare_3way|
    |stl-List|
    |stl-logical_and|
    |stl-logical_not|
    |stl-logical_or|
    |stl-lower_bound|
    |stl-make_heap|
    |stl-Map|
    |stl-max|
    |stl-max_element|
    |stl-mem_fun1_ref_t|
    |stl-mem_fun1_t|
    |stl-mem_fun_ref_t|
    |stl-mem_fun_t|
    |stl-merge|
    |stl-min|
    |stl-min_element|
    |stl-minus|
    |stl-mismatch|
    |stl-modulus|
    |stl-MonoidOperation|
    |stl-Multimap|
    |stl-MultipleAssociativeContainer|
    |stl-MultipleHashedAssociativeContainer|
    |stl-MultipleSortedAssociativeContainer|
    |stl-multiplies|
    |stl-multiset|
    |stl-negate|
    |stl-next_permutation|
    |stl-not_equal_to|
    |stl-nth_element|
    |stl-ostream_iterator|
    |stl-OutputIterator|
    |stl-output_iterator|
    |stl-output_iterator_tag|
    |stl-PairAssociativeContainer|
    |stl-pair|
    |stl-partial_sort|
    |stl-partial_sort_copy|
    |stl-partial_sum|
    |stl-partition|
    |stl-plus|
    |stl-pointer_to_binary_function|
    |stl-pointer_to_unary_function|
    |stl-pop_heap|
    |stl-power|
    |stl-Predicate|
    |stl-prev_permutation|
    |stl-priority_queue|
    |stl-project1st|
    |stl-project2nd|
    |stl-ptr_fun|
    |stl-push_heap|
    |stl-queue|
    |stl-RandomAccessContainer|
    |stl-RandomAccessIterator|
    |stl-RandomNumberGenerator|
    |stl-random_access_iterator|
    |stl-random_access_iterator_tag|
    |stl-random_sample|
    |stl-random_sample_n|
    |stl-random_shuffle|
    |stl-raw_storage_iterator|
    |stl-RelationalOperators|
    |stl-remove|
    |stl-remove_copy|
    |stl-remove_copy_if|
    |stl-remove_if|
    |stl-replace|
    |stl-replace_copy|
    |stl-replace_copy_if|
    |stl-replace_if|
    |stl-return_temporary_buffer|
    |stl-reverse|
    |stl-ReverseBidirectionalIterator|
    |stl-reverse_copy|
    |stl-ReverseIterator|
    |stl-ReversibleContainer|
    |stl-Rope|
    |stl-rotate|
    |stl-rotate_copy|
    |stl-search|
    |stl-search_n|
    |stl-select1st|
    |stl-select2nd|
    |stl-Sequence|
    |stl-sequence_buffer|
    |stl-set|
    |stl-set_difference|
    |stl-set_intersection|
    |stl-set_symmetric_difference|
    |stl-set_union|
    |stl-SimpleAssociativeContainer|
    |stl-Slist|
    |stl-sort|
    |stl-sort_heap|
    |stl-SortedAssociativeContainer|
    |stl-stable_partition|
    |stl-stable_sort|
    |stl-stack|
    |stl-StrictWeakOrdering|
    |stl-subtractive_rng|
    |stl-swap|
    |stl-swap_ranges|
    |stl-temporary_buffer|
    |stl-transform|
    |stl-TrivialIterator|
    |stl-UnaryFunction|
    |stl-unary_compose|
    |stl-unary_function|
    |stl-unary_negate|
    |stl-uninitialized_copy|
    |stl-uninitialized_copy_n|
    |stl-uninitialized_fill|
    |stl-uninitialized_fill_n|
    |stl-unique|
    |stl-UniqueAssociativeContainer|
    |stl-UniqueHashedAssociativeContainer|
    |stl-UniqueSortedAssociativeContainer|
    |stl-unique_copy|
    |stl-upper_bound|
    |stl-value_type|
    |stl-Vector|

********************************************************************************
*stlrefvim-license*         License and Copyright          *stlrefvim-copyright*
********************************************************************************

stlrefvim Copyright (c) 2008 Daniel Price

The scripts of the project stlrefvim are released under the GNU General Public
License 2 (GPL 2) or later

'The Standard Template Library Programmer's Guide' is
    copyright (c) 1993-2006 Silicon Graphics, Inc

SGI STL License
--------------------------------------------------------------------------
Permission to use, copy, modify, distribute and sell this software and its
documentation for any purpose is hereby granted without fee, provided that the
below copyright notice appears in all copies and that both the copyright
notice and this permission notice appear in supporting documentation. Silicon
Graphics makes no representations about the suitability of this software for
any purpose. It is provided as is without express or implied warranty.
Copyright © 1994
Hewlett-Packard Company


********************************************************************************
                               Acknowledgements     *stlrefvim-acknowledgements*
********************************************************************************
This vim documentation and script would not be possible were it not for
the generous efforts of SGI and HP in creating and documenting the STL.

Many thanks must also go to Christian Habermann's for his crefvim plugin
that formed the basis of and was the inspiration for this plugin


 vim:tw=78:ts=8:ft=help:norl:
